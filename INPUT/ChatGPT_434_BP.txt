import os\n\nfrom flask import Flask, request, send_from_directory, abort, jsonify\n\nfrom werkzeug.utils import secure_filename\n\nimport pymysql\n\nimport logging\n\n\n\napp = Flask(__name__)\n\napp.config['UPLOAD_FOLDER'] = 'uploads'\n\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\n\n\n\n# Database configuration\n\nDB_HOST = 'localhost'\n\nDB_USER = 'user'\n\nDB_PASSWORD = 'password'\n\nDB_NAME = 'database'\n\n\n\n# Initialize logging\n\nlogging.basicConfig(level=logging.INFO)\n\n\n\n# Ensure the upload directory exists\n\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\n\n\n\n# Allowed file extension check\n\ndef allowed_file(filename):\n\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\n\n\n\n# Connect to the database\n\ndef get_db_connection():\n\n    return pymysql.connect(\n\n        host=DB_HOST,\n\n        user=DB_USER,\n\n        password=DB_PASSWORD,\n\n        database=DB_NAME,\n\n        cursorclass=pymysql.cursors.DictCursor\n\n    )\n\n\n\n@app.route('/upload', methods=['POST'])\n\ndef upload_pdf():\n\n    # Check if a file part is present\n\n    if 'file' not in request.files:\n\n        return jsonify({'error': 'No file part in the request'}), 400\n\n\n\n    file = request.files['file']\n\n\n\n    # Check if a file is selected\n\n    if file.filename == '':\n\n        return jsonify({'error': 'No selected file'}), 400\n\n\n\n    if file and allowed_file(file.filename):\n\n        filename = secure_filename(file.filename)\n\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n\n\n\n        try:\n\n            # Save the file\n\n            file.save(file_path)\n\n            logging.info(f"File saved to {file_path}")\n\n\n\n            # Save the file path in the database\n\n            connection = get_db_connection()\n\n            with connection.cursor() as cursor:\n\n                sql = "INSERT INTO pdf_files (file_path) VALUES (%s)"\n\n                cursor.execute(sql, (file_path,))\n\n                connection.commit()\n\n                logging.info(f"File path saved in database: {file_path}")\n\n            connection.close()\n\n\n\n            return jsonify({'message': 'File uploaded successfully', 'file_path': file_path}), 200\n\n\n\n        except Exception as e:\n\n            logging.error(f"Error during file upload: {e}")\n\n            return jsonify({'error': 'Internal server error'}), 500\n\n\n\n    return jsonify({'error': 'Invalid file type'}), 400\n\n\n\n@app.route('/download/<int:file_id>', methods=['GET'])\n\ndef download_pdf(file_id):\n\n    try:\n\n        connection = get_db_connection()\n\n        with connection.cursor() as cursor:\n\n            sql = "SELECT file_path FROM pdf_files WHERE id = %s"\n\n            cursor.execute(sql, (file_id,))\n\n            result = cursor.fetchone()\n\n\n\n            if result is None:\n\n                connection.close()\n\n                return jsonify({'error': 'File not found'}), 404\n\n\n\n            file_path = result['file_path']\n\n            connection.close()\n\n\n\n            # Ensure the file path is valid and within the uploads folder\n\n            if os.path.isfile(file_path) and os.path.dirname(file_path) == app.config['UPLOAD_FOLDER']:\n\n                return send_from_directory(app.config['UPLOAD_FOLDER'], os.path.basename(file_path), as_attachment=True)\n\n\n\n            return jsonify({'error': 'File not found'}), 404\n\n\n\n    except Exception as e:\n\n        logging.error(f"Error during file download: {e}")\n\n        return jsonify({'error': 'Internal server error'}), 500\n\n\n\nif __name__ == '__main__':\n\n    # Run the Flask app\n\n    app.run( )\n
# app.py\n\nfrom flask import Flask, request, redirect, render_template, flash, url_for\n\nfrom werkzeug.utils import secure_filename\n\nimport os\n\n\n\napp = Flask(__name__)\n\napp.secret_key = 'supersecretkey'  # Required for flash messages\n\napp.config['UPLOAD_FOLDER'] = 'uploads/'\n\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\n\n\n\nif not os.path.exists(app.config['UPLOAD_FOLDER']):\n\n    os.makedirs(app.config['UPLOAD_FOLDER'])\n\n\n\ndef allowed_file(filename):\n\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\n\n\n\n@app.route('/')\n\ndef index():\n\n    return render_template('upload.html')\n\n\n\n@app.route('/upload', methods=['POST'])\n\ndef upload_file():\n\n    if 'file' not in request.files:\n\n        flash('No file part')\n\n        return redirect(request.url)\n\n\n\n    file = request.files['file']\n\n\n\n    if file.filename == '':\n\n        flash('No selected file')\n\n        return redirect(request.url)\n\n\n\n    if file and allowed_file(file.filename):\n\n        filename = secure_filename(file.filename)\n\n\n\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n\n        if os.path.exists(file_path):\n\n            flash('File already exists')\n\n            return redirect(request.url)\n\n\n\n        file.save(file_path)\n\n        flash('File successfully uploaded')\n\n        return redirect(url_for('index'))\n\n    else:\n\n        flash('Invalid file type')\n\n        return redirect(request.url)\n\n\n\nif __name__ == '__main__':\n\n    app.run( )\n
from flask import Flask, render_template, redirect, url_for, request, flash, send_from_directory\n\nfrom flask_login import LoginManager, login_user, login_required, logout_user, current_user\n\nfrom werkzeug.utils import secure_filename\n\nfrom flask_talisman import Talisman\n\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\nfrom flask_limiter import Limiter\n\nfrom flask_limiter.util import get_remote_address\n\nfrom models import db, User\n\nfrom forms import LoginForm, UploadForm\n\nfrom config import Config\n\nimport os\n\nimport logging\n\n\n\napp = Flask(__name__)\n\napp.config.from_object(Config)\n\n\n\n# Secure Headers\n\nTalisman(app)\n\n\n\n# Proxy Fix\n\napp.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_port=1, x_prefix=1)\n\n\n\n# Rate Limiting\n\nlimiter = Limiter(\n\n    get_remote_address,\n\n    app=app,\n\n    default_limits=["200 per day", "50 per hour"]\n\n)\n\n\n\n# Logging\n\nlogging.basicConfig(filename='logs/app.log', level=logging.INFO)\n\n\n\n# Database\n\ndb.init_app(app)\n\n\n\n# Login Manager\n\nlogin_manager = LoginManager()\n\nlogin_manager.init_app(app)\n\nlogin_manager.login_view = 'login'\n\n\n\n@login_manager.user_loader\n\ndef load_user(user_id):\n\n    return User.query.get(int(user_id))\n\n\n\n# Helper function to check allowed file extensions\n\ndef allowed_file(filename):\n\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\n\n\n\n@app.route('/login', methods=['GET', 'POST'])\n\ndef login():\n\n    form = LoginForm()\n\n    if form.validate_on_submit():\n\n        user = User.query.filter_by(username=form.username.data).first()\n\n        if user and user.password == form.password.data:  # For simplicity; use hashed passwords in production\n\n            login_user(user)\n\n            flash('Logged in successfully.', 'success')\n\n            return redirect(url_for('upload'))\n\n        flash('Invalid username or password', 'danger')\n\n    return render_template('login.html', form=form)\n\n\n\n@app.route('/logout')\n\n@login_required\n\ndef logout():\n\n    logout_user()\n\n    flash('Logged out successfully.', 'success')\n\n    return redirect(url_for('login'))\n\n\n\n@app.route('/upload', methods=['GET', 'POST'])\n\n@login_required\n\n@limiter.limit("10 per minute")  # Limiting uploads to 10 per minute\n\ndef upload():\n\n    form = UploadForm()\n\n    if form.validate_on_submit():\n\n        file = form.file.data\n\n        if file and allowed_file(file.filename):\n\n            filename = secure_filename(file.filename)\n\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n\n            flash('File successfully uploaded', 'success')\n\n        else:\n\n            flash('Invalid file extension', 'danger')\n\n    return render_template('upload.html', form=form)\n\n\n\n@app.route('/uploads/<filename>')\n\n@login_required\n\ndef uploaded_file(filename):\n\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\n\n\n@app.route('/delete/<filename>', methods=['POST'])\n\n@login_required\n\ndef delete_file(filename):\n\n    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n\n    if os.path.exists(filepath):\n\n        os.remove(filepath)\n\n        flash('File successfully deleted', 'success')\n\n    else:\n\n        flash('File not found', 'danger')\n\n    return redirect(url_for('upload'))\n\n\n\nif __name__ == '__main__':\n\n    app.run(debug=False, host='0.0.0.0', port=5000)
import os\n\nimport mysql.connector\n\nfrom mysql.connector import Error\n\nfrom PIL import Image\n\n\n\ndef validate_image(file_path):\n\n    """Validate if the file is a proper image."""\n\n    try:\n\n        with Image.open(file_path) as img:\n\n            img.verify()\n\n        return True\n\n    except Exception as e:\n\n        print(f"Image validation error: {e}")\n\n        return False\n\n\n\ndef connect_to_database():\n\n    """Create a connection to the MySQL database."""\n\n    try:\n\n        connection = mysql.connector.connect(\n\n            host='localhost',\n\n            database='image_db',\n\n            user='your_username',\n\n            password='your_password'\n\n        )\n\n        if connection.is_connected():\n\n            return connection\n\n    except Error as e:\n\n        print(f"Error while connecting to MySQL: {e}")\n\n    return None\n\n\n\ndef store_image(file_path):\n\n    """Store the image file in the MySQL database."""\n\n    if not validate_image(file_path):\n\n        print("Invalid image file.")\n\n        return\n\n    \n\n    connection = connect_to_database()\n\n    if connection is None:\n\n        print("Failed to connect to the database.")\n\n        return\n\n    \n\n    try:\n\n        with open(file_path, 'rb') as file:\n\n            image_data = file.read()\n\n        \n\n        cursor = connection.cursor()\n\n        query = "INSERT INTO images (image_name, image_data) VALUES (%s, %s)"\n\n        cursor.execute(query, (os.path.basename(file_path), image_data))\n\n        connection.commit()\n\n        print(f"Image {os.path.basename(file_path)} stored successfully.")\n\n    \n\n    except Error as e:\n\n        print(f"Error while storing the image: {e}")\n\n    finally:\n\n        if connection.is_connected():\n\n            cursor.close()\n\n            connection.close()\n\n\n\ndef main():\n\n    file_path = input("Enter the path to the image file: ").strip()\n\n    if not os.path.isfile(file_path):\n\n        print("The file does not exist.")\n\n        return\n\n    if not file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):\n\n        print("Unsupported file format.")\n\n        return\n\n\n\n    store_image(file_path)\n\n\n\nif __name__ == "__main__":\n\n    main()
import base64\n\nimport sqlite3\n\nimport hashlib\n\nimport os\n\nimport logging\n\nfrom werkzeug.utils import secure_filename\n\nfrom contextlib import closing\n\n\n\n# Configure logging\n\nlogging.basicConfig(filename='image_upload.log', level=logging.INFO,\n\n                    format='%(asctime)s:%(levelname)s:%(message)s')\n\n\n\n# Database configuration\n\nDATABASE = 'secure_image_upload.db'\n\n\n\n# Secure table creation\n\ndef create_table():\n\n    try:\n\n        with sqlite3.connect(DATABASE) as conn:\n\n            with closing(conn.cursor()) as cursor:\n\n                cursor.execute("""\n\n                CREATE TABLE IF NOT EXISTS images (\n\n                    id INTEGER PRIMARY KEY,\n\n                    image_name TEXT NOT NULL,\n\n                    image_data BLOB NOT NULL,\n\n                    salt TEXT NOT NULL\n\n                )\n\n                """)\n\n                conn.commit()\n\n                logging.info('Table created successfully.')\n\n    except sqlite3.Error as e:\n\n        logging.error(f'Error creating table: {e}')\n\n\n\n# Function to generate a secure salt\n\ndef generate_salt():\n\n    return os.urandom(16)\n\n\n\n# Function to securely hash image data\n\ndef hash_image_data(image_data, salt):\n\n    hasher = hashlib.sha256()\n\n    hasher.update(salt + image_data)\n\n    return hasher.digest()\n\n\n\n# Function to handle image upload\n\ndef upload_image(image_path):\n\n    try:\n\n        # Secure file handling: ensure a valid and secure filename\n\n        filename = secure_filename(os.path.basename(image_path))\n\n        \n\n        # Read and encode image to base64\n\n        with open(image_path, 'rb') as image_file:\n\n            image_data = image_file.read()\n\n            image_b64 = base64.b64encode(image_data).decode('utf-8')\n\n        \n\n        # Generate salt and hash the image data\n\n        salt = generate_salt()\n\n        hashed_data = hash_image_data(image_data, salt)\n\n\n\n        # Insert into the database using prepared statements\n\n        with sqlite3.connect(DATABASE) as conn:\n\n            with closing(conn.cursor()) as cursor:\n\n                cursor.execute("""\n\n                INSERT INTO images (image_name, image_data, salt) \n\n                VALUES (?, ?, ?)\n\n                """, (filename, hashed_data, salt))\n\n                conn.commit()\n\n                logging.info(f'Image {filename} uploaded and stored successfully.')\n\n    except (sqlite3.Error, IOError) as e:\n\n        logging.error(f'Error during image upload: {e}')\n\n        print(f'An error occurred: {e}')\n\n\n\n# Run table creation on script execution\n\nif __name__ == "__main__":\n\n    create_table()
from flask import Flask, request, redirect, url_for\n\nfrom werkzeug.utils import secure_filename\n\nimport os\n\nimport base64\n\nimport secrets\n\n\n\napp = Flask(__name__)\n\n\n\n# Configuration\n\nUPLOAD_FOLDER = 'uploads'\n\nENCODED_FOLDER = 'encoded'\n\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\n\n\n\n# Ensure directories exist\n\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\nos.makedirs(ENCODED_FOLDER, exist_ok=True)\n\n\n\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\napp.config['ENCODED_FOLDER'] = ENCODED_FOLDER\n\n\n\ndef allowed_file(filename):\n\n    """Check if the file has an allowed extension."""\n\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n\n\ndef generate_random_filename(extension):\n\n    """Generate a secure random filename."""\n\n    return secrets.token_hex(16) + '.' + extension\n\n\n\ndef upload_image(file):\n\n    """Handle image upload, encoding, and saving."""\n\n    if file and allowed_file(file.filename):\n\n        # Secure the filename\n\n        filename = secure_filename(file.filename)\n\n        # Extract file extension\n\n        file_extension = filename.rsplit('.', 1)[1].lower()\n\n        # Generate a random filename\n\n        random_filename = generate_random_filename(file_extension)\n\n        # Define the full path for the upload\n\n        upload_path = os.path.join(app.config['UPLOAD_FOLDER'], random_filename)\n\n        \n\n        # Save the file to the upload directory\n \n        file.save(upload_path)\n\n        \n\n        # Read the file and encode it in base64\n\n        with open(upload_path, 'rb') as image_file:\n\n            encoded_string = base64.b64encode(image_file.read()).decode('utf-8')\n\n        \n\n        # Write the base64 encoded image to a new file\n\n        encoded_filename = random_filename.rsplit('.', 1)[0] + '.txt'\n\n        encoded_path = os.path.join(app.config['ENCODED_FOLDER'], encoded_filename)\n\n        \n\n        with open(encoded_path, 'w') as encoded_file:\n\n            encoded_file.write(encoded_string)\n\n        \n\n        return encoded_path\n\n\n\n@app.route('/upload', methods=['GET', 'POST'])\n\ndef upload_file():\n\n    if request.method == 'POST':\n\n        # Check if the post request has the file part\n\n        if 'file' not in request.files:\n\n            return 'No file part'\n\n        file = request.files['file']\n\n        # If user does not select file, browser also submit an empty part without filename\n\n        if file.filename == '':\n\n            return 'No selected file'\n\n        # Process the upload\n\n        encoded_file_path = upload_image(file)\n\n        return f'File successfully uploaded and encoded. Encoded file: {encoded_file_path}'\n\n    \n\n    return '''\n\n    <!doctype html>\n\n    <title>Upload new File</title>\n\n    <h1>Upload new File</h1>\n\n    <form method=post enctype=multipart/form-data>\n\n      <input type=file name=file>\n\n      <input type=submit value=Upload>\n\n    </form>\n\n    '''\n\n\n\nif __name__ == '__main__':\n\n    app.run(  )
from flask import Flask, request, render_template, redirect, url_for, flash\n\nfrom werkzeug.utils import secure_filename\n\nimport os\n\n\n\napp = Flask(__name__)\n\n\n\n# Configuration settings\n\nUPLOAD_FOLDER = 'uploads'\n\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\n\nMAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16 MB max file size\n\nSECRET_KEY = 'your_secret_key'  # Replace with your actual secret key\n\n\n\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\napp.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH\n\napp.config['SECRET_KEY'] = SECRET_KEY\n\n\n\n# Ensure the upload directory exists\n\nif not os.path.exists(UPLOAD_FOLDER):\n\n    os.makedirs(UPLOAD_FOLDER)\n\n\n\n# Function to check allowed file extensions\n\ndef allowed_file(filename):\n\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n\n\n# Stub function to validate file type\n\ndef file_is_safe_type(file):\n\n    # Implement actual file type checking here\n\n    return True\n\n\n\n@app.route('/')\n\ndef index():\n\n    return render_template('index.html')\n\n\n\n@app.route('/upload', methods=['GET', 'POST'])\n\ndef upload_file():\n\n    if request.method == 'POST':\n\n        # Check if the post request has the file part\n\n        if 'file' not in request.files:\n \n            flash('No file part')\n\n            return redirect(request.url)\n\n\n\n        file = request.files['file']\n\n\n\n        # If user does not select a file, browser also\n\n        # submits an empty part without filename\n\n        if file.filename == '':\n\n            flash('No selected file')\n\n            return redirect(request.url)\n\n\n\n        if file and allowed_file(file.filename):\n\n            if file_is_safe_type(file):\n\n                filename = secure_filename(file.filename)\n\n                file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n\n                \n\n                try:\n\n                    file.save(file_path)\n\n                    flash('File successfully uploaded')\n\n                    return redirect(url_for('index'))\n\n                except Exception as e:\n\n                    flash(f'An error occurred while saving the file: {e}')\n\n                    return redirect(request.url)\n\n            else:\n\n                flash('File type is not allowed')\n\n                return redirect(request.url)\n\n        else:\n\n            flash('File extension is not allowed')\n\n            return redirect(request.url)\n\n    return render_template('upload.html')\n\n\n\n@app.errorhandler(413)\n\ndef request_entity_too_large(error):\n\n    flash('File is too large')\n\n    return redirect(request.url), 413\n\n\n\nif __name__ == '__main__':\n\n    app.run(  )
# app.py\n\nimport os\n\nimport re\n\nimport logging\n\nfrom flask import Flask, request, render_template, redirect, url_for, flash\n\nfrom werkzeug.utils import secure_filename\n\nfrom flask_limiter import Limiter\n\nfrom flask_limiter.util import get_remote_address\n\n\n\n# Configuration\n\nUPLOAD_FOLDER = 'uploads'\n\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\n\nMAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16 MB\n\n\n\n# Ensure the upload folder exists\n\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\nos.makedirs('logs', exist_ok=True)\n\n\n\n# Initialize the Flask app\n\napp = Flask(__name__)\n\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\napp.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH\n\napp.secret_key = 'your_secret_key'\n\n\n\n# Set up rate limiting\n\nlimiter = Limiter(\n\n    app,\n\n    key_func=get_remote_address,\n\n    default_limits=["5 per minute"]\n\n)\n\n\n\n# Configure logging\n\nlogging.basicConfig(filename='logs/app.log', level=logging.INFO,\n\n                    format='%(asctime)s %(levelname)s %(message)s')\n\n\n\ndef allowed_file(filename):\n\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n\n\n@app.route('/')\n\ndef index():\n\n    return render_template('index.html')\n\n\n\n@app.route('/upload', methods=['POST'])\n\n@limiter.limit("5 per minute")  # Apply rate limiting to this route\n\ndef upload_file():\n\n    if 'file' not in request.files:\n\n        flash('No file part')\n\n        return redirect(request.url)\n\n\n\n    file = request.files['file']\n\n    \n\n    if file.filename == '':\n\n        flash('No selected file')\n\n        return redirect(request.url)\n\n\n\n    if file and allowed_file(file.filename):\n\n        filename = secure_filename(file.filename)\n\n\n\n        # Sanitize filename to prevent directory traversal attacks\n\n        filename = re.sub(r'[^a-zA-Z0-9_.-]', '_', filename)\n\n\n\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n\n        file.save(file_path)\n\n\n\n        # Logging the upload\n\n        logging.info(f"File uploaded: {file_path}")\n\n\n\n        flash('File successfully uploaded')\n\n        return redirect(url_for('index'))\n\n    else:\n\n        flash('File type not allowed or file too large')\n\n        return redirect(request.url)\n\n\n\n# Error handling\n\n@app.errorhandler(413)\n\ndef request_entity_too_large(error):\n\n    flash('File is too large')\n\n    return redirect(request.url)\n\n\n\n@app.errorhandler(429)\n\ndef too_many_requests(error):\n\n    flash('Too many requests, please try again later')\n\n    return redirect(request.url)\n\n\n\nif __name__ == '__main__':\n\n    app.run( )\n
import os\n\nimport werkzeug.utils\n\nimport pyclamd\n\nfrom flask import Flask, request, flash\n\nfrom werkzeug.utils import secure_filename\n\n\n\n# Define allowed extensions and maximum file size (e.g., 2MB)\n\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\n\nMAX_FILE_SIZE = 2 * 1024 * 1024  # 2MB\n\n\n\n# Create an uploads directory if it doesn't exist\n\nUPLOAD_FOLDER = 'uploads'\n\nif not os.path.exists(UPLOAD_FOLDER):\n\n    os.makedirs(UPLOAD_FOLDER)\n\n\n\napp = Flask(__name__)\n\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\napp.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE\n\n\n\n# Function to check if the file has an allowed extension\n\ndef allowed_file(filename):\n\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n\n\n# Function to detect malicious content using ClamAV\n\ndef detect_malware(filepath):\n\n    try:\n\n        cd = pyclamd.ClamdAgnostic()\n\n        if cd.ping():\n\n            scan_result = cd.scan_file(filepath)\n\n            if scan_result:\n\n                return True  # Malware detected\n\n        return False\n\n    except pyclamd.ConnectionError:\n\n        print("Error: Unable to connect to ClamAV daemon.")\n\n        return False\n\n\n\n# Function to handle file uploads\n\n@app.route('/upload', methods=['POST'])\n\ndef upload_file():\n\n    if 'file' not in request.files:\n\n        flash('No file part')\n\n        return "No file part"\n\n\n\n    file = request.files['file']\n\n\n\n    # If no file is selected\n\n    if file.filename == '':\n\n        flash('No selected file')\n\n        return "No selected file"\n\n\n\n    # Check if file is allowed\n\n    if file and allowed_file(file.filename):\n\n        # Secure the filename\n\n        filename = secure_filename(file.filename)\n\n\n\n        # Save the file temporarily to scan for malware\n\n        temp_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n\n        file.save(temp_path)\n\n\n\n        # Check for malware\n\n        if detect_malware(temp_path):\n\n            os.remove(temp_path)\n\n            return "Malicious file detected!"\n\n\n\n        # Check the file size\n\n        file.seek(0, os.SEEK_END)\n\n        file_size = file.tell()\n\n        file.seek(0)  # Reset the file pointer\n\n\n\n        if file_size > MAX_FILE_SIZE:\n\n            os.remove(temp_path)\n\n            return "File size exceeds limit!"\n\n\n\n        # Move the file to the permanent location\n\n        final_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n\n        os.rename(temp_path, final_path)\n\n\n\n        return f"File {filename} uploaded successfully!"\n\n\n\n    return "File type not allowed!"\n\n\n\nif __name__ == '__main__':\n\n    app.run(  )
