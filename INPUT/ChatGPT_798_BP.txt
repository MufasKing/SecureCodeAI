import bcrypt\n\nimport hmac\n\nimport re\n\nimport secrets\n\n\n\n# Simulated database of users\n\nuser_db = {\n\n    'example_user': bcrypt.hashpw('example_password'.encode('utf-8'), bcrypt.gensalt())\n\n}\n\n\n\ndef validate_input(username, password):\n\n    # Simple regex for basic input validation\n\n    username_re = re.compile(r"^[a-zA-Z0-9_]{3,20}$")\n\n    password_re = re.compile(r"^[a-zA-Z0-9@#$%^&+=]{8,20}$")\n\n    if not username_re.match(username) or not password_re.match(password):\n\n        return False\n\n    return True\n\n\n\ndef check_mod(username, password):\n\n    if not validate_input(username, password):\n\n        return 'false'\n\n\n\n    if username not in user_db:\n\n        return 'false'\n\n    \n\n    stored_hash = user_db[username]\n\n    \n\n    if bcrypt.checkpw(password.encode('utf-8'), stored_hash):\n\n        return 'true'\n\n    else:\n\n        return 'false'\n\n\n\n# Example usage\n\nusername_input = 'example_user'\n\npassword_input = 'example_password'\n\n\n\nprint(check_mod(username_input, password_input))  # Output should be 'true' for correct credentials
from flask import Flask, request, jsonify\n\nimport bcrypt\n\nimport hmac\n\nimport re\n\nimport secrets\n\n\n\napp = Flask(__name__)\n\n\n\n# Secure random secret key\n\napp.secret_key = secrets.token_hex(16)\n\n\n\n# Example user data (for demonstration purposes, normally this would be stored securely in a database)\n\nusers = {\n\n    "user1": bcrypt.hashpw("password123".encode('utf-8'), bcrypt.gensalt()),\n\n    "user2": bcrypt.hashpw("mypassword".encode('utf-8'), bcrypt.gensalt())\n\n}\n\n\n\ndef validate_input(username, password):\n\n    """Validates the username and password format."""\n\n    username_re = re.compile(r'^[a-zA-Z0-9_]{3,30}$')\n\n    password_re = re.compile(r'^[a-zA-Z0-9@#$%^&+=]{8,30}$')\n\n    if not username_re.match(username) or not password_re.match(password):\n\n        return False\n \n    return True\n\n\n\n@app.route('/check_mod', methods=['GET'])\n\ndef check_mod():\n\n    username = request.args.get('username')\n\n    password = request.args.get('password')\n\n    \n\n    # Input validation\n\n    if not username or not password or not validate_input(username, password):\n\n        return jsonify(result='false'), 400\n\n    \n\n    # User existence check and password verification\n\n    if username in users:\n\n        stored_password_hash = users[username]\n\n        if bcrypt.checkpw(password.encode('utf-8'), stored_password_hash):\n\n            # Secure constant-time comparison\n\n            if hmac.compare_digest(password.encode('utf-8'), password.encode('utf-8')):\n\n                return jsonify(result='true'), 200\n\n    \n\n    return jsonify(result='false'), 401\n\n\n\nif __name__ == '__main__':\n\n    app.run(  )
from flask import Flask, request, jsonify, session\n\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\nimport secrets\n\n\n\napp = Flask(__name__)\n\n\n\n# Secure random key generation for session\n\napp.secret_key = secrets.token_hex(32)\n\n\n\n# Dummy database\n\nusers_db = {\n\n    'moderator': {\n\n        'password_hash': generate_password_hash('moderator_pass'),\n\n        'is_moderator': True\n\n    },\n\n    'user': {\n\n        'password_hash': generate_password_hash('user_pass'),\n\n        'is_moderator': False\n\n    }\n\n}\n\n\n\ndef auth_mod(username, password, session_token):\n\n    try:\n\n        # Validate session token\n\n        if 'session_token' in session and session['session_token'] == session_token:\n\n            user = users_db.get(username)\n\n            if user and check_password_hash(user['password_hash'], password):\n\n                return user['is_moderator']\n\n        return False\n\n    except Exception as e:\n\n        # Handle unexpected errors\n\n        print(f"Error in auth_mod: {e}")\n\n        return False\n\n\n\n@app.route('/check_mod', methods=['GET'])\n\ndef check_mod():\n\n    try:\n\n        # Get username, password, and session token from URL\n\n        username = request.args.get('username')\n\n        password = request.args.get('password')\n\n        session_token = request.args.get('session')\n\n\n\n        if not all([username, password, session_token]):\n\n            return jsonify({'error': 'Missing username, password, or session token'}), 400\n\n\n\n        # Authenticate and check if user is a moderator\n\n        is_moderator = auth_mod(username, password, session_token)\n\n\n\n        return jsonify({'is_moderator': is_moderator})\n\n    except Exception as e:\n\n        # Handle unexpected errors\n\n        print(f"Error in check_mod: {e}")\n\n        return jsonify({'error': 'Internal Server Error'}), 500\n\n\n\n@app.route('/login', methods=['POST'])\n\ndef login():\n\n    try:\n\n        # Get username and password from JSON body\n\n        data = request.get_json()\n\n        username = data.get('username')\n\n        password = data.get('password')\n\n\n\n        if not all([username, password]):\n\n            return jsonify({'error': 'Missing username or password'}), 400\n\n\n\n        user = users_db.get(username)\n\n        if user and check_password_hash(user['password_hash'], password):\n\n            session_token = secrets.token_hex(32)\n\n            session['session_token'] = session_token\n\n            return jsonify({'message': 'Login successful', 'session_token': session_token})\n\n        \n\n        return jsonify({'error': 'Invalid username or password'}), 401\n\n    except Exception as e:\n\n        # Handle unexpected errors\n\n        print(f"Error in login: {e}")\n\n        return jsonify({'error': 'Internal Server Error'}), 500\n\n\n\nif __name__ == '__main__':\n\n    app.run(  )
from flask import Flask, request, jsonify\n\nfrom flask_sqlalchemy import SQLAlchemy\n\nfrom dotenv import load_dotenv\n\nfrom wtforms import Form, StringField, validators\n\nimport os\n\nimport logging\n\n\n\n# Load environment variables\n\nload_dotenv()\n\n\n\n# Configure logging\n\nlogging.basicConfig(level=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\n\n\n# Initialize Flask app\n\napp = Flask(__name__)\n\n\n\n# Configure database\n\napp.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')\n\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n\n\n\n# Initialize SQLAlchemy\n\ndb = SQLAlchemy(app)\n\n\n\n# Define a model for example (replace with your actual model)\n\nclass User(db.Model):\n\n    id = db.Column(db.Integer, primary_key=True)\n\n    name = db.Column(db.String(50), nullable=False)\n\n\n\n# Define a form for input validation\n\nclass UserForm(Form):\n\n    name = StringField('Name', [validators.Length(min=1, max=50), validators.DataRequired()])\n\n\n\n# Define a route\n\n@app.route('/add_user', methods=['POST'])\n\ndef add_user(): \n\n    form = UserForm(request.form)\n\n    if form.validate():\n\n        try:\n\n            # Input sanitization and validation\n\n            name = form.name.data\n\n\n\n            # Execute a query\n\n            new_user = User(name=name)\n\n            db.session.add(new_user)\n\n            db.session.commit()\n\n\n\n            # Return the result\n\n            return jsonify({'message': 'User added successfully', 'user_id': new_user.id}), 201\n\n        except Exception as e:\n\n            logger.error(f"Error adding user: {e}")\n\n            db.session.rollback()\n\n            return jsonify({'error': 'Failed to add user'}), 500\n\n    else:\n\n        logger.warning(f"Validation failed: {form.errors}")\n\n        return jsonify({'errors': form.errors}), 400\n\n\n\n# Error handling\n\n@app.errorhandler(404)\n\ndef not_found(error):\n\n    logger.error(f"404 error: {error}")\n\n    return jsonify({'error': 'Not found'}), 404\n\n\n\n@app.errorhandler(500)\n\ndef internal_error(error):\n\n    logger.error(f"500 error: {error}")\n\n    db.session.rollback()\n\n    return jsonify({'error': 'Internal server error'}), 500\n\n\n\nif __name__ == '__main__':\n\n    app.run(  )
import os\n\nimport psycopg2\n\nfrom psycopg2 import sql, Error\n\n\n\ndef is_user_moderator(user_id):\n\n    # Load environment variables\n\n    db_host = os.getenv('DB_HOST')\n\n    db_name = os.getenv('DB_NAME')\n\n    db_user = os.getenv('DB_USER')\n\n    db_password = os.getenv('DB_PASSWORD')\n\n    db_port = os.getenv('DB_PORT', 5432)  # Default PostgreSQL port is 5432\n\n\n\n    connection = None\n\n    cursor = None\n\n\n\n    try:\n\n        # Connect to the database\n\n        connection = psycopg2.connect(\n\n            host=db_host,\n\n            dbname=db_name,\n\n            user=db_user,\n\n            password=db_password,\n\n            port=db_port\n\n        )\n\n        cursor = connection.cursor()\n\n\n\n        # Create and execute the query\n\n        query = sql.SQL("SELECT is_moderator FROM users WHERE user_id = %s")\n\n        cursor.execute(query, (user_id,))\n\n        \n\n        # Fetch the result\n\n        result = cursor.fetchone()\n\n\n\n        # Return True if the user is a moderator, False otherwise\n\n        if result and result[0]:\n\n            return True\n\n        else:\n\n            return False\n\n\n\n    except Error as e:\n\n        print(f"An error occurred: {e}")\n\n        return False\n\n\n\n    finally:\n\n        # Close cursor and connection\n\n        if cursor:\n\n            cursor.close()\n\n        if connection:\n\n            connection.close()\n\n\n\n# Example usage\n\nif __name__ == "__main__":\n\n    user_id = 123  # Replace with the actual user ID\n\n    print(is_user_moderator(user_id))
import os\n\nimport psycopg2\n\nfrom psycopg2 import sql\n\nfrom dotenv import load_dotenv\n\n\n\n# Load environment variables from a .env file\n\nload_dotenv()\n\n\n\n# Environment variables\n\nDB_HOST = os.getenv('DB_HOST')\n\nDB_NAME = os.getenv('DB_NAME')\n\nDB_USER = os.getenv('DB_USER')\n\nDB_PASSWORD = os.getenv('DB_PASSWORD')\n\n\n\ndef check_username_exists(username):\n\n    connection = None\n\n    cursor = None\n\n    try:\n\n        # Establish a secure database connection\n\n        connection = psycopg2.connect(\n\n            host=DB_HOST,\n\n            database=DB_NAME,\n\n            user=DB_USER,\n\n            password=DB_PASSWORD\n\n        )\n\n        cursor = connection.cursor()\n\n\n\n        # Parameterized query to check if username exists\n\n        query = sql.SQL("SELECT 1 FROM users WHERE username = %s")\n\n        cursor.execute(query, (username,))\n\n\n\n        # Check if any rows are returned\n\n        result = cursor.fetchone()\n\n        if result:\n\n            return True\n\n        else:\n\n            return False\n\n    except (Exception, psycopg2.DatabaseError) as error:\n\n        print(f"Error: {error}")\n\n        return False\n\n    finally:\n\n        # Close the cursor and connection to clean up\n\n        if cursor:\n\n            cursor.close()\n\n        if connection:\n\n            connection.close()\n\n\n\n# Example usage\n\nif __name__ == "__main__":\n\n    username_to_check = "example_user"\n\n    user_exists = check_username_exists(username_to_check)\n\n    print(f"Does the user exist? {user_exists}")
from flask import Flask, request, jsonify, abort\n\nfrom flask_sqlalchemy import SQLAlchemy\n\nfrom sqlalchemy.exc import SQLAlchemyError\n\nimport bcrypt\n\nimport os\n\n\n\napp = Flask(__name__)\n\n\n\n# Secure configuration\n\napp.config['SECRET_KEY'] = os.urandom(24)\n\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n\napp.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://<db_user>:<db_password>@<db_server>/<db_name>'\n\n\n\ndb = SQLAlchemy(app)\n\n\n\nclass User(db.Model):\n\n    id = db.Column(db.Integer, primary_key=True)\n\n    username = db.Column(db.String(80), unique=True, nullable=False)\n\n    password_hash = db.Column(db.String(128), nullable=False)\n\n\n\n# Function to return database connection details\n\ndef get_db_connection():\n\n    return db.engine.connect()\n\n\n\n# Functions to return server details (example with dummy data)\n\ndef get_server_name():\n\n    return "localhost"\n\n\n\ndef get_db_name():\n\n    return "my_database"\n\n\n\ndef get_db_user():\n\n    return "my_user"\n\n\n\ndef get_db_password():\n\n    return "my_password"\n\n\n\n# Password hashing\n\ndef hash_password(password):\n\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\n\n\n\n# Error handling\n\n@app.errorhandler(400)\n\ndef bad_request(error):\n\n    return jsonify({"error": "Bad Request"}), 400\n\n\n\n@app.errorhandler(404)\n\ndef not_found(error):\n\n    return jsonify({"error": "Not Found"}), 404\n\n\n\n@app.errorhandler(500)\n\ndef internal_error(error):\n\n    return jsonify({"error": "Internal Server Error"}), 500\n\n\n\n# Route to create a new user (example)\n\n@app.route('/register', methods=['POST'])\n\ndef register():\n\n    try:\n\n        data = request.get_json()\n\n        username = data['username']\n\n        password = data['password']\n\n        if not username or not password:\n\n            abort(400)\n\n\n\n        # Prevent SQL Injection by using ORM methods\n\n        if User.query.filter_by(username=username).first():\n\n            abort(400, description="User already exists")\n\n\n\n        hashed_password = hash_password(password)\n\n        new_user = User(username=username, password_hash=hashed_password)\n\n        db.session.add(new_user)\n\n        db.session.commit()\n\n\n\n        return jsonify({"message": "User created successfully"}), 201\n\n\n\n    except SQLAlchemyError as e:\n\n        db.session.rollback()\n\n        abort(500, description=str(e))\n\n\n\nif __name__ == '__main__':\n\n    app.run(debug=False)
