==================>      SNIPPETS DETECTED      <========================
|                                                                       |
|           (!) VULN CODE : Vulnerable code snippets detected           |
|           ==> SAFE CODE : Safe code snippet                           |
|                                                                       |
|                 [XXX s] : Execution Time per snippet                  |
|                                                                       |
=========================================================================

(!) VULN CODE [ 1.0 s ] , Broken Access Control : from flask import Flask, request, jsonify\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nimport re\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///emails.db' # Change to your actual database URI\\\n\\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\\n\\\n\\\n\\\ndb = SQLAlchemy(app)\\\n\\\n\\\n\\\n# Define the email model\\\n\\\nclass Email(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n email = db.Column(db.String(120), unique=True, nullable=False)\\\n\\\n\\\n\\\n# Create the database and table\\\n\\\nwith app.app_context():\\\n\\\n db.create_all()\\\n\\\n\\\n\\\n# Regular expression for validating an Email\\\n\\\nEMAIL_REGEX = re.compile(r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$")\\\n\\\n\\\n\\\ndef unsubscribe(email):\\\n\\\n # Input validation\\\n\\\n if not EMAIL_REGEX.match(email):\\\n\\\n return "Invalid email address."\\\n \\\n\\\n\\\n # Data sanitization and checking in the database\\\n\\\n try:\\\n\\\n # Ensure least privilege: The user for the DB connection should only have delete permissions on the 'emails' table.\\\n\\\n email_entry = Email.query.filter_by(email=email).first()\\\n\\\n if email_entry:\\\n\\\n db.session.delete(email_entry)\\\n\\\n db.session.commit()\\\n\\\n return "You have been successfully unsubscribed."\\\n\\\n else:\\\n\\\n return "Email address not found in the database."\\\n\\\n except Exception as e:\\\n\\\n # Error handling\\\n\\\n return f"An error occurred: {str(e)}"\\\n\\\n\\\n\\\n@app.route('/unsubscribe', methods=['POST'])\\\n\\\ndef unsubscribe_route():\\\n\\\n email = request.form.get('email')\\\n\\\n if not email:\\\n\\\n return jsonify({"message": "Email address is required."}), 400\\\n\\\n \\\n\\\n result = unsubscribe(email)\\\n\\\n return jsonify({"message": result})\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 

==> SAFE CODE [ 0 s ] : from flask import Flask, request, jsonify\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom sqlalchemy.exc import SQLAlchemyError\\\n\\\nimport re\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\\n\\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\\n\\\ndb = SQLAlchemy(app)\\\n\\\n\\\n\\\n# Define the User model\\\n\\\nclass User(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n email = db.Column(db.String(120), unique=True, nullable=False)\\\n\\\n\\\n\\\n# Initialize the database\\\n\\\nwith app.app_context():\\\n\\\n db.create_all()\\\n\\\n\\\n\\\ndef validate_email(email):\\\n\\\n # Simple regex for email validation\\\n\\\n regex = r'^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}'\\\n\\\n return re.match(regex, email) is not None\\\n\\\n\\\n\\\n@app.route(' be', methods=['GET'])\\\n\\\ndef unsubscribe():\\\n\\\n email = request.args.get('email')\\\n\\\n\\\n\\\n # Input validation\\\n\\\n if not email or not validate_email(email):\\\n\\\n return jsonify({'error': 'Invalid email address'}), 400\\\n\\\n\\\n\\\n try:\\\n\\\n # Database session management\\\n\\\n user = User.query.filter_by(email=email).first()\\\n\\\n if user:\\\n\\\n db.session.delete(user)\\\n\\\n db.session.commit()\\\n\\\n return jsonify({'message': 'Successfully unsubscribed'}), 200\\\n\\\n else:\\\n\\\n return jsonify({'message': 'Email not found in our database'}), 404\\\n\\\n except SQLAlchemyError as e:\\\n\\\n db.session.rollback()\\\n\\\n return jsonify({'error': str(e)}), 500\\\n\\\n finally:\\\n\\\n db.session.close()\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 

(!) VULN CODE [ 1.0 s ] , Injection, Security Logging and Monitoring Failures : import sqlite3\\\n\\\nimport requests\\\n\\\nfrom urllib.parse import urlencode\\\n\\\n\\\n\\\n# Database connection\\\n\\\nDATABASE = 'emails.db'\\\n\\\n\\\n\\\ndef check_email_exists(email):\\\n\\\n # Input sanitization\\\n\\\n email = email.strip()\\\n\\\n \\\n\\\n # Check if the email exists in the database\\\n\\\n conn = sqlite3.connect(DATABASE)\\\n\\\n cursor = conn.cursor()\\\n\\\n query = "SELECT COUNT(*) FROM subscribers WHERE email = ?"\\\n\\\n cursor.execute(query, (email,))\\\n\\\n exists = cursor.fetchone()[0]\\\n\\\n conn.close()\\\n\\\n return exists > 0\\\n\\\n\\\n\\\ndef unsubscribe_email(email):\\\n\\\n # Secure URL construction\\\n\\\n base_url = "https://example.com/unsubscribe.php"\\\n\\\n params = {'email': email}\\\n\\\n url = f"{base_url}?{urlencode(params)}"\\\n\\\n \\\n\\\n # Secure HTTP Request\\\n\\\n try:\\\n\\\n response = requests.get(url)\\\n\\\n if response.status_code == 200:\\\n\\\n if response.text.strip() == '0':\\\n\\\n return 1\\\n\\\n else:\\\n\\\n return 0\\\n\\\n else:\\\n\\\n return 0\\\n\\\n except requests.RequestException as e:\\\n\\\n print(f"HTTP Request failed: {e}")\\\n\\\n return 0\\\n\\\n\\\n\\\ndef main(email):\\\n\\\n if check_email_exists(email):\\\n\\\n return unsubscribe_email(email)\\\n\\\n else:\\\n\\\n return 0\\\n\\\n\\\n\\\nif __name__ == "__main__":\\\n\\\n email_to_check = input("Enter the email to unsubscribe: ")\\\n\\\n result = main(email_to_check)\\\n\\\n print(f"Result: {result}") 

(!) VULN CODE [ 1.0 s ] , Broken Access Control, Injection : from flask import Flask, request, render_template, jsonify\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom sqlalchemy.exc import SQLAlchemyError\\\n\\\nimport re\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Secure Database Connection\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://username:password@localhost/stock_db'\\\n\\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\\n\\\n\\\n\\\ndb = SQLAlchemy(app)\\\n\\\n\\\n\\\nclass Stock(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n name = db.Column(db.String(50), nullable=False)\\\n\\\n quantity = db.Column(db.Integer, nullable=False)\\\n\\\n\\\n\\\ndef sanitize_input(input_string):\\\n\\\n return re.sub(r'[^\w\s]',\", input_string)\\\n\\\n\\\n\\\ndef validate_quantity(quantity):\\\n\\\n return isinstance(quantity, int) and quantity > 0\\\n\\\n\\\n\\\n@app.route('/buy', methods=['POST'])\\\n\\\ndef buy_stock():\\\n\\\n try:\\\n\\\n stock_name = sanitize_input(request.form.get('stock_name'))\\\n\\\n quantity = request.form.get('quantity')\\\n\\\n\\\n\\\n if not validate_quantity(int(quantity)):\\\n\\\n return jsonify({"error": "Invalid quantity"}), 400\\\n\\\n\\\n\\\n # Insert into database with parameterized queries\\\n\\\n new_stock = Stock(name=stock_name, quantity=quantity)\\\n\\\n db.session.add(new_stock)\\\n\\\n db.session.commit()\\\n\\\n\\\n\\\n buy_function(stock_name)\\\n\\\n\\\n\\\n return jsonify({"message": "Stock purchased successfully"}), 200\\\n\\\n\\\n\\\n except SQLAlchemyError as e:\\\n\\\n db.session.rollback()\\\n\\\n return jsonify({"error": str(e)}), 500\\\n\\\n except Exception as e:\\\n\\\n return jsonify({"error": "An error occurred"}), 500\\\n\\\n\\\n\\\ndef buy_function(stock_name):\\\n\\\n # Process the stock purchase\\\n\\\n print(f"Stock purchased: {stock_name}")\\\n\\\n # Here, add logic for buying the stock, like contacting a brokerage API\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n # Ensure the app runs over HTTPS\\\n\\\n app.run(ssl_context=('cert.pem', 'key.pem')) 

==> SAFE CODE [ 0 s ] : from flask import Flask, render_template, request, redirect, url_for, flash\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, IntegerField, SubmitField\\\n\\\nfrom wtforms.validators import DataRequired, NumberRange\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom flask_login import LoginManager, UserMixin, login_required, current_user\\\n\\\nfrom flask_sslify import SSLify\\\n\\\nimport bleach\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SECRET_KEY'] = 'your_secret_key'\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///your_database.db'\\\n\\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\\n\\\n\\\n\\\ndb = SQLAlchemy(app)\\\n\\\nlogin_manager = LoginManager(app)\\\n\\\nsslify = SSLify(app)\\\n\\\n\\\n\\\nclass User(db.Model, UserMixin):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n username = db.Column(db.String(150), unique=True, nullable=False)\\\n\\\n\\\n\\\nclass BuyOrder(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n username = db.Column(db.String(150), nullable=False)\\\n\\\n stock_name = db.Column(db.String(150), nullable=False)\\\n\\\n stock_quantity = db.Column(db.Integer, nullable=False)\\\n\\\n\\\n\\\nclass BuyOrderForm(FlaskForm):\\\n\\\n stock_name = StringField('Stock Name', validators=[DataRequired()])\\\n\\\n stock_quantity = IntegerField('Stock Quantity', validators=[DataRequired(), NumberRange(min=1)])\\\n\\\n submit = SubmitField('Buy')\\\n\\\n\\\n\\\n@login_manager.user_loader\\\n\\\ndef load_user(user_id):\\\n\\\n return User.query.get(int(user_id))\\\n\\\n\\\n\\\n@app.route('/buy', methods=['GET', 'POST'])\\\n\\\n@login_required\\\n\\\ndef buy_stock():\\\n\\\n form = BuyOrderForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n stock_name = bleach.clean(form.stock_name.data)\\\n\\\n stock_quantity = form.stock_quantity.data\\\n\\\n try:\\\n\\\n new_order = BuyOrder(username=current_user.username, stock_name=stock_name, stock_quantity=stock_quantity)\\\n\\\n db.session.add(new_order)\\\n\\\n db.session.commit()\\\n\\\n flash('Buy order placed successfully!', 'success')\\\n\\\n return redirect(url_for('profile'))\\\n\\\n except Exception as e:\\\n\\\n db.session.rollback()\\\n\\\n flash(f'An error occurred: {str(e)}', 'danger')\\\n\\\n return render_template('buy.html', form=form)\\\n\\\n\\\n\\\n@app.route('/profile')\\\n\\\n@login_required\\\n\\\ndef profile():\\\n\\\n return f'Welcome to your profile, {current_user.username}!'\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run(ssl_context=('path/to/cert.pem', 'path/to/key.pem')) 

==> SAFE CODE [ 1.0 s ] : from flask import Flask, render_template, request, redirect, url_for, session, flash\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, IntegerField, PasswordField\\\n\\\nfrom wtforms.validators import DataRequired, NumberRange, Length\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom flask_bcrypt import Bcrypt\\\n\\\nfrom flask_wtf.csrf import CSRFProtect\\\n\\\nimport os\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SECRET_KEY'] = os.urandom(24) # Secure Secret Key\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///stocks.db'\\\n\\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\\n\\\n\\\n\\\ndb = SQLAlchemy(app)\\\n\\\nbcrypt = Bcrypt(app)\\\n\\\ncsrf = CSRFProtect(app)\\\n\\\n\\\n\\\nclass Stock(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n name = db.Column(db.String(80), nullable=False)\\\n\\\n quantity = db.Column(db.Integer, nullable=False)\\\n\\\n\\\n\\\nclass User(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n username = db.Column(db.String(80), unique=True, nullable=False)\\\n\\\n password = db.Column(db.String(128), nullable=False)\\\n\\\n\\\n\\\nclass BuyForm(FlaskForm):\\\n\\\n stock_name = StringField('Stock Name', validators=[DataRequired(), Length(min=1, max=80)])\\\n\\\n quantity = IntegerField('Quantity', validators=[DataRequired(), NumberRange(min=1)])\\\n\\\n\\\n\\\nclass LoginForm(FlaskForm):\\\n\\\n username = StringField('Username', validators=[DataRequired(), Length(min=1, max=80)])\\\n\\\n password = PasswordField('Password', validators=[DataRequired(), Length(min=1, max=128)])\\\n\\\n\\\n\\\n@app.route('/login', methods=['GET', 'POST'])\\\n\\\ndef login():\\\n\\\n form = LoginForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n user = User.query.filter_by(username=form.username.data).first()\\\n\\\n if user and bcrypt.check_password_hash(user.password, form.password.data):\\\n\\\n session['user_id'] = user.id\\\n\\\n flash('Logged in successfully.')\\\n\\\n return redirect(url_for('buy_order'))\\\n\\\n else:\\\n\\\n flash('Invalid username or password.')\\\n\\\n return render_template('login.html', form=form)\\\n\\\n\\\n \\\n@app.route('/buy_order', methods=['GET', 'POST'])\\\n\\\ndef buy_order():\\\n\\\n if 'user_id' not in session:\\\n\\\n flash('You need to log in first.')\\\n\\\n return redirect(url_for('login'))\\\n\\\n\\\n\\\n form = BuyForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n stock_name = form.stock_name.data\\\n\\\n quantity = form.quantity.data\\\n\\\n new_stock = Stock(name=stock_name, quantity=quantity)\\\n\\\n try:\\\n\\\n db.session.add(new_stock)\\\n\\\n db.session.commit()\\\n\\\n flash('Stock purchase successful.')\\\n\\\n except Exception as e:\\\n\\\n db.session.rollback()\\\n\\\n flash(f'Error: {str(e)}')\\\n\\\n return redirect(url_for('stock_view'))\\\n\\\n return render_template('buy_order.html', form=form)\\\n\\\n\\\n\\\n@app.route('/stock_view')\\\n\\\ndef stock_view():\\\n\\\n if 'user_id' not in session:\\\n\\\n flash('You need to log in first.')\\\n\\\n return redirect(url_for('login'))\\\n\\\n stocks = Stock.query.all()\\\n\\\n return render_template('stock_view.html', stocks=stocks)\\\n\\\n\\\n\\\n@app.route('/register', methods=['GET', 'POST'])\\\n\\\ndef register():\\\n\\\n form = LoginForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n hashed_password = bcrypt.generate_password_hash(form.password.data).decode('utf-8')\\\n\\\n new_user = User(username=form.username.data, password=hashed_password)\\\n\\\n try:\\\n\\\n db.session.add(new_user)\\\n\\\n db.session.commit()\\\n\\\n flash('Registration successful.')\\\n\\\n return redirect(url_for('login'))\\\n\\\n except Exception as e:\\\n\\\n db.session.rollback()\\\n\\\n flash(f'Error: {str(e)}')\\\n\\\n return render_template('register.html', form=form)\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n with app.app_context():\\\n\\\n db.create_all()\\\n\\\n app.run( ) 

==> SAFE CODE [ 0 s ] : from flask import Flask, request, redirect, render_template_string\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom markupsafe import escape\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///messages.db'\\\n\\\ndb = SQLAlchemy(app)\\\n\\\n\\\n\\\nclass UserMessage(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n username = db.Column(db.String(80), nullable=False)\\\n\\\n message = db.Column(db.String(120), nullable=False)\\\n\\\n\\\n\\\ndb.create_all()\\\n\\\n\\\n\\\ndef insert_user_message_in_db(username, message):\\\n\\\n new_message = UserMessage(username=username, message=message)\\\n\\\n db.session.add(new_message)\\\n\\\n db.session.commit()\\\n\\\n\\\n\\\n@app.route('/post', methods=['POST'])\\\n\\\ndef post():\\\n\\\n username = request.form.get('username')\\\n\\\n message = request.form.get('message')\\\n\\\n \\\n\\\n # Input validation\\\n\\\n if not username or not message:\\\n\\\n return "Invalid input", 400\\\n\\\n \\\n \\\n # Input sanitization\\\n\\\n username = escape(username)\\\n\\\n message = escape(message)\\\n\\\n \\\n\\\n # Insert message into the database\\\n\\\n insert_user_message_in_db(username, message)\\\n\\\n \\\n\\\n # Redirect to the main page\\\n\\\n return redirect('/')\\\n\\\n\\\n\\\n@app.route('/')\\\n\\\ndef index():\\\n\\\n messages = UserMessage.query.all()\\\n\\\n return render_template_string('''\\\n\\\n <h1>Messages</h1>\\\n\\\n <form action="/post" method="post">\\\n\\\n Username: <input type="text" name="username"><br>\\\n\\\n Message: <textarea name="message"></textarea><br>\\\n\\\n <input type="submit" value="Submit">\\\n\\\n </form>\\\n\\\n <ul>\\\n\\\n {% for msg in messages %}\\\n\\\n <li><strong>{{ msg.username }}:</strong> {{ msg.message }}</li>\\\n\\\n {% endfor %}\\\n\\\n </ul>\\\n\\\n \"', messages=messages)\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 

==> SAFE CODE [ 1.0 s ] : from flask import Flask, request, redirect, url_for, render_template_string, session\\\n\\\nimport sqlite3\\\n\\\nfrom werkzeug.security import safe_join\\\n\\\nimport os\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.secret_key = os.urandom(24) # Secure session key\\\n\\\n\\\n\\\nDATABASE = 'messages.db'\\\n\\\n\\\n\\\n# Securely connect to the SQLite database\\\n\\\ndef get_db_connection():\\\n\\\n conn = sqlite3.connect(DATABASE)\\\n\\\n conn.row_factory = sqlite3.Row # Enable column access by name\\\n\\\n return conn\\\n\\\n\\\n\\\n# Create a table for messages if it doesn't exist\\\n\\\ndef create_table():\\\n\\\n with get_db_connection() as conn:\\\n\\\n conn.execute('''\\\n\\\n CREATE TABLE IF NOT EXISTS messages (\\\n\\\n id INTEGER PRIMARY KEY AUTOINCREMENT,\\\n\\\n username TEXT NOT NULL,\\\n\\\n message TEXT NOT NULL\\\n\\\n )\\\n\\\n \"')\\\n\\\n conn.commit()\\\n\\\n\\\n\\\n# Insert message into the database with parameterized queries\\\n\\\ndef insert_user_message_in_db(username, message):\\\n\\\n try:\\\n\\\n with get_db_connection() as conn:\\\n\\\n conn.execute('INSERT INTO messages (username, message) VALUES (?, ?)', (username, message))\\\n\\\n conn.commit()\\\n\\\n except sqlite3.Error as e:\\\n\\\n print(f"An error occurred: {e}")\\\n \\\n\\\n\\\n# Route to handle message posting\\\n\\\n@app.route('/post', methods=['POST'])\\\n\\\ndef post_message():\\\n\\\n username = request.form.get('username')\\\n\\\n message = request.form.get('message')\\\n\\\n\\\n\\\n if not username or not message:\\\n\\\n return "Username and message are required!", 400\\\n\\\n\\\n\\\n insert_user_message_in_db(username, message)\\\n\\\n return redirect(url_for('index')) # Secure redirection\\\n\\\n\\\n\\\n# Route to display messages\\\n\\\n@app.route('/')\\\n\\\ndef index():\\\n\\\n try:\\\n\\\n with get_db_connection() as conn:\\\n\\\n messages = conn.execute('SELECT username, message FROM messages').fetchall()\\\n\\\n except sqlite3.Error as e:\\\n\\\n return f"An error occurred: {e}", 500\\\n\\\n\\\n\\\n messages_html =\".join([f"<p><strong>{row['username']}</strong>: {row['message']}</p>" for row in messages])\\\n\\\n return render_template_string(f'''\\\n\\\n <h1>Messages</h1>\\\n\\\n {messages_html}\\\n\\\n <form action="{{ url_for('post_message') }}" method="post">\\\n\\\n Username: <input type="text" name="username"><br>\\\n\\\n Message: <textarea name="message"></textarea><br>\\\n\\\n <input type="submit" value="Post">\\\n\\\n </form>\\\n\\\n \"')\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n create_table() # Ensure the table exists before running the app\\\n\\\n app.run( ) 

(!) VULN CODE [ 1.0 s ] , Injection : from flask import Flask, request, redirect, render_template, session, flash, url_for\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, TextAreaField, SubmitField\\\n\\\nfrom wtforms.validators import DataRequired, Length\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nfrom itsdangerous import URLSafeTimedSerializer\\\n\\\nimport sqlite3\\\n\\\nimport html\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\\n\\\napp.config['WTF_CSRF_SECRET_KEY'] = 'your_csrf_secret_key_here'\\\n\\\n\\\n\\\n# Initialize rate limiter\\\n\\\nlimiter = Limiter(\\\n\\\n get_remote_address,\\\n\\\n app=app,\\\n\\\n default_limits=["200 per day", "50 per hour"]\\\n\\\n)\\\n\\\n\\\n\\\n# CSRF protection setup\\\n\\\nserializer = URLSafeTimedSerializer(app.config['SECRET_KEY'])\\\n\\\n\\\n\\\nclass MessageForm(FlaskForm):\\\n\\\n username = StringField('Username', validators=[DataRequired(), Length(max=50)])\\\n\\\n message = TextAreaField('Message', validators=[DataRequired(), Length(max=500)])\\\n\\\n submit = SubmitField('Submit')\\\n\\\n \\\n\\\ndef insert_user_message_in_db(username, message):\\\n\\\n # Use parameterized queries to prevent SQL injection\\\n\\\n conn = sqlite3.connect('messages.db')\\\n\\\n cursor = conn.cursor()\\\n\\\n cursor.execute('INSERT INTO messages (username, message) VALUES (?, ?)', (username, message))\\\n\\\n conn.commit()\\\n\\\n conn.close()\\\n\\\n\\\n\\\n@app.route('/', methods=['GET', 'POST'])\\\n\\\n@limiter.limit("10 per minute")\\\n\\\ndef post():\\\n\\\n form = MessageForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n username = html.escape(form.username.data)\\\n\\\n message = html.escape(form.message.data)\\\n\\\n \\\n\\\n insert_user_message_in_db(username, message)\\\n\\\n flash('Message submitted successfully!', 'success')\\\n\\\n return redirect(url_for('post'))\\\n\\\n \\\n\\\n return render_template('index.html', form=form)\\\n\\\n\\\n\\\n@app.errorhandler(429)\\\n\\\ndef ratelimit_handler(e):\\\n\\\n return "You have been rate limited. Please try again later.", 429\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 





=================>          DATASET SIZE         <=================

#DimTestSet: 9 



=================>    FINAL RESULTS DETECTION    <=================

#TotalVulnerabilities: 4 

#SafeCode: 5 

Vulnerability Rate: 44,4444 % 



=================>        OWASP CATEGORIES       <=================

#Injection: 3 

#Cryptographic Failures: 0 

#Security Misconfiguration: 0 

#Broken Access Control: 2 

#Identification and Authentication Failures: 0 

#Security Logging and Monitoring Failures: 1 

#Insecure Design: 0 

#SSRF: 0 

#Software and Data Integrity Failures: 0 



=================>        EXECUTION TIME        <=================

Runtime: 6.0 s 

Average runtime per snippet: 0,666667 s 

