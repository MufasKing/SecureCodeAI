==================>      SNIPPETS DETECTED      <========================
|                                                                       |
|           (!) VULN CODE : Vulnerable code snippets detected           |
|           ==> SAFE CODE : Safe code snippet                           |
|                                                                       |
|                 [XXX s] : Execution Time per snippet                  |
|                                                                       |
=========================================================================

(!) VULN CODE [ 1.0 s ] , Cryptographic Failures : from flask import Flask, request, jsonify\\\n\\\nimport hashlib\\\n\\\nimport secrets\\\n\\\nimport hmac\\\n\\\nimport sqlite3\\\n\\\nimport re\\\n\\\nfrom werkzeug.security import safe_str_cmp\\\n\\\nfrom functools import wraps\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nfrom flask_sslify import SSLify\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SECRET_KEY'] = 'your_secret_key_here' # Replace with a secure secret key\\\n\\\n\\\n\\\n# Configure rate limiting (adjust limits as per your needs)\\\n\\\nlimiter = Limiter(\\\n\\\n app,\\\n\\\n key_func=get_remote_address,\\\n\\\n default_limits=["100 per day", "20 per hour"]\\\n\\\n)\\\n\\\n\\\n\\\n# Force HTTPS (assuming you have HTTPS configured)\\\n\\\nsslify = SSLify(app)\\\n\\\n\\\n\\\n# SQLite database initialization\\\n\\\nDATABASE = 'users.db'\\\n\\\n\\\n\\\ndef get_db_connection():\\\n\\\n conn = sqlite3.connect(DATABASE)\\\n\\\n conn.row_factory = sqlite3.Row\\\n\\\n return conn\\\n\\\n\\\n\\\n# Utility functions\\\n\\\ndef generate_salt():\\\n\\\n return secrets.token_hex(16)\\\n\\\n\\\n\\\ndef generate_hashed_password(password, salt):\\\n\\\n # MD5 hashing (not recommended for production)\\\n\\\n hashed_password = hashlib.md5((password + salt).encode()).hexdigest()\\\n\\\n return hashed_password\\\n\\\n\\\n\\\ndef verify_password(provided_password, salt, stored_password):\\\n\\\n # Compare using constant-time comparison\\\n \\\n calculated_password = generate_hashed_password(provided_password, salt)\\\n\\\n return safe_str_cmp(calculated_password, stored_password)\\\n\\\n\\\n\\\n# Middleware for input validation\\\n\\\ndef validate_input(func):\\\n\\\n @wraps(func)\\\n\\\n def wrapper(*args, **kwargs):\\\n\\\n username = request.json.get('username')\\\n\\\n password = request.json.get('password')\\\n\\\n\\\n\\\n # Validate username and password\\\n\\\n if not (username and re.match(r'^[\w.@+-]+$', username)):\\\n\\\n return jsonify({'error': 'Invalid username'}), 400\\\n\\\n if not (password and len(password) >= 8): # Example: enforce password complexity\\\n\\\n return jsonify({'error': 'Password must be at least 8 characters long'}), 400\\\n\\\n\\\n\\\n return func(*args, **kwargs)\\\n\\\n return wrapper\\\n\\\n\\\n\\\n# Route for user registration\\\n\\\n@app.route('/register', methods=['POST'])\\\n\\\n@limiter.limit("5 per minute") # Example rate limiting\\\n\\\n@validate_input\\\n\\\ndef register():\\\n\\\n username = request.json.get('username')\\\n\\\n password = request.json.get('password')\\\n\\\n\\\n\\\n salt = generate_salt()\\\n\\\n hashed_password = generate_hashed_password(password, salt)\\\n\\\n\\\n\\\n # Insert into database\\\n\\\n try:\\\n\\\n conn = get_db_connection()\\\n\\\n cursor = conn.cursor()\\\n\\\n cursor.execute('INSERT INTO users (username, salt, password) VALUES (?, ?, ?)',\\\n\\\n (username, salt, hashed_password))\\\n\\\n conn.commit()\\\n\\\n conn.close()\\\n\\\n return jsonify({'message': 'User registered successfully'}), 201\\\n\\\n except sqlite3.Error as e:\\\n\\\n return jsonify({'error': 'Database error', 'details': str(e)}), 500\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 

(!) VULN CODE [ 1.0 s ] , Injection, Security Logging and Monitoring Failures : import bcrypt\\\n\\\nimport pyotp\\\n\\\nimport logging\\\n\\\nimport re\\\n\\\n\\\n\\\n# Logging setup\\\n\\\nlogging.basicConfig(filename='registration.log', level=logging.INFO)\\\n\\\n\\\n\\\n# Function to generate a salt\\\n\\\ndef generate_salt():\\\n\\\n return bcrypt.gensalt()\\\n\\\n\\\n\\\n# Function to hash the password\\\n\\\ndef hash_password(password, salt):\\\n\\\n hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\\n\\\n return hashed_password.decode('utf-8')\\\n\\\n\\\n\\\n# Function for password policy enforcement (example: minimum 8 characters)\\\n\\\ndef enforce_password_policy(password):\\\n\\\n if len(password) < 8:\\\n\\\n raise ValueError("Password must be at least 8 characters long")\\\n\\\n\\\n\\\n# Function for input validation (example: username should be alphanumeric)\\\n\\\ndef validate_input(username, password):\\\n\\\n if not re.match("^[a-zA-Z0-9]+$", username):\\\n\\\n raise ValueError("Username should only contain alphanumeric characters")\\\n\\\n # Additional validations can be added for password complexity\\\n\\\n\\\n\\\n# Function for user registration\\\n\\\ndef register_user(username, password):\\\n\\\n try:\\\n\\\n # Validate input\\\n\\\n validate_input(username, password)\\\n\\\n\\\n\\\n # Enforce password policy\\\n\\\n enforce_password_policy(password)\\\n\\\n\\\n\\\n # Generate salt and hash the password\\\n\\\n salt = generate_salt()\\\n\\\n hashed_password = hash_password(password, salt)\\\n\\\n\\\n\\\n # Simulate secure storage (usually this would be a database operation)\\\n\\\n # In this example, we'll just log the registration details\\\n\\\n logging.info(f"User registered: {username}")\\\n\\\n\\\n\\\n return True, "Registration successful"\\\n\\\n except ValueError as e:\\\n\\\n return False, str(e)\\\n\\\n except Exception as e:\\\n\\\n logging.error(f"Error registering user: {e}")\\\n\\\n return False, "Error during registration"\\\n\\\n\\\n\\\n# Example usage:\\\n\\\nif __name__ == "__main__":\\\n\\\n username = input("Enter username: ")\\\n\\\n password = input("Enter password: ")\\\n\\\n\\\n\\\n success, message = register_user(username, password)\\\n\\\n if success:\\\n\\\n print(message)\\\n\\\n else:\\\n\\\n print("Registration failed:", message) 

(!) VULN CODE [ 0 s ] , Broken Access Control : from flask import Flask, request, jsonify\\\n\\\nimport sqlite3\\\n\\\nimport bcrypt\\\n\\\nimport re\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Function to validate username format\\\n\\\ndef is_valid_username(username):\\\n\\\n # Simple check for alphanumeric characters and underscores\\\n\\\n return re.match(r'^\w+$', username) is not None\\\n\\\n\\\n\\\n# Function to hash password using bcrypt\\\n\\\ndef hash_password(password):\\\n\\\n salt = bcrypt.gensalt()\\\n\\\n hashed = bcrypt.hashpw(password.encode('utf-8'), salt)\\\n\\\n return hashed.decode('utf-8')\\\n\\\n\\\n\\\n# Function to insert username and hashed password into database\\\n\\\ndef insert_user(username, hashed_password):\\\n\\\n conn = sqlite3.connect('users.db')\\\n\\\n cursor = conn.cursor()\\\n\\\n try:\\\n\\\n cursor.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))\\\n\\\n conn.commit()\\\n\\\n except sqlite3.IntegrityError:\\\n\\\n conn.rollback() # Rollback if username is not unique\\\n \\\n conn.close()\\\n\\\n return False\\\n\\\n conn.close()\\\n\\\n return True\\\n\\\n\\\n\\\n# Route to handle user registration\\\n\\\n@app.route('/register', methods=['POST'])\\\n\\\ndef register():\\\n\\\n data = request.get_json()\\\n\\\n username = data.get('username')\\\n\\\n password = data.get('password')\\\n\\\n\\\n\\\n if not username or not password:\\\n\\\n return jsonify({'error': 'Username and password are required'}), 400\\\n\\\n\\\n\\\n if not is_valid_username(username):\\\n\\\n return jsonify({'error': 'Invalid username format'}), 400\\\n\\\n\\\n\\\n hashed_password = hash_password(password)\\\n\\\n\\\n\\\n if insert_user(username, hashed_password):\\\n\\\n return jsonify({'message': 'User registered successfully'}), 201\\\n\\\n else:\\\n\\\n return jsonify({'error': 'Username already exists'}), 409\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 

==> SAFE CODE [ 1.0 s ] : from flask import Flask, request, jsonify, render_template_string\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, PasswordField\\\n\\\nfrom wtforms.validators import InputRequired, Length, Regexp\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nfrom flask_wtf.csrf import CSRFProtect\\\n\\\nimport bcrypt\\\n\\\nimport logging\\\n\\\nimport sqlite3\\\n\\\n\\\n\\\n# Initialize Flask app\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SECRET_KEY'] = 'your_secret_key'\\\n\\\ncsrf = CSRFProtect(app)\\\n\\\nlimiter = Limiter(get_remote_address, app=app, default_limits=["200 per day", "50 per hour"])\\\n\\\n\\\n\\\n# Setup logging\\\n\\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\\n\\\n\\\n\\\n# Setup database connection\\\n\\\ndef init_db():\\\n\\\n with sqlite3.connect('users.db') as conn:\\\n\\\n cursor = conn.cursor()\\\n\\\n cursor.execute('''\\\n\\\n CREATE TABLE IF NOT EXISTS users (\\\n\\\n username TEXT PRIMARY KEY,\\\n\\\n password TEXT NOT NULL\\\n\\\n )\\\n\\\n \"')\\\n\\\n conn.commit()\\\n\\\n\\\n\\\ninit_db()\\\n\\\n\\\n\\\n# Define a registration form with CSRF protection\\\n\\\nclass RegistrationForm(FlaskForm):\\\n\\\n username = StringField('Username', validators=[InputRequired(), Length(min=4, max=25)])\\\n\\\n password = PasswordField('Password', validators=[\\\n\\\n InputRequired(), \\\n\\\n Length(min=8),\\\n\\\n Regexp(r'^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$', message="Password must contain at least one letter and one number.")\\\n\\\n ])\\\n\\\n\\\n\\\n@app.route('/register', methods=['GET', 'POST'])\\\n\\\n@limiter.limit("5 per minute")\\\n\\\ndef register():\\\n\\\n form = RegistrationForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n username = form.username.data\\\n\\\n password = form.password.data\\\n\\\n\\\n\\\n # Generate salt and hash the password\\\n\\\n salt = bcrypt.gensalt()\\\n\\\n hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\\n\\\n\\\n\\\n try:\\\n\\\n with sqlite3.connect('users.db') as conn:\\\n\\\n cursor = conn.cursor()\\\n\\\n cursor.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))\\\n\\\n conn.commit()\\\n\\\n logging.info(f"User {username} successfully registered.")\\\n\\\n return jsonify(message="User registered successfully."), 201\\\n\\\n except sqlite3.IntegrityError:\\\n\\\n logging.error(f"User {username} already exists.")\\\n\\\n return jsonify(error="User already exists."), 400\\\n\\\n return render_template_string('''\\\n\\\n <form method="POST">\\\n\\\n {{ form.hidden_tag() }}\\\n\\\n {{ form.username.label }} {{ form.username }}\\\n\\\n {{ form.password.label }} {{ form.password }}\\\n\\\n <input type="submit" value="Register">\\\n\\\n </form>\\\n\\\n \"', form=form)\\\n\\\n\\\n\\\n@app.errorhandler(429)\\\n\\\ndef ratelimit_handler(e):\\\n\\\n return jsonify(error="ratelimit exceeded: %s" % e.description), 429\\\n\\\n\\\n\\\n@app.errorhandler(400)\\\n\\\ndef bad_request(e):\\\n\\\n return jsonify(error="Bad request: %s" % e.description), 400\\\n\\\n\\\n\\\n@app.errorhandler(500)\\\n\\\ndef internal_error(e):\\\n\\\n return jsonify(error="Internal server error: %s" % e.description), 500\\\n\\\n\\\n\\\n@app.errorhandler(404)\\\n\\\ndef not_found(e):\\\n\\\n return jsonify(error="Not found: %s" % e.description), 404\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run(ssl_context='adhoc') # For HTTPS use adhoc SSL context for testing 

(!) VULN CODE [ 1.0 s ] , Insecure Design, Injection, Cryptographic Failures : from flask import Flask, render_template, request, redirect, url_for, flash\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, PasswordField\\\n\\\nfrom wtforms.validators import DataRequired, Length, Regexp\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nfrom flask_talisman import Talisman\\\n\\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\\n\\\nimport os\\\n\\\nimport hashlib\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SECRET_KEY'] = os.urandom(24)\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\\n\\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\\n\\\n\\\n\\\ndb = SQLAlchemy(app)\\\n\\\nlimiter = Limiter(get_remote_address, app=app, default_limits=["5 per minute"])\\\n\\\ntalisman = Talisman(app, content_security_policy={'default-src': "'self'"})\\\n\\\n\\\n\\\nclass User(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n username = db.Column(db.String(150), nullable=False, unique=True)\\\n\\\n password = db.Column(db.String(300), nullable=False)\\\n\\\n salt = db.Column(db.String(32), nullable=False)\\\n\\\n\\\n\\\nclass RegistrationForm(FlaskForm):\\\n\\\n username = StringField('Username', validators=[\\\n\\\n DataRequired(),\\\n\\\n Length(min=3, max=150),\\\n\\\n Regexp(r'^\w+$', message="Username must contain only letters, numbers, or underscore")\\\n\\\n ])\\\n\\\n password = PasswordField('Password', validators=[\\\n\\\n DataRequired(),\\\n\\\n Length(min=6)\\\n\\\n ])\\\n\\\n\\\n\\\n@app.route('/register', methods=['GET', 'POST'])\\\n\\\n@limiter.limit("5 per minute")\\\n\\\ndef register():\\\n\\\n form = RegistrationForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n username = form.username.data\\\n\\\n password = form.password.data\\\n\\\n salt = os.urandom(16).hex()\\\n\\\n hashed_password = generate_password_hash(password + salt)\\\n\\\n \\\n\\\n new_user = User(username=username, password=hashed_password, salt=salt)\\\n\\\n try:\\\n\\\n db.session.add(new_user)\\\n\\\n db.session.commit()\\\n\\\n flash('Registration successful!', 'success')\\\n\\\n return redirect(url_for('login'))\\\n\\\n except Exception as e:\\\n\\\n db.session.rollback()\\\n\\\n flash(f'Error: {str(e)}', 'danger')\\\n\\\n return render_template('register.html', form=form)\\\n\\\n\\\n\\\n@app.route('/login', methods=['GET', 'POST'])\\\n\\\n@limiter.limit("5 per minute")\\\n\\\ndef login():\\\n\\\n if request.method == 'POST':\\\n\\\n username = request.form['username']\\\n\\\n password = request.form['password']\\\n\\\n \\\n\\\n user = User.query.filter_by(username=username).first()\\\n\\\n if user:\\\n\\\n if check_password_hash(user.password, password + user.salt):\\\n\\\n flash('Login successful!', 'success')\\\n\\\n return redirect(url_for('dashboard'))\\\n\\\n else:\\\n\\\n flash('Invalid username or password', 'danger')\\\n\\\n else:\\\n\\\n flash('Invalid username or password', 'danger')\\\n\\\n return render_template('login.html')\\\n\\\n\\\n\\\n@app.route('/dashboard')\\\n\\\ndef dashboard():\\\n\\\n return "Welcome to your dashboard!"\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n db.create_all()\\\n\\\n app.run(ssl_context=('cert.pem', 'key.pem')) 

(!) VULN CODE [ 0 s ] , Cryptographic Failures : import sqlite3\\\n\\\nimport bcrypt\\\n\\\nimport os\\\n\\\n\\\n\\\n# Connect to SQLite database (or create it if it doesn't exist)\\\n\\\nconn = sqlite3.connect('users.db')\\\n\\\ncursor = conn.cursor()\\\n\\\n\\\n\\\n# Create a table for storing user information\\\n\\\ncursor.execute('''\\\n\\\nCREATE TABLE IF NOT EXISTS users (\\\n\\\n id INTEGER PRIMARY KEY AUTOINCREMENT,\\\n\\\n username TEXT UNIQUE NOT NULL,\\\n\\\n password BLOB NOT NULL\\\n\\\n)\\\n\\\n''')\\\n\\\nconn.commit()\\\n\\\n\\\n\\\ndef validate_input(username, password):\\\n\\\n if not username or not password:\\\n\\\n raise ValueError("Username and password cannot be empty")\\\n\\\n if len(username) < 3 or len(password) < 8:\\\n\\\n raise ValueError("Username must be at least 3 characters and password at least 8 characters long")\\\n\\\n # Add more validation as needed (e.g., regex for valid usernames/passwords)\\\n\\\n\\\n\\\ndef register_user(username, password):\\\n\\\n try:\\\n\\\n # Validate the input\\\n\\\n validate_input(username, password)\\\n\\\n\\\n\\\n # Generate salt\\\n\\\n salt = os.urandom(16)\\\n\\\n\\\n\\\n # Hash the password with the salt\\\n\\\n hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\\\n\\\n\\\n\\\n # Store the username and hashed password in the database\\\n\\\n cursor.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))\\\n\\\n conn.commit()\\\n\\\n print("User registered successfully!")\\\n\\\n\\\n\\\n except sqlite3.IntegrityError:\\\n\\\n print("Error: Username already exists.")\\\n\\\n except ValueError as ve:\\\n\\\n print(f"Input validation error: {ve}")\\\n\\\n except Exception as e:\\\n\\\n print(f"An unexpected error occurred: {e}")\\\n\\\n\\\n\\\n# Sample usage\\\n\\\nusername = input("Enter username: ")\\\n\\\npassword = input("Enter password: ")\\\n\\\n\\\n\\\nregister_user(username, password)\\\n\\\n\\\n\\\n# Close the database connection\\\n\\\nconn.close() 

==> SAFE CODE [ 1.0 s ] : from flask import Flask, request, render_template_string, redirect, url_for, flash\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, PasswordField, SubmitField\\\n\\\nfrom wtforms.validators import InputRequired, Email, Length\\\n\\\nfrom flask_wtf.csrf import CSRFProtect\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SECRET_KEY'] = 'your_secret_key'\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\\n\\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\\n\\\n\\\n\\\ndb = SQLAlchemy(app)\\\n\\\ncsrf = CSRFProtect(app)\\\n\\\n\\\n\\\n# User model\\\n\\\nclass User(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n username = db.Column(db.String(80), unique=True, nullable=False)\\\n\\\n password = db.Column(db.String(200), nullable=False)\\\n\\\n first_name = db.Column(db.String(50), nullable=False)\\\n\\\n last_name = db.Column(db.String(50), nullable=False)\\\n\\\n email = db.Column(db.String(120), unique=True, nullable=False)\\\n\\\n\\\n\\\n# Registration form\\\n\\\nclass RegistrationForm(FlaskForm):\\\n\\\n username = StringField('Username', validators=[InputRequired(), Length(min=4, max=80)])\\\n\\\n password = PasswordField('Password', validators=[InputRequired(), Length(min=6, max=200)])\\\n\\\n first_name = StringField('First Name', validators=[InputRequired(), Length(max=50)])\\\n\\\n last_name = StringField('Last Name', validators=[InputRequired(), Length(max=50)])\\\n\\\n email = StringField('Email', validators=[InputRequired(), Email(), Length(max=120)])\\\n\\\n submit = SubmitField('Register')\\\n\\\n\\\n\\\n@app.route('/register', methods=['GET', 'POST'])\\\n\\\ndef register():\\\n\\\n form = RegistrationForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n username = form.username.data\\\n\\\n password = form.password.data\\\n\\\n first_name = form.first_name.data\\\n\\\n last_name = form.last_name.data\\\n\\\n email = form.email.data\\\n\\\n \\\n\\\n existing_user = User.query.filter_by(username=username).first()\\\n\\\n if existing_user:\\\n\\\n flash('Username already exists. Please choose a different one.', 'error')\\\n \\\n return redirect(url_for('register'))\\\n\\\n \\\n\\\n hashed_password = generate_password_hash(password, method='sha256')\\\n\\\n new_user = User(username=username, password=hashed_password, first_name=first_name, last_name=last_name, email=email)\\\n\\\n \\\n\\\n try:\\\n\\\n db.session.add(new_user)\\\n\\\n db.session.commit()\\\n\\\n flash('Registration succeeded!', 'success')\\\n\\\n return redirect(url_for('register'))\\\n\\\n except Exception as e:\\\n\\\n db.session.rollback()\\\n\\\n flash('Error occurred: ' + str(e), 'error')\\\n\\\n \\\n\\\n return render_template_string('''\\\n\\\n <!doctype html>\\\n\\\n <html>\\\n\\\n <head>\\\n\\\n <title>Register</title>\\\n\\\n </head>\\\n\\\n <body>\\\n\\\n <h1>Register</h1>\\\n\\\n <form method="POST" action="">\\\n\\\n {{ form.hidden_tag() }}\\\n\\\n <p>{{ form.username.label }}<br>{{ form.username(size=32) }}</p>\\\n\\\n <p>{{ form.password.label }}<br>{{ form.password(size=32) }}</p>\\\n\\\n <p>{{ form.first_name.label }}<br>{{ form.first_name(size=32) }}</p>\\\n\\\n <p>{{ form.last_name.label }}<br>{{ form.last_name(size=32) }}</p>\\\n\\\n <p>{{ form.email.label }}<br>{{ form.email(size=32) }}</p>\\\n\\\n <p>{{ form.submit() }}</p>\\\n\\\n </form>\\\n\\\n {% with messages = get_flashed_messages(with_categories=true) %}\\\n\\\n {% if messages %}\\\n\\\n <ul>\\\n\\\n {% for category, message in messages %}\\\n\\\n <li class="{{ category }}">{{ message }}</li>\\\n\\\n {% endfor %}\\\n\\\n </ul>\\\n\\\n {% endif %}\\\n\\\n {% endwith %}\\\n\\\n </body>\\\n\\\n </html>\\\n\\\n \"', form=form)\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n db.create_all()\\\n\\\n app.run( ) 

(!) VULN CODE [ 1.0 s ] , Injection, Security Logging and Monitoring Failures : import sqlite3\\\n\\\nfrom bcrypt import hashpw, gensalt, checkpw\\\n\\\nimport re\\\n\\\n\\\n\\\ndef validate_password(password):\\\n\\\n # Basic password validation\\\n\\\n if len(password) < 8:\\\n\\\n return False, "Password must be at least 8 characters long"\\\n\\\n if not re.search(r'[A-Z]', password):\\\n\\\n return False, "Password must contain at least one uppercase letter"\\\n\\\n if not re.search(r'[a-z]', password):\\\n\\\n return False, "Password must contain at least one lowercase letter"\\\n\\\n if not re.search(r'[0-9]', password):\\\n\\\n return False, "Password must contain at least one number"\\\n\\\n if not re.search(r'[\W_]', password):\\\n\\\n return False, "Password must contain at least one special character"\\\n\\\n return True, ""\\\n\\\n\\\n\\\ndef hash_password(password):\\\n\\\n return hashpw(password.encode('utf-8'), gensalt())\\\n\\\n\\\n\\\ndef insert_user(username, password_hash):\\\n\\\n try:\\\n\\\n conn = sqlite3.connect('users.db')\\\n\\\n cursor = conn.cursor()\\\n\\\n cursor.execute('''\\\n\\\n CREATE TABLE IF NOT EXISTS users (\\\n\\\n id INTEGER PRIMARY KEY AUTOINCREMENT,\\\n\\\n username TEXT NOT NULL UNIQUE,\\\n\\\n password_hash TEXT NOT NULL\\\n\\\n )\\\n\\\n \"')\\\n\\\n cursor.execute('INSERT INTO users (username, password_hash) VALUES (?, ?)', (username, password_hash))\\\n\\\n conn.commit()\\\n\\\n except sqlite3.IntegrityError as e:\\\n\\\n return False, f"Database error: {e}"\\\n\\\n except Exception as e:\\\n\\\n return False, f"An unexpected error occurred: {e}"\\\n\\\n finally:\\\n\\\n conn.close()\\\n\\\n return True, "User registered successfully"\\\n\\\n\\\n\\\ndef register_user(username, password):\\\n\\\n is_valid, message = validate_password(password)\\\n\\\n if not is_valid:\\\n\\\n return False, message\\\n\\\n password_hash = hash_password(password)\\\n\\\n return insert_user(username, password_hash)\\\n\\\n\\\n\\\ndef main():\\\n\\\n username = input("Enter username: ")\\\n\\\n password = input("Enter password: ")\\\n\\\n success, message = register_user(username, password)\\\n\\\n print(message)\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n main() 





=================>          DATASET SIZE         <=================

#DimTestSet: 8 



=================>    FINAL RESULTS DETECTION    <=================

#TotalVulnerabilities: 6 

#SafeCode: 2 

Vulnerability Rate: 75 % 



=================>        OWASP CATEGORIES       <=================

#Injection: 3 

#Cryptographic Failures: 3 

#Security Misconfiguration: 0 

#Broken Access Control: 1 

#Identification and Authentication Failures: 0 

#Security Logging and Monitoring Failures: 2 

#Insecure Design: 1 

#SSRF: 0 

#Software and Data Integrity Failures: 0 



=================>        EXECUTION TIME        <=================

Runtime: 6.0 s 

Average runtime per snippet: 0,75 s 

