==================>      SNIPPETS DETECTED      <========================
|                                                                       |
|           (!) VULN CODE : Vulnerable code snippets detected           |
|           ==> SAFE CODE : Safe code snippet                           |
|                                                                       |
|                 [XXX s] : Execution Time per snippet                  |
|                                                                       |
=========================================================================

==> SAFE CODE [ 1.0 s ] : import json\\\n\\\nfrom flask import Flask, request, jsonify\\\n\\\nfrom werkzeug.exceptions import BadRequest\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n@app.route('/api', methods=['GET'])\\\n\\\ndef api():\\\n\\\n try:\\\n\\\n # Get the payload parameter from the URL\\\n\\\n payload = request.args.get('payload')\\\n\\\n \\\n\\\n # Check if payload is provided\\\n\\\n if payload is None:\\\n\\\n raise BadRequest('Payload parameter is missing')\\\n\\\n \\\n\\\n # Convert payload to dictionary\\\n\\\n try:\\\n\\\n payload_dict = json.loads(payload)\\\n\\\n if not isinstance(payload_dict, dict):\\\n\\\n raise ValueError\\\n\\\n except (json.JSONDecodeError, ValueError):\\\n \\\n raise BadRequest('Invalid payload format. It should be a JSON dictionary.')\\\n\\\n\\\n\\\n # Validate presence of 'name' key in the dictionary\\\n\\\n if 'name' not in payload_dict:\\\n\\\n raise BadRequest("'name' key is missing in the payload")\\\n\\\n\\\n\\\n # Get the name value from the dictionary\\\n\\\n name_value = payload_dict['name']\\\n\\\n\\\n\\\n # Return the name value in a JSON response\\\n\\\n return jsonify({'name': name_value}), 200\\\n\\\n\\\n\\\n except BadRequest as e:\\\n\\\n # Return error message for bad requests\\\n\\\n return jsonify({'error': str(e)}), 400\\\n\\\n\\\n\\\n except Exception as e:\\\n\\\n # Handle unexpected errors\\\n\\\n return jsonify({'error': 'An unexpected error occurred'}), 500\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run() 

==> SAFE CODE [ 1.0 s ] : from flask import Flask, request, render_template_string, make_response\\\n\\\nfrom flask_wtf.csrf import CSRFProtect\\\n\\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\\n\\\nfrom wtforms import Form, StringField, validators\\\n\\\nfrom markupsafe import escape\\\n\\\nimport os\\\n\\\n\\\n\\\n# Create an instance of the Flask class\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Set a secret key for CSRF protection\\\n\\\napp.config['SECRET_KEY'] = os.urandom(24)\\\n\\\ncsrf = CSRFProtect(app)\\\n\\\n\\\n\\\n# Enforce HTTPS\\\n\\\nclass SecureMiddleware:\\\n\\\n def __init__(self, app):\\\n\\\n self.app = app\\\n\\\n\\\n\\\n def __call__(self, environ, start_response):\\\n\\\n if environ['wsgi.url_scheme'] != 'https':\\\n\\\n start_response('301 Moved Permanently', [('Location', 'https://' + environ['HTTP_HOST'] + environ['PATH_INFO'])])\\\n\\\n return []\\\n\\\n return self.app(environ, start_response)\\\n\\\n\\\n\\\napp.wsgi_app = SecureMiddleware(app.wsgi_app)\\\n\\\n\\\n\\\n# Disable caching for sensitive data\\\n\\\n@app.after_request\\\n\\\ndef add_header(response):\\\n\\\n response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0, max-age=0'\\\n\\\n response.headers['Pragma'] = 'no-cache'\\\n\\\n response.headers['Expires'] = '-1'\\\n\\\n return response\\\n\\\n\\\n\\\n# Input validation form using WTForms\\\n\\\nclass InputForm(Form):\\\n\\\n user_input = StringField('User Input', [validators.DataRequired(), validators.Length(min=1, max=100)])\\\n\\\n\\\n\\\n# Route and function\\\n\\\n@app.route('/show_message', methods=['GET', 'POST'])\\\n\\\ndef show_message():\\\n\\\n form = InputForm(request.form)\\\n\\\n if request.method == 'POST' and form.validate():\\\n\\\n # Input sanitization using escape to prevent XSS\\\n\\\n user_input = escape(form.user_input.data)\\\n\\\n return render_template_string('<h1>Your input: {{ user_input }}</h1>', user_input=user_input)\\\n\\\n return render_template_string('''\\\n\\\n <form method="post">\\\n\\\n {{ form.hidden_tag() }}\\\n\\\n {{ form.user_input.label }} {{ form.user_input(size=20) }}<br>\\\n\\\n <input type="submit" value="Submit">\\\n\\\n </form>\\\n\\\n \"', form=form)\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n # Use ProxyFix to handle X-Forwarded-Proto header for HTTPS enforcement\\\n\\\n app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1)\\\n\\\n app.run(ssl_context='adhoc') 

(!) VULN CODE [ 0 s ] , Injection, Injection, Software and Data Integrity Failures : from flask import Flask, request, jsonify, abort\\\n\\\nimport yaml\\\n\\\nfrom yaml.loader import SafeLoader\\\n\\\nimport ssl\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Secure Configuration\\\n\\\napp.config['JSONIFY_PRETTYPRINT_REGULAR'] = False\\\n\\\n\\\n\\\ndef validate_payload(data):\\\n\\\n required_keys = ['type', 'name']\\\n\\\n for key in required_keys:\\\n\\\n if key not in data:\\\n\\\n return False\\\n\\\n return True\\\n\\\n\\\n\\\n@app.route('/process', methods=['POST'])\\\n\\\ndef process_request():\\\n\\\n if not request.is_json:\\\n\\\n abort(400, description="Invalid request: Content-Type must be application/json")\\\n\\\n\\\n\\\n content = request.get_json()\\\n\\\n\\\n\\\n if 'payload' not in content:\\\n\\\n abort(400, description="Missing parameter: payload")\\\n\\\n\\\n\\\n try:\\\n\\\n payload = yaml.load(content['payload'], Loader=SafeLoader)\\\n\\\n except yaml.YAMLError as exc:\\\n\\\n abort(400, description=f"Invalid YAML: {exc}")\\\n\\\n\\\n\\\n if not validate_payload(payload):\\\n\\\n abort(400, description="Invalid payload structure")\\\n\\\n\\\n\\\n if payload['type'] == 'Create':\\\n\\\n return jsonify({"error": "Create operation is not allowed"}), 400\\\n\\\n\\\n\\\n if payload['type'] == 'Update':\\\n\\\n if payload['name'] == 'UnsafeDeserialization':\\\n\\\n return jsonify({"error": "UnsafeDeserialization is not allowed"}), 400\\\n\\\n\\\n\\\n return jsonify({"message": "Success"}), 200\\\n\\\n\\\n\\\n@app.errorhandler(400)\\\n\\\ndef handle_400_error(e):\\\n\\\n return jsonify(error=str(e)), 400\\\n\\\n\\\n\\\n@app.errorhandler(500)\\\n\\\ndef handle_500_error(e):\\\n\\\n return jsonify(error="Internal Server Error"), 500\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n # Set up HTTPS (Assuming you have cert.pem and key.pem for SSL)\\\n\\\n context = ssl.SSLContext(ssl.PROTOCOL_TLS)\\\n\\\n context.load_cert_chain('cert.pem', 'key.pem')\\\n\\\n app.run(host='0.0.0.0', port=5000, ssl_context=context) 

(!) VULN CODE [ 1.0 s ] , Broken Access Control : import os\\\n\\\nfrom flask import Flask, request, jsonify\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom sqlalchemy.exc import SQLAlchemyError\\\n\\\nfrom dotenv import load_dotenv\\\n\\\nfrom datetime import datetime\\\n\\\nfrom flask_session import Session\\\n\\\n\\\n\\\n# Load environment variables from .env file\\\n\\\nload_dotenv()\\\n\\\n\\\n\\\n# Flask app setup\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Secure Flask configuration\\\n\\\napp.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'default_secret_key')\\\n\\\napp.config['SESSION_TYPE'] = 'filesystem'\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///sensor.db')\\\n\\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\\n\\\n\\\n\\\n# Initialize session management\\\n\\\nSession(app)\\\n\\\n\\\n\\\n# Initialize database\\\n\\\ndb = SQLAlchemy(app)\\\n\\\n\\\n\\\n# Define the Sensor model\\\n\\\nclass Sensor(db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n latitude = db.Column(db.Float, nullable=False)\\\n\\\n longitude = db.Column(db.Float, nullable=False)\\\n\\\n date = db.Column(db.Date, nullable=False)\\\n\\\n temperature = db.Column(db.Float, nullable=False)\\\n\\\n\\\n\\\n def __repr__(self):\\\n\\\n return f'<Sensor {self.id} - {self.temperature}C>'\\\n\\\n\\\n\\\n# Create the database tables\\\n\\\nwith app.app_context():\\\n\\\n db.create_all()\\\n\\\n\\\n\\\n# Utility function to validate and parse date\\\n\\\ndef parse_date(date_str):\\\n\\\n try: \\\n\\\n return datetime.strptime(date_str, '%Y-%m-%d').date()\\\n\\\n except ValueError:\\\n\\\n return None\\\n\\\n\\\n\\\n# Endpoint to get temperature for a given location and date\\\n\\\n@app.route('/api/temperature_for_location', methods=['POST'])\\\n\\\ndef temperature_for_location():\\\n\\\n data = request.json\\\n\\\n \\\n\\\n # Input validation\\\n\\\n if not data:\\\n\\\n return jsonify({'error': 'No input data provided'}), 400\\\n\\\n\\\n\\\n latitude = data.get('latitude')\\\n\\\n longitude = data.get('longitude')\\\n\\\n date_str = data.get('date')\\\n\\\n\\\n\\\n if latitude is None or longitude is None or date_str is None:\\\n\\\n return jsonify({'error': 'Missing required parameters'}), 400\\\n\\\n\\\n\\\n try:\\\n\\\n latitude = float(latitude)\\\n\\\n longitude = float(longitude)\\\n\\\n except ValueError:\\\n\\\n return jsonify({'error': 'Invalid latitude or longitude format'}), 400\\\n\\\n\\\n\\\n date = parse_date(date_str)\\\n\\\n if date is None:\\\n\\\n return jsonify({'error': 'Invalid date format. Expected YYYY-MM-DD'}), 400\\\n\\\n\\\n\\\n # Database query\\\n\\\n try:\\\n\\\n sensor_data = Sensor.query.filter_by(latitude=latitude, longitude=longitude, date=date).first()\\\n\\\n if sensor_data:\\\n\\\n return jsonify({'temperature': sensor_data.temperature}), 200\\\n\\\n else:\\\n\\\n return jsonify({'error': 'Data not found for the given parameters'}), 404\\\n\\\n except SQLAlchemyError as e:\\\n\\\n return jsonify({'error': str(e)}), 500\\\n\\\n\\\n\\\n# Run the Flask app\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( )\\\n\\\n 

==> SAFE CODE [ 1.0 s ] : from flask import Flask, request, jsonify\\\n\\\nimport mysql.connector\\\n\\\nfrom mysql.connector import Error\\\n\\\nimport os\\\n\\\nfrom dotenv import load_dotenv\\\n\\\n\\\n\\\n# Load environment variables from .env file\\\n\\\nload_dotenv()\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Function to get database connection\\\n\\\ndef get_db_connection():\\\n\\\n try:\\\n\\\n connection = mysql.connector.connect(\\\n\\\n host=os.getenv('MYSQL_HOST'),\\\n\\\n user=os.getenv('MYSQL_USER'),\\\n\\\n password=os.getenv('MYSQL_PASSWORD'),\\\n\\\n database=os.getenv('MYSQL_DB')\\\n\\\n )\\\n\\\n if connection.is_connected():\\\n\\\n return connection\\\n\\\n except Error as e:\\\n\\\n print("Error while connecting to MySQL", e)\\\n\\\n return None\\\n\\\n\\\n\\\n# Route to handle temperature query\\\n\\\n@app.route('/api/temperature_for_location', methods=['GET'])\\\n\\\ndef get_temperature_for_location():\\\n\\\n try:\\\n\\\n # Extract and validate input parameters\\\n\\\n lat = request.args.get('latitude')\\\n\\\n lon = request.args.get('longitude')\\\n\\\n year = request.args.get('year')\\\n\\\n month = request.args.get('month')\\\n\\\n day = request.args.get('day')\\\n\\\n grib_file = request.args.get('grib_file')\\\n\\\n\\\n\\\n if not all([lat, lon, year, month, day, grib_file]):\\\n\\\n return jsonify({"error": "Missing required parameters"}), 400\\\n \\\n\\\n\\\n # Input sanitization and validation\\\n\\\n try:\\\n\\\n lat = float(lat)\\\n\\\n lon = float(lon)\\\n\\\n year = int(year)\\\n\\\n month = int(month)\\\n\\\n day = int(day)\\\n\\\n except ValueError:\\\n\\\n return jsonify({"error": "Invalid input types"}), 400\\\n\\\n\\\n\\\n # Secure database query\\\n\\\n query = """\\\n\\\n SELECT MAX(temperature) as max_temp\\\n\\\n FROM temperatures\\\n\\\n WHERE latitude = %s AND longitude = %s AND year = %s AND month = %s AND day = %s AND grib_file = %s\\\n\\\n """\\\n\\\n\\\n\\\n # Database connection and query execution\\\n\\\n connection = get_db_connection()\\\n\\\n if connection is None:\\\n\\\n return jsonify({"error": "Database connection failed"}), 500\\\n\\\n\\\n\\\n cursor = connection.cursor(dictionary=True)\\\n\\\n cursor.execute(query, (lat, lon, year, month, day, grib_file))\\\n\\\n result = cursor.fetchone()\\\n\\\n\\\n\\\n cursor.close()\\\n\\\n connection.close()\\\n\\\n\\\n\\\n if result:\\\n\\\n return jsonify(result), 200\\\n\\\n else:\\\n\\\n return jsonify({"error": "No data found"}), 404\\\n\\\n\\\n\\\n except Exception as e:\\\n\\\n return jsonify({"error": str(e)}), 500\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 

==> SAFE CODE [ 0 s ] : from flask import Flask, request, jsonify\\\n\\\nfrom psycopg2 import connect, sql\\\n\\\nfrom psycopg2.extras import RealDictCursor\\\n\\\nimport os\\\n\\\nfrom dotenv import load_dotenv\\\n\\\nimport logging\\\n\\\nfrom datetime import datetime\\\n\\\n\\\n\\\n# Load environment variables\\\n\\\nload_dotenv()\\\n\\\n\\\n\\\n# Configure logging\\\n\\\nlogging.basicConfig(level=logging.INFO)\\\n\\\nlogger = logging.getLogger(__name__)\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Get database URL from environment variables\\\n\\\nDATABASE_URL = os.getenv('DATABASE_URL')\\\n\\\n\\\n\\\ndef get_db_connection():\\\n\\\n try:\\\n\\\n conn = connect(DATABASE_URL)\\\n\\\n return conn\\\n\\\n except Exception as e:\\\n\\\n logger.error("Database connection failed: %s", str(e))\\\n\\\n raise\\\n\\\n\\\n\\\ndef validate_input(lat, lon, date):\\\n\\\n try:\\\n\\\n lat = float(lat)\\\n\\\n lon = float(lon)\\\n\\\n datetime.strptime(date, '%Y-%m-%d')\\\n\\\n except ValueError as e:\\\n\\\n logger.error("Invalid input: %s", str(e))\\\n\\\n return False\\\n\\\n return T \\\n\\\n\\\n\\\n@app.route('/api/temperature_for_location', methods=['GET'])\\\n\\\ndef temperature_for_location():\\\n\\\n lat = request.args.get('lat')\\\n\\\n lon = request.args.get('lon')\\\n\\\n date = request.args.get('date')\\\n\\\n\\\n\\\n if not validate_input(lat, lon, date):\\\n\\\n return jsonify({'error': 'Invalid input'}), 400\\\n\\\n\\\n\\\n try:\\\n\\\n conn = get_db_connection()\\\n\\\n cursor = conn.cursor(cursor_factory=RealDictCursor)\\\n\\\n \\\n\\\n query = sql.SQL("""\\\n\\\n SELECT temperature \\\n\\\n FROM temperatures \\\n\\\n WHERE latitude = %s AND longitude = %s AND date = %s\\\n\\\n """)\\\n\\\n \\\n\\\n cursor.execute(query, (lat, lon, date))\\\n\\\n result = cursor.fetchone()\\\n\\\n cursor.close()\\\n\\\n conn.close()\\\n\\\n\\\n\\\n if result:\\\n\\\n return jsonify({'temperature': result['temperature']})\\\n\\\n else:\\\n\\\n return jsonify({'error': 'Temperature data not found'}), 404\\\n\\\n\\\n\\\n except Exception as e:\\\n\\\n logger.error("Error fetching temperature data: %s", str(e))\\\n\\\n return jsonify({'error': 'Internal Server Error'}), 500\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 

==> SAFE CODE [ 0 s ] : from flask import Flask, request, jsonify\\\n\\\nimport yaml\\\n\\\nfrom yaml.loader import SafeLoader\\\n\\\nimport os\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Secure product catalog\\\n\\\nPRODUCT_CATALOG = {\\\n\\\n 'P001': 29.99,\\\n\\\n 'P002': 49.99,\\\n\\\n 'P003': 9.99,\\\n\\\n}\\\n\\\n\\\n\\\ndef get_product_price(product_code):\\\n\\\n # Separation of concerns: Product price retrieval\\\n\\\n return PRODUCT_CATALOG.get(product_code)\\\n\\\n\\\n\\\ndef calculate_total_price(product_code, quantity):\\\n\\\n # Separation of concerns: Total price calculation\\\n\\\n price = get_product_price(product_code)\\\n\\\n if price is None:\\\n\\\n raise ValueError("Invalid product code")\\\n\\\n return price * quantity\\\n\\\n\\\n\\\n@app.route('/calculate_price', methods=['GET'])\\\n\\\ndef calculate_price():\\\n\\\n # Entry point for the API\\\n\\\n try:\\\n\\\n yaml_payload = request.args.get('payload')\\\n\\\n if not yaml_payload:\\\n \\\n raise ValueError("Missing 'payload' query parameter")\\\n\\\n \\\n\\\n # Secure YAML Parsing\\\n\\\n try:\\\n\\\n data = yaml.safe_load(yaml_payload)\\\n\\\n except yaml.YAMLError as e:\\\n\\\n raise ValueError(f"Invalid YAML payload: {str(e)}")\\\n\\\n\\\n\\\n # Input Validation\\\n\\\n if not isinstance(data, dict):\\\n\\\n raise ValueError("Payload must be a dictionary")\\\n\\\n if 'product_code' not in data or 'quantity' not in data:\\\n\\\n raise ValueError("Payload must contain 'product_code' and 'quantity'")\\\n\\\n product_code = data['product_code']\\\n\\\n quantity = data['quantity']\\\n\\\n if not isinstance(product_code, str) or not isinstance(quantity, int):\\\n\\\n raise ValueError("'product_code' must be a string and 'quantity' must be an integer")\\\n\\\n if quantity <= 0:\\\n\\\n raise ValueError("'quantity' must be a positive integer")\\\n\\\n\\\n\\\n # Calculate total price\\\n\\\n total_price = calculate_total_price(product_code, quantity)\\\n\\\n return jsonify({"total_price": f"{total_price:.2f}"})\\\n\\\n \\\n\\\n except ValueError as e:\\\n\\\n return jsonify({"error": str(e)}), 400\\\n\\\n except Exception as e:\\\n\\\n return jsonify({"error": "An unexpected error occurred"}), 500\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 

(!) VULN CODE [ 1.0 s ] , Broken Access Control : from flask import Flask, request, jsonify\\\n\\\nimport os\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Secret Key Generation\\\n\\\napp.secret_key = os.urandom(24)\\\n\\\n\\\n\\\n# Security Headers\\\n\\\n@app.after_request\\\n\\\ndef set_security_headers(response):\\\n\\\n response.headers['Content-Security-Policy'] = "default-src 'self'"\\\n\\\n response.headers['X-Content-Type-Options'] = 'nosniff'\\\n\\\n response.headers['X-Frame-Options'] = 'DENY'\\\n\\\n response.headers['X-XSS-Protection'] = '1; mode=block'\\\n\\\n return response\\\n\\\n\\\n\\\n# Sample data for product prices\\\n\\\nproduct_prices = {\\\n\\\n "P001": 19.99,\\\n\\\n "P002": 29.99,\\\n\\\n "P003": 9.99\\\n\\\n}\\\n\\\n\\\n\\\n# Function to get the price for a product code\\\n\\\ndef get_price(product_code):\\\n\\\n return product_prices.get(product_code, None)\\\n\\\n\\\n\\\n# Input Validation Function\\\n\\\ndef is_valid_product_code(product_code):\\\n\\\n return product_code in product_prices\\\n\\\n\\\n\\\n# Route to calculate the price for a product code and quantity\\\n\\\n@app.route('/calculate_price', methods=['POST'])\\\n\\\ndef calculate_price():\\\n\\\n try:\\\n\\\n data = request.get_json()\\\n\\\n if not data or 'product_code' not in data or 'quantity' not in data:\\\n\\\n return jsonify({'error': 'Invalid input'}), 400\\\n\\\n\\\n\\\n product_code = data['product_code']\\\n\\\n quantity = data['quantity']\\\n\\\n\\\n\\\n if not isinstance(quantity, int) or quantity <= 0:\\\n\\\n return jsonify({'error': 'Quantity must be a positive integer'}), 400\\\n\\\n\\\n\\\n if not is_valid_product_code(product_code):\\\n\\\n return jsonify({'error': 'Invalid product code'}), 400\\\n\\\n\\\n\\\n price = get_price(product_code)\\\n\\\n total_price = price * quantity\\\n\\\n\\\n\\\n return jsonify({'product_code': product_code, 'quantity': quantity, 'total_price': total_price})\\\n\\\n\\\n\\\n except Exception as e:\\\n\\\n return jsonify({'error': str(e)}), 500\\\n\\\n\\\n\\\n# Reverse Proxy Support\\\n\\\n@app.before_request\\\n\\\ndef before_request():\\\n\\\n if request.headers.get('X-Forwarded-Proto') == 'https':\\\n\\\n request.environ['wsgi.url_scheme'] = 'https'\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run(port=5000) 

==> SAFE CODE [ 0 s ] : from flask import Flask, request, jsonify\\\n\\\nimport yaml\\\n\\\nimport logging\\\n\\\nfrom werkzeug.exceptions import BadRequest\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Setup basic logging\\\n\\\nlogging.basicConfig(level=logging.INFO)\\\n\\\n\\\n\\\n# Mock function to get price for a product code\\\n\\\ndef get_price_for_product_code(product_code):\\\n\\\n # Simulated product prices\\\n\\\n product_prices = {\\\n\\\n 'A001': 10.0,\\\n\\\n 'A002': 20.0,\\\n\\\n 'A003': 30.0\\\n\\\n }\\\n\\\n return product_prices.get(product_code)\\\n\\\n\\\n\\\n@app.route('/calculate_price', methods=['GET'])\\\n\\\ndef calculate_price():\\\n\\\n # Validate query parameter\\\n\\\n yaml_payload = request.args.get('payload')\\\n\\\n if not yaml_payload:\\\n\\\n logging.error("No YAML payload provided")\\\n\\\n return jsonify({"error": "No YAML payload provided"}), 400\\\n\\\n\\\n\\\n try:\\\n\\\n # Load YAML payload into a dictionary\\\n\\\n data = yaml.safe_load(yaml_payload)\\\n\\\n \\\n\\\n # Input validation\\\n\\\n if not isinstance(data, dict):\\\n\\\n raise ValueError("Invalid payload format. Expected a dictionary.")\\\n\\\n \\\n\\\n product_code = data.get('product_code')\\\n\\\n quantity = data.get('quantity')\\\n\\\n\\\n\\\n if not product_code or not isinstance(product_code, str):\\\n\\\n raise ValueError("Invalid or missing product code.")\\\n\\\n \\\n\\\n if not quantity or not isinstance(quantity, int) or quantity <= 0:\\\n\\\n raise ValueError("Invalid or missing quantity.")\\\n\\\n \\\n\\\n # Calculate total price\\\n\\\n price_per_unit = get_price_for_product_code(product_code)\\\n\\\n if price_per_unit is None:\\\n\\\n raise ValueError("Invalid product code.")\\\n\\\n \\\n\\\n total_price = price_per_unit * quantity\\\n\\\n\\\n\\\n # Output sanitization\\\n\\\n response = {\\\n\\\n 'product_code': product_code,\\\n\\\n 'quantity': quantity,\\\n\\\n 'total_price': round(total_price, 2)\\\n\\\n }\\\n\\\n\\\n\\\n # Log the successful operation\\\n\\\n logging.info(f"Price calculated successfully for product {product_code} with quantity {quantity}")\\\n\\\n\\\n\\\n # Return the total price as a YAML payload\\\n\\\n return yaml.safe_dump(response), 200\\\n\\\n\\\n\\\n except yaml.YAMLError as e:\\\n\\\n logging.error(f"Error parsing YAML payload: {e}")\\\n\\\n return jsonify({"error": "Invalid YAML payload"}), 400\\\n\\\n except ValueError as e:\\\n\\\n logging.error(f"Input validation error: {e}")\\\n\\\n return jsonify({"error": str(e)}), 400\\\n\\\n except Exception as e:\\\n\\\n logging.error(f"Unexpected error: {e}")\\\n\\\n return jsonify({"error": "Internal server error"}), 500\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n # Run the Flask application\\\n\\\n app.run(host='127.0.0.1', port=5000, debug=False) 





=================>          DATASET SIZE         <=================

#DimTestSet: 9 



=================>    FINAL RESULTS DETECTION    <=================

#TotalVulnerabilities: 3 

#SafeCode: 6 

Vulnerability Rate: 33,3333 % 



=================>        OWASP CATEGORIES       <=================

#Injection: 1 

#Cryptographic Failures: 0 

#Security Misconfiguration: 0 

#Broken Access Control: 2 

#Identification and Authentication Failures: 0 

#Security Logging and Monitoring Failures: 0 

#Insecure Design: 0 

#SSRF: 0 

#Software and Data Integrity Failures: 1 



=================>        EXECUTION TIME        <=================

Runtime: 6.0 s 

Average runtime per snippet: 0,666667 s 

