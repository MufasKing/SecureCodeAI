==================>      SNIPPETS DETECTED      <========================
|                                                                       |
|           (!) VULN CODE : Vulnerable code snippets detected           |
|           ==> SAFE CODE : Safe code snippet                           |
|                                                                       |
|                 [XXX s] : Execution Time per snippet                  |
|                                                                       |
=========================================================================

==> SAFE CODE [ 1.0 s ] : from flask import Flask, request, redirect, url_for, session, render_template, flash\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nfrom flask_talisman import Talisman\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, PasswordField\\\n\\\nfrom wtforms.validators import DataRequired, Length, Regexp\\\n\\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\\n\\\nimport logging\\\n\\\nfrom itsdangerous import os\\\n\\\n\\\n\\\n# Initialize Flask app\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Generate a secure secret key\\\n\\\napp.config['SECRET_KEY'] = os.urandom(24)\\\n\\\n\\\n\\\n# Setup Flask-Limiter\\\n\\\nlimiter = Limiter(app, key_func=get_remote_address)\\\n\\\n\\\n\\\n# Setup Flask-Talisman for HTTPS and security headers\\\n\\\nTalisman(app)\\\n\\\n\\\n\\\n# Setup logging\\\n\\\nlogging.basicConfig(level=logging.INFO)\\\n\\\n\\\n\\\n# Define the login form\\\n\\\nclass LoginForm(FlaskForm):\\\n\\\n username = StringField('Username', validators=[DataRequired(), Length(min=6, max=35)])\\\n\\\n password = PasswordField('Password', validators=[DataRequired(), Regexp(r'^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$', message="Password complexity requirements not met.")])\\\n\\\n\\\n\\\n# Mock database for demonstration\\\n\\\nusers = {"admin": generate_password_hash("Admin@123")}\\\n\\\n\\\n\\\n@app.route('/')\\\n\\\ndef index():\\\n\\\n return 'Index Page <a href="/login">Login</a>'\\\n\\\n\\\n\\\n@app.route('/login', methods=['GET', 'POST'])\\\n\\\n@limiter.limit("5 per minute")\\\n\\\ndef do_login():\\\n\\\n form = LoginForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n username = form.username.data\\\n\\\n password = form.password.data\\\n\\\n user_password_hash = users.get(username)\\\n\\\n if user_password_hash and check_password_hash(user_password_hash, password):\\\n\\\n session['username'] = username\\\n\\\n return redirect(url_for('secret'))\\\n\\\n else:\\\n\\\n flash('Invalid username or password')\\\n\\\n return redirect(url_for('do_login'))\\\n\\\n return render_template('login.html', form=form)\\\n\\\n\\\n\\\n@app.route('/secret')\\\n\\\ndef secret():\\\n\\\n if 'username' in session:\\\n\\\n return 'Secret settings'\\\n\\\n else:\\\n\\\n return redirect(url_for('do_login'))\\\n\\\n\\\n\\\n@app.errorhandler(404)\\\n\\\ndef page_not_found(e):\\\n\\\n return 'This page does not exist', 404\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run(ssl_context='adhoc') # Use 'adhoc' for demo purposes. For production, specify cert and key. 

(!) VULN CODE [ 1.0 s ] , Insecure Design, Injection : from flask import Flask, redirect, request, session, abort\\\n\\\nfrom flask_login import LoginManager, current_user, login_required\\\n\\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\\n\\\nimport secrets\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.secret_key = secrets.token_hex(16)\\\n\\\n\\\n\\\nlogin_manager = LoginManager()\\\n\\\nlogin_manager.init_app(app)\\\n\\\nlogin_manager.login_view = 'login'\\\n\\\n\\\n\\\n# Mock database for demonstration purposes\\\n\\\nusers = {\\\n\\\n "user": {"password": generate_password_hash("userpass"), "role": "user"},\\\n\\\n "admin": {"password": generate_password_hash("adminpass"), "role": "admin"}\\\n\\\n}\\\n\\\n\\\n\\\n# User loader callback for Flask-Login\\\n\\\n@login_manager.user_loader\\\n\\\ndef load_user(user_id):\\\n\\\n if user_id in users:\\\n\\\n return User(user_id)\\\n\\\n return None\\\n\\\n\\\n\\\nclass User:\\\n\\\n def __init__(self, username):\\\n\\\n self.id = username\\\n\\\n self.role = users[username]['role']\\\n\\\n\\\n\\\n @property\\\n\\\n def is_authenticated(self):\\\n\\\n return True\\\n\\\n\\\n\\\n @property\\\n\\\n def is_active(self):\\\n\\\n return True\\\n\\\n\\\n\\\n @property\\\n\\\n def is_anonymous(self):\\\n\\\n return False\\\n\\\n\\\n\\\n def get_id(self):\\\n\\\n return self.id\\\n\\\n\\\n\\\n@app.route('/login', methods=['GET', 'POST'])\\\n\\\ndef login():\\\n\\\n if request.method == 'POST':\\\n\\\n username = request.form['username']\\\n\\\n password = request.form['password']\\\n\\\n user = users.get(username)\\\n\\\n if user and check_password_hash(user['password'], password):\\\n\\\n user_obj = User(username)\\\n\\\n session['user_id'] = user_obj.get_id()\\\n\\\n return redirect('/user')\\\n\\\n return abort(401)\\\n\\\n return\"'\\\n\\\n <form method="post">\\\n\\\n Username: <input type="text" name="username"><br>\\\n\\\n Password: <input type="password" name="password"><br>\\\n\\\n <input type="submit" value="Login">\\\n\\\n </form>\\\n\\\n \"'\\\n\\\n\\\n\\\n@app.route('/logout')\\\n\\\ndef logout():\\\n\\\n session.pop('user_id', None)\\\n\\\n return redirect('/login')\\\n\\\n\\\n\\\n@app.route('/user')\\\n\\\n@login_required\\\n\\\ndef user_page():\\\n\\\n if current_user.role == 'admin':\\\n\\\n return redirect('/admin')\\\n\\\n return 'Welcome User!'\\\n\\\n\\\n\\\n@app.route('/admin')\\\n\\\n@login_required\\\n\\\ndef admin_page():\\\n\\\n if current_user.role != 'admin':\\\n\\\n return abort(403)\\\n\\\n return 'Welcome Admin!'\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run(ssl_context='adhoc') # Use adhoc SSL context for demonstration purposes 

(!) VULN CODE [ 1.0 s ] , Injection : from flask import Flask, request, redirect, render_template, session, url_for, flash\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, PasswordField\\\n\\\nfrom wtforms.validators import DataRequired\\\n\\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\\n\\\nimport os\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.secret_key = os.urandom(24)\\\n\\\n\\\n\\\n# Rate limiting setup\\\n\\\nlimiter = Limiter(\\\n\\\n app,\\\n\\\n key_func=get_remote_address,\\\n\\\n default_limits=["5 per minute"]\\\n\\\n)\\\n\\\n\\\n\\\n# CSRF protection is enabled by default in Flask-WTF\\\n\\\nclass LoginForm(FlaskForm):\\\n\\\n username = StringField('Username', validators=[DataRequired()])\\\n\\\n password = PasswordField('Password', validators=[DataRequired()])\\\n\\\n\\\n\\\n# Dummy database of users\\\n\\\nusers_db = {\\\n\\\n "user1": generate_password_hash("password1")\\\n\\\n}\\\n\\\n\\\n\\\n@app.route('/login', methods=['GET'])\\\n\\\ndef login():\\\n\\\n form = LoginForm()\\\n\\\n return render_template('login.html', form=form)\\\n\\\n\\\n\\\n@app.route('/do_login', methods=['POST'])\\\n\\\n@limiter.limit("5 per minute") # Rate limiting for login attempts\\\n\\\ndef do_login():\\\n\\\n form = LoginForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n username = form.username.data\\\n\\\n password = form.password.data\\\n\\\n user_hash = users_db.get(username)\\\n\\\n if user_hash and check_password_hash(user_hash, password):\\\n\\\n session['username'] = username # Session management\\\n\\\n return redirect(url_for('user_page'))\\\n\\\n else:\\\n\\\n flash('Invalid username or password')\\\n\\\n return redirect(url_for('login'))\\\n\\\n return 'Invalid input', 400\\\n\\\n\\\n\\\n@app.route('/user_page')\\\n\\\ndef user_page():\\\n\\\n if 'username' in session:\\\n\\\n return f"Welcome {session['username']}!"\\\n\\\n return redirect(url_for('login'))\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run(ssl_context='adhoc') # HTTPS 

==> SAFE CODE [ 0 s ] : from flask import Flask, request, redirect, session, render_template, url_for\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, PasswordField\\\n\\\nfrom wtforms.validators import InputRequired\\\n\\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nfrom flask_talisman import Talisman\\\n\\\nfrom flask_wtf.csrf import CSRFProtect\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SECRET_KEY'] = 'your_secret_key'\\\n\\\nTalisman(app)\\\n\\\nCSRFProtect(app)\\\n\\\nlimiter = Limiter(app, key_func=get_remote_address)\\\n\\\n\\\n\\\n# Define forms for input validation\\\n\\\nclass LoginForm(FlaskForm):\\\n\\\n username = StringField('Username', validators=[InputRequired()])\\\n\\\n password = PasswordField('Password', validators=[InputRequired()])\\\n\\\n\\\n\\\n# Login page (GET request)\\\n\\\n@app.route('/login', methods=['GET'])\\\n\\\ndef login():\\\n\\\n form = LoginForm()\\\n\\\n return render_template('login.html', form=form)\\\n\\\n\\\n\\\n# Do login (POST request)\\\n\\\n@app.route('/do_login', methods=['POST'])\\\n\\\ndef do_login():\\\n\\\n form = LoginForm(request.form)\\\n\\\n if form.validate():\\\n\\\n # Here you would check the username and password against the database\\\n\\\n # and set session variables accordingly\\\n\\\n pass\\\n\\\n return redirect(url_for('index'))\\\n\\\n\\\n\\\n# Index page\\\n\\\n@app.route('/')\\\n\\\ndef index():\\\n\\\n return 'Index Page'\\\n\\\n\\\n\\\n# User page\\\n\\\n@app.route('/user')\\\n\\\ndef user_page():\\\n\\\n # Access control logic here\\\n\\\n return 'User Page'\\\n\\\n\\\n\\\n# Admin page\\\n\\\n@app.route('/admin')\\\n\\\ndef admin_page():\\\n\\\n # Access control logic here\\\n\\\n return 'Admin Page'\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run(ssl_context='adhoc') 

==> SAFE CODE [ 1.0 s ] : from flask import Flask, request, redirect, url_for, render_template, flash\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, PasswordField, validators\\\n\\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nfrom flask_talisman import Talisman\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\napp.config['SECRET_KEY'] = 'your_secret_key'\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///yourdatabase.db'\\\n\\\ndb = SQLAlchemy(app)\\\n\\\nlogin_manager = LoginManager(app)\\\n\\\nlimiter = Limiter(app, key_func=get_remote_address)\\\n\\\nTalisman(app)\\\n\\\n\\\n\\\nclass User(UserMixin, db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n email = db.Column(db.String(100), unique=True, nullable=False)\\\n\\\n password_hash = db.Column(db.String(200), nullable=False)\\\n\\\n\\\n\\\n@login_manager.user_loader\\\n\\\ndef load_user(user_id):\\\n\\\n return User.query.get(int(user_id))\\\n\\\n\\\n\\\nclass LoginForm(FlaskForm):\\\n\\\n email = StringField('Email', validators=[validators.DataRequired(), validators.Email()])\\\n\\\n password = PasswordField('Password', validators=[validators.DataRequired()])\\\n\\\n\\\n\\\nclass ChangeEmailForm(FlaskForm):\\\n\\\n old_email = StringField('Old Email', validators=[validators.DataRequired(), validators.Email()])\\\n\\\n new_email = StringField('New Email', validators=[validators.DataRequired(), validators.Email(), validators.NoneOf(message="New email must be different", values=lambda form: [form.old_email.data])])\\\n\\\n password = PasswordField('Confirm Password', validators=[validators.DataRequired()])\\\n\\\n\\\n\\\n# Define routes for login, registration, email change, etc.\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run(ssl_context='adhoc') # For HTTPS, in production use a proper SSL context or a reverse proxy handling HTTPS 

==> SAFE CODE [ 0 s ] : # Python Flask example for a secure login page with email change functionality\\\n\\\n\\\n\\\nfrom flask import Flask, request, session, redirect, url_for, render_template, flash\\\n\\\nfrom flask_wtf import FlaskForm\\\n\\\nfrom wtforms import StringField, PasswordField, SubmitField\\\n\\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\\n\\\nfrom flask_sqlalchemy import SQLAlchemy\\\n\\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user\\\n\\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\\n\\\nimport logging\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nfrom flask_talisman import Talisman\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\n\\\n\\\n# Secure Secret Key\\\n\\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\\n\\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite'\\\n\\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\\n\\\n\\\n\\\n# Initialize Database\\\n\\\ndb = SQLAlchemy(app)\\\n\\\n\\\n\\\n# Initialize Login Manager\\\n\\\nlogin_manager = LoginManager()\\\n\\\nlogin_manager.init_app(app)\\\n\\\nlogin_manager.login_view = 'login'\\\n\\\n\\\n\\\n# Initialize Rate Limiter\\\n\\\nlimiter = Limiter(app, key_func=get_remote_address)\\\n\\\n\\\n\\\n# Initialize Talisman for Secure Headers\\\n\\\nTalisman(app)\\\n\\\n\\\n\\\n# User Model\\\n\\\nclass User(UserMixin, db.Model):\\\n\\\n id = db.Column(db.Integer, primary_key=True)\\\n\\\n email = db.Column(db.String(100), unique=True, nullable=False)\\\n\\\n password_hash = db.Column(db.String(100), nullable=False)\\\n\\\n\\\n\\\n def set_password(self, password):\\\n\\\n self.password_hash = generate_password_hash(password)\\\n\\\n\\\n\\\n def check_password(self, password):\\\n\\\n return check_password_hash(self.password_hash, password)\\\n\\\n\\\n\\\n# User Loader\\\n\\\n@login_manager.user_loader\\\n\\\ndef load_user(user_id):\\\n\\\n return User.query.get(int(user_id))\\\n\\\n\\\n\\\n# Forms\\\n\\\nclass LoginForm(FlaskForm):\\\n\\\n email = StringField('Email', validators=[DataRequired(), Email()])\\\n\\\n password = PasswordField('Password', validators=[DataRequired()])\\\n\\\n submit = SubmitField('Login')\\\n\\\n\\\n\\\nclass ChangeEmailForm(FlaskForm):\\\n\\\n old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\\n\\\n new_email = StringField('New Email', validators=[DataRequired(), Email()])\\\n\\\n confirm_password = PasswordField('Confirm Password', validators=[DataRequired()])\\\n\\\n submit = SubmitField('Change Email')\\\n\\\n\\\n\\\n# Routes\\\n\\\n@app.route('/login', methods=['GET', 'POST'])\\\n\\\n@limiter.limit("5/minute")\\\n\\\ndef login():\\\n\\\n form = LoginForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n user = User.query.filter_by(email=form.email.data).first()\\\n\\\n if user and user.check_password(form.password.data):\\\n\\\n login_user(user)\\\n\\\n return redirect(url_for('change_email'))\\\n\\\n else:\\\n\\\n flash('Invalid email or password')\\\n\\\n return render_template('login.html', form=form)\\\n\\\n\\\n\\\n@app.route('/change_email', methods=['GET', 'POST'])\\\n\\\n@login_required\\\n\\\n@limiter.limit("5/minute")\\\n\\\ndef change_email():\\\n\\\n form = ChangeEmailForm()\\\n\\\n if form.validate_on_submit():\\\n\\\n user = User.query.filter_by(email=form.old_email.data).first()\\\n\\\n if user and user.check_password(form.confirm_password.data):\\\n\\\n user.email = form.new_email.data\\\n\\\n db.session.commit()\\\n\\\n flash('Your email has been updated.')\\\n\\\n return redirect(url_for('login'))\\\n\\\n else:\\\n\\\n flash('Invalid email or password.')\\\n\\\n return render_template('change_email.html', form=form)\\\n\\\n\\\n\\\n@app.route('/logout')\\\n\\\n@login_required\\\n\\\ndef logout():\\\n\\\n logout_user()\\\n\\\n return redirect(url_for('login'))\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n logging.basicConfig(filename='app.log', level=logging.DEBUG)\\\n\\\n app.run( ) 

==> SAFE CODE [ 1.0 s ] : from flask import Flask, request, session\\\n\\\nfrom flask_bcrypt import Bcrypt\\\n\\\nfrom flask_limiter import Limiter\\\n\\\nfrom flask_limiter.util import get_remote_address\\\n\\\nimport re\\\n\\\n\\\n\\\napp = Flask(__name__)\\\n\\\nbcrypt = Bcrypt(app)\\\n\\\nlimiter = Limiter(app, key_func=get_remote_address)\\\n\\\n\\\n\\\napp.secret_key = 'your_secret_key' # Change this to a random secret key\\\n\\\nusers = {} # This should be replaced with a database in a real application\\\n\\\n\\\n\\\n@app.route('/signup', methods=['POST'])\\\n\\\ndef signup():\\\n\\\n email = request.form['email']\\\n\\\n password = request.form['password']\\\n\\\n if not re.match(r"[^@]+@[^@]+\.[^@]+", email):\\\n\\\n return "Invalid email format", 400\\\n\\\n hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')\\\n\\\n users[email] = hashed_password\\\n\\\n return "Signup successful", 200\\\n\\\n\\\n\\\n@app.route('/login', methods=['POST'])\\\n\\\ndef login():\\\n\\\n email = request.form['email']\\\n\\\n password = request.form['password']\\\n\\\n hashed_password = users.get(email)\\\n\\\n if hashed_password and bcrypt.check_password_hash(hashed_password, password):\\\n\\\n session['user'] = email\\\n\\\n return "Login successful", 200\\\n\\\n else:\\\n\\\n return "Invalid credentials", 401\\\n\\\n\\\n\\\n@app.route('/change_email', methods=['POST'])\\\n\\\n@limiter.limit("5 per minute")\\\n\\\ndef change_email():\\\n\\\n if 'user' not in session:\\\n\\\n return "Unauthorized", 401\\\n\\\n old_email = request.form['old_email']\\\n\\\n new_email = request.form['new_email']\\\n\\\n password = request.form['password']\\\n\\\n if old_email != session['user'] or not bcrypt.check_password_hash(users[old_email], password):\\\n\\\n return "Invalid credentials", 401\\\n\\\n if not re.match(r"[^@]+@[^@]+\.[^@]+", new_email):\\\n\\\n return "Invalid new email format", 400\\\n\\\n users[new_email] = users.pop(old_email)\\\n\\\n session['user'] = new_email\\\n\\\n return "Email changed successfully", 200\\\n\\\n\\\n\\\nif __name__ == '__main__':\\\n\\\n app.run( ) 





=================>          DATASET SIZE         <=================

#DimTestSet: 7 



=================>    FINAL RESULTS DETECTION    <=================

#TotalVulnerabilities: 2 

#SafeCode: 5 

Vulnerability Rate: 28,5714 % 



=================>        OWASP CATEGORIES       <=================

#Injection: 2 

#Cryptographic Failures: 0 

#Security Misconfiguration: 0 

#Broken Access Control: 0 

#Identification and Authentication Failures: 0 

#Security Logging and Monitoring Failures: 0 

#Insecure Design: 1 

#SSRF: 0 

#Software and Data Integrity Failures: 0 



=================>        EXECUTION TIME        <=================

Runtime: 5.0 s 

Average runtime per snippet: 0,714286 s 

