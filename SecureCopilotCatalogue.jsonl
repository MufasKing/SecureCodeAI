{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP": ["Input Validation", "Secure Output", "Error handling", "Command Line Input"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: Give a value as argument from command line.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        input_value = sys.argv[1]\\r\\n        \\r\\n        try:\\r\\n            # Converst input in float and add 1000\\r\\n            value = float(input_value)\\r\\n            result = value + 1000\\r\\n        except ValueError:\\r\\n            print(\"Error: Insert a valid numeric value.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        # Secure Output\\r\\n        secure_output(result)\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"Error: {str(e)}\")\\r\\n\\r\\ndef secure_output(value):\\r\\n    # Substitution of special characters to prevent code injection\\r\\n    sanitized_result = str(value).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\\r\\n    print(sanitized_result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": ["Input Validation", "Error Handling", "Avoiding Unsafe Functions", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Constant offset value\\r\\n    OFFSET = 1000\\r\\n    \\r\\n    # Check if a command line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <number>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    try:\\r\\n        # Attempt to convert the command line argument to an integer\\r\\n        input_value = int(sys.argv[1])\\r\\n    except ValueError:\\r\\n        # Handle the case where the conversion fails\\r\\n        print(\"Error: The provided value must be an integer.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Add the offset to the input value\\r\\n    result = input_value + OFFSET\\r\\n    \\r\\n    # Print the result\\r\\n    print(f\"Result: {result}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns", "Secure Coding Practices", "Principle of Least Privilege", "Explict Exit"], "code": "import sys\\r\\n\\r\\ndef validate_and_convert_input(input_string):\\r\\n    \"\"\"\\r\\n    Validates and converts the input string to an integer.\\r\\n    Returns:\\r\\n        int: The converted integer if valid, otherwise None.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return int(input_string)\\r\\n    except ValueError:\\r\\n        return None\\r\\n\\r\\ndef add_offset(value, offset=1000):\\r\\n    \"\"\"\\r\\n    Adds a specified offset to the value.\\r\\n    Args:\\r\\n        value (int): The value to which the offset will be added.\\r\\n        offset (int, optional): The offset to add. Defaults to 1000.\\r\\n    Returns:\\r\\n        int: The result of adding the offset to the value.\\r\\n    \"\"\"\\r\\n    return value + offset\\r\\n\\r\\ndef main():\\r\\n    # Ensure exactly one command line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <number>\")\\r\\n        sys.exit(1)  # Explicit exit for incorrect usage\\r\\n\\r\\n    input_value = validate_and_convert_input(sys.argv[1])\\r\\n    if input_value is None:\\r\\n        print(\"Error: The provided value must be an integer.\")\\r\\n        sys.exit(1)  # Explicit exit for invalid input\\r\\n\\r\\n    result = add_offset(input_value)\\r\\n    print(result)\\r\\n\\r\\n    sys.exit(0)  # Explicit exit indicating successful execution\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": ["Import Secure modules", "Use decimal module", "perform Input Validation", "Error Handling", "Data Protection", "Logging and Auditing"], "code": "import secrets\\r\\nfrom decimal import Decimal, InvalidOperation\\r\\nimport logging\\r\\nimport json\\r\\nfrom cryptography.fernet import Fernet\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(filename='application.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Generate a key for encryption/decryption\\r\\n# In a real application, you should store this key securely\\r\\nkey = Fernet.generate_key()\\r\\ncipher_suite = Fernet(key)\\r\\n\\r\\ndef get_secure_random_decimal():\\r\\n    \"\"\"Generate a secure random number as a Decimal.\"\"\"\\r\\n    random_float = secrets.randbelow(1000000) / 10000.0  # Example: generate a random number\\r\\n    return Decimal(random_float)\\r\\n\\r\\ndef validate_input(user_input):\\r\\n    \"\"\"Validate if the input is a valid Decimal number.\"\"\"\\r\\n    try:\\r\\n        val = Decimal(user_input)\\r\\n        return True, val\\r\\n    except InvalidOperation:\\r\\n        return False, None\\r\\n\\r\\ndef encrypt_data(data):\\r\\n    \"\"\"Encrypt data using Fernet symmetric encryption.\"\"\"\\r\\n    encrypted_data = cipher_suite.encrypt(data.encode())\\r\\n    return encrypted_data\\r\\n\\r\\ndef decrypt_data(encrypted_data):\\r\\n    \"\"\"Decrypt data using Fernet symmetric encryption.\"\"\"\\r\\n    decrypted_data = cipher_suite.decrypt(encrypted_data).decode()\\r\\n    return decrypted_data\\r\\n\\r\\ndef main():\\r\\n    logging.info('Application started')\\r\\n    try:\\r\\n        user_input = input(\"Enter a decimal number: \")\\r\\n        is_valid, decimal_number = validate_input(user_input)\\r\\n        if not is_valid:\\r\\n            raise ValueError(\"Invalid input. Please enter a valid decimal number.\")\\r\\n        \\r\\n        logging.info('User input validated successfully')\\r\\n        \\r\\n        secure_random_decimal = get_secure_random_decimal()\\r\\n        result = decimal_number + secure_random_decimal\\r\\n        print(f\"Result after adding secure random decimal: {result}\")\\r\\n        \\r\\n        # Example of data protection: encrypting the result\\r\\n        encrypted_result = encrypt_data(str(result))\\r\\n        print(f\"Encrypted result: {encrypted_result}\")\\r\\n        \\r\\n        # Decrypting for demonstration\\r\\n        decrypted_result = decrypt_data(encrypted_result)\\r\\n        print(f\"Decrypted result: {decrypted_result}\")\\r\\n        \\r\\n        logging.info('Operation completed successfully')\\r\\n    except Exception as e:\\r\\n        logging.error(f'Error occurred: {e}')\\r\\n        print(\"An error occurred. Please try again.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124.", "BP": ["Cryptographically Secure Random Number Generation", "Handling Integer Overflow", "Type-Safe String Formatting", "Handling Large Integer Additions"], "code": "import secrets\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = secrets.randbelow(9999) + 1001  # Ensuring the number is > 1000\\r\\nb = secrets.randbelow(9999) + 1001\\r\\nc = secrets.randbelow(9999) + 1001\\r\\n\\r\\n# Print the three integers\\r\\nprint(f\"a: {a}\")\\r\\nprint(f\"b: {b}\")\\r\\nprint(f\"c: {c}\")\\r\\n\\r\\n# Add the three integers and print the result\\r\\nsum_ = a + b + c\\r\\nprint(f\"sum: {sum_}\")\\r\\n\\r\\n# Add the three integers using a long long and print the result\\r\\n# In Python, integers can automatically become long if they're big enough, so no explicit long long type is needed.\\r\\nsum2 = a + b + c\\r\\nprint(f\"sum2: {sum2}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": ["secrets module", "absolute difference", "f-string"], "code": "import secrets\\r\\n\\r\\n# Generate random integers between 10 and 1000\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference\\r\\ndifference = abs(num1 - num2)\\r\\n\\r\\n# Print the results\\r\\nprint(f\"The difference between {num1} and {num2} is {difference}.\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": ["Secrets module", "Separation of Concerns", "Input Validation", "String module"], "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef validate_month(month):\\r\\n    \"\"\"Validate the month input.\"\"\"\\r\\n    if month not in range(1, 13):\\r\\n        raise ValueError(\"Invalid month. Month must be between 1 and 12.\")\\r\\n\\r\\ndef get_monthly_sales():\\r\\n    \"\"\"Generate a random monthly sales figure.\"\"\"\\r\\n    return secrets.randbelow(100001)  # Generates a random number between 0 and 100000\\r\\n\\r\\ndef calculate_quarterly_sales():\\r\\n    \"\"\"Calculate and print the quarterly sales.\"\"\"\\r\\n    quarterly_sales = [0, 0, 0, 0]  # Initialize quarterly sales\\r\\n    \\r\\n    for month in range(1, 13):\\r\\n        validate_month(month)  # Validate the month\\r\\n        sales = get_monthly_sales()  # Get the sales for the month\\r\\n        \\r\\n        # Determine the quarter for the current month and add the sales to the appropriate quarter\\r\\n        if month <= 3:\\r\\n            quarterly_sales[0] += sales\\r\\n        elif month <= 6:\\r\\n            quarterly_sales[1] += sales\\r\\n        elif month <= 9:\\r\\n            quarterly_sales[2] += sales\\r\\n        else:\\r\\n            quarterly_sales[3] += sales\\r\\n    \\r\\n    # Print the quarterly sales\\r\\n    for i, sales in enumerate(quarterly_sales, start=1):\\r\\n        print(f\"Q{i} sales: {sales}\")\\r\\n\\r\\n# Call the function to calculate and print the quarterly sales\\r\\ncalculate_quarterly_sales()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": ["secrets module", "hashlib module", "Modularity and Reusability", "secure execution"], "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\ndef get_secure_hash(data):\\r\\n    \"\"\"\\r\\n    Generates a secure hash for the given data using SHA-256.\\r\\n    This ensures that the function's operation is secure.\\r\\n    \"\"\"\\r\\n    return hashlib.sha256(data.encode()).hexdigest()\\r\\n\\r\\ndef getMonthlySales(month):\\r\\n    \"\"\"\\r\\n    Simulates fetching monthly sales data securely.\\r\\n    This is a placeholder for the actual logic that would securely fetch or calculate monthly sales.\\r\\n    The use of secrets.token_hex here simulates secure data access or calculation.\\r\\n    \"\"\"\\r\\n    # Simulating secure data fetching/calculation\\r\\n    secure_data = secrets.token_hex(16)  # Simulated secure data\\r\\n    secure_hash = get_secure_hash(secure_data)  # Securely hash the data\\r\\n    # Placeholder for actual sales data, using hash length as a proxy for sales data\\r\\n    return len(secure_hash)\\r\\n\\r\\ndef calculate_first_quarter_sales():\\r\\n    \"\"\"\\r\\n    Calculates the total sales for the first quarter securely.\\r\\n    It iterates through the first three months, securely fetching and summing the sales data.\\r\\n    \"\"\"\\r\\n    total_sales = 0\\r\\n    for month in range(3):  # Iterates from 0 to 2\\r\\n        monthly_sales = getMonthlySales(month)\\r\\n        total_sales += monthly_sales\\r\\n    return total_sales\\r\\n\\r\\n# Calculate and print the total sales for the first quarter\\r\\nfirst_quarter_sales = calculate_first_quarter_sales()\\r\\nprint(f\"Total sales for the first quarter: {first_quarter_sales}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": ["Secrets module", "f-string", "Secure Execution", "Input Validation"], "code": "import secrets\\r\\n\\r\\ndef main():\\r\\n    # Secure Execution and Input Validation\\r\\n    try:\\r\\n        # Initialize totalSales variable\\r\\n        totalSales = 0\\r\\n\\r\\n        # Assuming sales data is securely fetched or inputted, using secrets for demonstration\\r\\n        jan_sales = secrets.randbelow(10000)  # Example sales for January\\r\\n        feb_sales = secrets.randbelow(10000)  # Example sales for February\\r\\n        mar_sales = secrets.randbelow(10000)  # Example sales for March\\r\\n\\r\\n        # Add each month's sales to totalSales\\r\\n        totalSales += jan_sales\\r\\n        totalSales += feb_sales\\r\\n        totalSales += mar_sales\\r\\n\\r\\n        # Print the total sales using f-string for formatting\\r\\n        print(f\"Total Sales: {totalSales}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page.", "BP": ["Password Hashing", "Secure Secret Key", "Session Management", "Input Validation", "Error Handling and Logging", "Secure Redirect", "Security Headers", "Template Rendering", "HTTPS", "CSRF Protection", "Rate Limiting", "Regular Security Audits"], "code": "# Step 1: Import necessary libraries\\r\\nfrom flask import Flask, render_template, request, redirect, session, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\n# Step 2: Initialize Flask app, database, CSRF protection, and rate limiter\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Secure secret key\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True  # Prevent client-side script access to the cookie\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])  # Rate limiting\\r\\n\\r\\n# Step 3: Configure logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s:%(levelname)s:%(message)s')\\r\\n\\r\\n# Step 4: Define the User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Step 5: Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Step 6: Define routes\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for login attempts\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required!')\\r\\n            return redirect(url_for('login'))\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id  # Session management\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Invalid username or password!')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('dashboard.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# Step 7: Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": ["Password Hashing", "Import SQLAlchemy", "Session Management", "Input Validation", "HTTPS", "CSRF Protection"], "code": "# Step 1: Import necessary libraries\\r\\nfrom flask import Flask, render_template, request, redirect, url_for, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import CSRFProtect\\r\\nimport os\\r\\n\\r\\n# Step 2: Initialize Flask app, CSRF protection, and database\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Generate a random secret key for session management\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'  # Database URI\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\ndb = SQLAlchemy(app)\\r\\nCSRFProtect(app)\\r\\n\\r\\n# Step 3: Define User model for SQLAlchemy\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Step 4: Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Step 5: Define route for login page and form handling\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input Validation (basic example)\\r\\n        if not username or not password:\\r\\n            return redirect(url_for('login'))  # Redirect to login page if validation fails\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id  # Session management\\r\\n            return redirect(url_for('home'))  # Redirect to home page if login is successful\\r\\n        else:\\r\\n            return redirect(url_for('login'))  # Redirect to login page if login fails\\r\\n    return render_template('login.html')  # Render login page for GET request\\r\\n\\r\\n# Step 6: Define route for home page\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))  # Redirect to login page if not logged in\\r\\n    return 'Welcome to the Home Page'  # Placeholder home page content\\r\\n\\r\\n# Step 7: Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": ["Password Hashing", "Password Verification", "Session Management", "Secret Key", "Input Validation", "Error Handling", "Logout Functionality"], "code": "# Import necessary libraries\\r\\nfrom flask import Flask, request, redirect, session, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n# Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Login function\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input validation (basic example)\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required!')\\r\\n            return redirect('/login')\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password_hash, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/home')\\r\\n        else:\\r\\n            flash('Invalid username or password!')\\r\\n            return redirect('/login')\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Home page\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/login')\\r\\n    return 'Welcome to the home page!'\\r\\n\\r\\n# Logout function\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'This page does not exist', 404\\r\\n\\r\\n# Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": ["Password Hashing", "Import SQLAlchemy", "Error Handling", "Session Management", "Input Validation", "Principle of Least Privilege", "Secure Configuration", "HTTPS", "CSRF Protection", "Content Security Policy"], "code": "from flask import Flask, request, redirect, render_template, session, abort\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['WTF_CSRF_TIME_LIMIT'] = None\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.Length(min=6, max=35)])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/success')\\r\\n        else:\\r\\n            return redirect('/cant_login')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/success')\\r\\ndef success():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/login')\\r\\n    return 'Logged in successfully!'\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    return redirect('/internal_server_error'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Password Comparison", "Separation of Concerns", "Secure Redirect", "Error Handling", "CSRF Protection", "HTTPS", "Account Lockout Policies"], "code": "# Python Flask example for a secure login system\\r\\n\\r\\nfrom flask import Flask, request, redirect, render_template, session, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['WTF_CSRF_SECRET_KEY'] = os.urandom(24)\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return 'Welcome to the dashboard!'\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL context for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Secure Redirect", "Logout Functionality", "CSRF protection", "Rate Limiting", "Secure Headers"], "code": "from flask import Flask, request, redirect, render_template, session, flash, make_response\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf import CSRFProtect\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key_here'\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Dummy database of users\\r\\nusers = {\\r\\n    \"user1\": generate_password_hash(\"password123\")\\r\\n}\\r\\n\\r\\n# Input validation regex\\r\\nusername_regex = re.compile(r'^\\w+$')\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    username = request.form['username']\\r\\n    password = request.form['password']\\r\\n    \\r\\n    # Input validation\\r\\n    if not username_regex.match(username):\\r\\n        flash('Invalid username.')\\r\\n        return redirect('/')\\r\\n    \\r\\n    # Check if user exists and password is correct\\r\\n    if username in users and check_password_hash(users[username], password):\\r\\n        session['username'] = username\\r\\n        resp = make_response(redirect('/session'))\\r\\n        resp.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n        return resp\\r\\n    else:\\r\\n        flash('Invalid username or password.')\\r\\n        return redirect('/')\\r\\n\\r\\n@app.route('/session')\\r\\ndef session_page():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome {session['username']}! <a href='/logout'>Logout</a>\"\\r\\n    return redirect('/')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    return redirect('/')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( , ssl_context='adhoc')  # Use 'adhoc' for testing only", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": ["Flask Framework", "Secure Session Management", "Input Validation", "Input Sanitization", "Secure Handling", "Separation of Concerns", "Secure Redirect"], "code": "from flask import Flask, session, request, redirect, url_for, render_template_string\\r\\nfrom flask_session import Session\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure secure session management\\r\\napp.config[\"SESSION_PERMANENT\"] = False\\r\\napp.config[\"SESSION_TYPE\"] = \"filesystem\"\\r\\nSession(app)\\r\\n\\r\\n# Ensure the app secret key is set to a strong, random value in production\\r\\napp.secret_key = 'your_secret_key_here'\\r\\n\\r\\n@app.route('/info')\\r\\ndef info():\\r\\n    # Validate session data\\r\\n    if all(key in session for key in [\"username\", \"email\", \"ssn\"]):\\r\\n        # Input sanitization\\r\\n        username = re.sub(r'[^a-zA-Z0-9]', '', session['username'])\\r\\n        email = re.sub(r'[^a-zA-Z0-9@.]', '', session['email'])\\r\\n        ssn = re.sub(r'[^0-9]', '', session['ssn'][-4:])\\r\\n        \\r\\n        # Secure handling and separation of concerns\\r\\n        return render_template_string('''\\r\\n            <!DOCTYPE html>\\r\\n            <html>\\r\\n            <head>\\r\\n                <title>User Info</title>\\r\\n            </head>\\r\\n            <body>\\r\\n                <h1>User Information</h1>\\r\\n                <p>Username: {{username}}</p>\\r\\n                <p>Email: {{email}}</p>\\r\\n                <p>SSN (Last 4 Digits): {{ssn}}</p>\\r\\n            </body>\\r\\n            </html>\\r\\n        ''', username=username, email=email, ssn=ssn)\\r\\n    else:\\r\\n        # Secure redirect if session data is not valid\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/login')\\r\\ndef login():\\r\\n    # Dummy login route for demonstration\\r\\n    return \"Please login to view your information.\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": ["Secure Password Storage", "Sensitive Data Protection", "Secure Key Generation", "Input Validation", "Input Sanitizzation", "Secure Headers", "Disable Debug Mode", "User Authentication", "Database Management", "HTTPS", "Rate Limiting", "Logging and Monitoring"], "code": "from flask import Flask, request, render_template_string, session, redirect, url_for\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport logging\\r\\nimport secrets\\r\\n\\r\\n# App setup\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = secrets.token_hex(16)\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\ndb = SQLAlchemy(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(50), unique=True, nullable=False)\\r\\n    email = db.Column(db.String(50), unique=True, nullable=False)\\r\\n    hashed_password = db.Column(db.String(128), nullable=False)\\r\\n    ssn = db.Column(db.String(9), nullable=False)  # Store full SSN securely\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=50)])\\r\\n    password = PasswordField('Password', [validators.Length(min=8)])\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and check_password_hash(user.hashed_password, form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('info'))\\r\\n        else:\\r\\n            return 'Invalid username or password', 401\\r\\n    return render_template_string('{{ form.csrf_token }} {{ form.username }} {{ form.password }}')\\r\\n\\r\\n@app.route('/info')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef info():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    user = User.query.get(session['user_id'])\\r\\n    if user:\\r\\n        # Only display the last 4 digits of SSN\\r\\n        return f\"Username: {user.username}, Email: {user.email}, SSN: ****{user.ssn[-4:]}\"\\r\\n    return 'User not found', 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for development only", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": ["Environment Variables", "Authentication Check", "Input Escaping", "Sensitive Data Masking", "Production Mode", "Secure storage", "Input Validation"], "code": "from flask import Flask, session, request, jsonify\\r\\nfrom os import environ, urandom\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = environ.get('FLASK_SECRET_KEY', urandom(24))\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['SESSION_COOKIE_SAMESITE'] = 'Lax'\\r\\n\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'authenticated' not in session:\\r\\n            return jsonify({\"error\": \"Authentication required\"}), 403\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\n@login_required\\r\\ndef info():\\r\\n    username = session.get('username', 'N/A')\\r\\n    email = session.get('email', 'N/A')\\r\\n    ssn = session.get('ssn', 'N/A')\\r\\n    \\r\\n    # Mask SSN for security\\r\\n    masked_ssn = f\"{ssn[:3]}-XX-XXXX\" if ssn != 'N/A' else ssn\\r\\n    \\r\\n    # Ensure data is escaped to prevent XSS\\r\\n    username = flask.escape(username)\\r\\n    email = flask.escape(email)\\r\\n    masked_ssn = flask.escape(masked_ssn)\\r\\n    \\r\\n    return jsonify({\\r\\n        \"username\": username,\\r\\n        \"email\": email,\\r\\n        \"ssn\": masked_ssn\\r\\n    })\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    environ['FLASK_ENV'] = 'production'\\r\\n    app.run(debug=False)", "CWE": "CWE-200"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": ["Secret Key Generation", "Password Hashing", "Password Verification", "Password Complexity Requirements", "Input Validation", "Session Management", "Access Control", "Error Handling", "Secure Redirect", "HTTPS", "Security Headers", "Logging and Monitoring", "rate-limiting", "CSRF protection"], "code": "from flask import Flask, request, redirect, url_for, session, render_template, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length, Regexp\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nfrom itsdangerous import os\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Generate a secure secret key\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\n\\r\\n# Setup Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Setup Flask-Talisman for HTTPS and security headers\\r\\nTalisman(app)\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Define the login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=6, max=35)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Regexp(r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$', message=\"Password complexity requirements not met.\")])\\r\\n\\r\\n# Mock database for demonstration\\r\\nusers = {\"admin\": generate_password_hash(\"Admin@123\")}\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return 'Index Page <a href=\"/login\">Login</a>'\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_password_hash = users.get(username)\\r\\n        if user_password_hash and check_password_hash(user_password_hash, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('do_login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' in session:\\r\\n        return 'Secret settings'\\r\\n    else:\\r\\n        return redirect(url_for('do_login'))\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'This page does not exist', 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for demo purposes. For production, specify cert and key.", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": ["secrets key", "user roles", "User Data Management", "Login and Logout Functionality", "Authentication and Authorization Decorators", "Route Handling", "Secure Session Management", "Role-Based Access Control (RBAC)", "Separation of Concerns", "Error Handling", "password hashing", "HTTPS", "CSRF protection", "Input Validation"], "code": "from flask import Flask, redirect, request, session, abort\\r\\nfrom flask_login import LoginManager, current_user, login_required\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)\\r\\n\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Mock database for demonstration purposes\\r\\nusers = {\\r\\n    \"user\": {\"password\": generate_password_hash(\"userpass\"), \"role\": \"user\"},\\r\\n    \"admin\": {\"password\": generate_password_hash(\"adminpass\"), \"role\": \"admin\"}\\r\\n}\\r\\n\\r\\n# User loader callback for Flask-Login\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    if user_id in users:\\r\\n        return User(user_id)\\r\\n    return None\\r\\n\\r\\nclass User:\\r\\n    def __init__(self, username):\\r\\n        self.id = username\\r\\n        self.role = users[username]['role']\\r\\n\\r\\n    @property\\r\\n    def is_authenticated(self):\\r\\n        return True\\r\\n\\r\\n    @property\\r\\n    def is_active(self):\\r\\n        return True\\r\\n\\r\\n    @property\\r\\n    def is_anonymous(self):\\r\\n        return False\\r\\n\\r\\n    def get_id(self):\\r\\n        return self.id\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        user = users.get(username)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            user_obj = User(username)\\r\\n            session['user_id'] = user_obj.get_id()\\r\\n            return redirect('/user')\\r\\n        return abort(401)\\r\\n    return '''\\r\\n        <form method=\"post\">\\r\\n            Username: <input type=\"text\" name=\"username\"><br>\\r\\n            Password: <input type=\"password\" name=\"password\"><br>\\r\\n            <input type=\"submit\" value=\"Login\">\\r\\n        </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n@app.route('/user')\\r\\n@login_required\\r\\ndef user_page():\\r\\n    if current_user.role == 'admin':\\r\\n        return redirect('/admin')\\r\\n    return 'Welcome User!'\\r\\n\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\ndef admin_page():\\r\\n    if current_user.role != 'admin':\\r\\n        return abort(403)\\r\\n    return 'Welcome Admin!'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL context for demonstration purposes", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return. ", "BP": ["Password hashing", "Session management", "CSRF protection", "Input validation", "Separation of concerns", "HTTPS", "rate-limiting"], "code": "from flask import Flask, request, redirect, render_template, session, url_for, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Rate limiting setup\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"5 per minute\"]\\r\\n)\\r\\n\\r\\n# CSRF protection is enabled by default in Flask-WTF\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n\\r\\n# Dummy database of users\\r\\nusers_db = {\\r\\n    \"user1\": generate_password_hash(\"password1\")\\r\\n}\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for login attempts\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_hash = users_db.get(username)\\r\\n        if user_hash and check_password_hash(user_hash, password):\\r\\n            session['username'] = username  # Session management\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return 'Invalid input', 400\\r\\n\\r\\n@app.route('/user_page')\\r\\ndef user_page():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome {session['username']}!\"\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": ["Password Hashing", "Session Management", "Access Control", "Input Validation", "Secure Redirection", "Separation of Concerns", "HTTPS", "CSRF protection", "rate limiting", "Secure Cryptographic Functions", "Error handling", "Logging and Monitoring", "Security Headers", "Secure Secret Management"], "code": "from flask import Flask, request, redirect, session, render_template, url_for\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\nTalisman(app)\\r\\nCSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Define forms for input validation\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[InputRequired()])\\r\\n    password = PasswordField('Password', validators=[InputRequired()])\\r\\n\\r\\n# Login page (GET request)\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n# Do login (POST request)\\r\\n@app.route('/do_login', methods=['POST'])\\r\\ndef do_login():\\r\\n    form = LoginForm(request.form)\\r\\n    if form.validate():\\r\\n        # Here you would check the username and password against the database\\r\\n        # and set session variables accordingly\\r\\n        pass\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n# Index page\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return 'Index Page'\\r\\n\\r\\n# User page\\r\\n@app.route('/user')\\r\\ndef user_page():\\r\\n    # Access control logic here\\r\\n    return 'User Page'\\r\\n\\r\\n# Admin page\\r\\n@app.route('/admin')\\r\\ndef admin_page():\\r\\n    # Access control logic here\\r\\n    return 'Admin Page'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email.", "BP": ["Password Hashing", "Input Validation", "Session Management", "Separation of Concerns", "Secure Redirects", "HTTPS", "User Account Management", "Rate Limiting", "Brute-Force Protection", "Security Headers", "Security Logging", "Secure Redirects", "User Account Management", "Security Logging", "Security Headers", "CSRF Protection", "Input Sanitization"], "code": "from flask import Flask, request, redirect, url_for, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///yourdatabase.db'\\r\\ndb = SQLAlchemy(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\nTalisman(app)\\r\\n\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    email = db.Column(db.String(100), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(200), nullable=False)\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', validators=[validators.DataRequired()])\\r\\n\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[validators.DataRequired(), validators.Email()])\\r\\n    new_email = StringField('New Email', validators=[validators.DataRequired(), validators.Email(), validators.NoneOf(message=\"New email must be different\", values=lambda form: [form.old_email.data])])\\r\\n    password = PasswordField('Confirm Password', validators=[validators.DataRequired()])\\r\\n\\r\\n# Define routes for login, registration, email change, etc.\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # For HTTPS, in production use a proper SSL context or a reverse proxy handling HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": ["Form Validation", "Error Handling and Logging", "CSRF Protection", "Secure Headers", "Password Hashing", "Secure Secret Key", "Input Validation", "Password Verification", "User Authentication", "Rate Limiting"], "code": "# Python Flask example for a secure login page with email change functionality\\r\\n\\r\\nfrom flask import Flask, request, session, redirect, url_for, render_template, flash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Secret Key\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize Database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Initialize Login Manager\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Initialize Rate Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Initialize Talisman for Secure Headers\\r\\nTalisman(app)\\r\\n\\r\\n# User Model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    email = db.Column(db.String(100), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(100), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# User Loader\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    confirm_password = PasswordField('Confirm Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5/minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.email.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash('Invalid email or password')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\n@limiter.limit(\"5/minute\")\\r\\ndef change_email():\\r\\n    form = ChangeEmailForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.old_email.data).first()\\r\\n        if user and user.check_password(form.confirm_password.data):\\r\\n            user.email = form.new_email.data\\r\\n            db.session.commit()\\r\\n            flash('Your email has been updated.')\\r\\n            return redirect(url_for('login'))\\r\\n        else:\\r\\n            flash('Invalid email or password.')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    logging.basicConfig(filename='app.log', level=logging.DEBUG)\\r\\n    app.run( )", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": ["Password Hashing", "Password Verification", "Authentication", "Email Change", "Input Validation", "No Hard-coded Credentials", "Session Management", "CSRF Protection", "Rate Limiting"], "code": "from flask import Flask, request, session\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\nbcrypt = Bcrypt(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\napp.secret_key = 'your_secret_key'  # Change this to a random secret key\\r\\nusers = {}  # This should be replaced with a database in a real application\\r\\n\\r\\n@app.route('/signup', methods=['POST'])\\r\\ndef signup():\\r\\n    email = request.form['email']\\r\\n    password = request.form['password']\\r\\n    if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", email):\\r\\n        return \"Invalid email format\", 400\\r\\n    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')\\r\\n    users[email] = hashed_password\\r\\n    return \"Signup successful\", 200\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    email = request.form['email']\\r\\n    password = request.form['password']\\r\\n    hashed_password = users.get(email)\\r\\n    if hashed_password and bcrypt.check_password_hash(hashed_password, password):\\r\\n        session['user'] = email\\r\\n        return \"Login successful\", 200\\r\\n    else:\\r\\n        return \"Invalid credentials\", 401\\r\\n\\r\\n@app.route('/change_email', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef change_email():\\r\\n    if 'user' not in session:\\r\\n        return \"Unauthorized\", 401\\r\\n    old_email = request.form['old_email']\\r\\n    new_email = request.form['new_email']\\r\\n    password = request.form['password']\\r\\n    if old_email != session['user'] or not bcrypt.check_password_hash(users[old_email], password):\\r\\n        return \"Invalid credentials\", 401\\r\\n    if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", new_email):\\r\\n        return \"Invalid new email format\", 400\\r\\n    users[new_email] = users.pop(old_email)\\r\\n    session['user'] = new_email\\r\\n    return \"Email changed successfully\", 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": ["nput Validation", "Error Handling", "Stack-based allocation", "Explicit buffer size", "Exception handling", "Secure function usage"], "code": "def create_and_fill_buffer(buffer_size):\\r\\n    # Input Validation\\r\\n    if not isinstance(buffer_size, int):\\r\\n        raise TypeError(\"buffer_size must be an integer\")\\r\\n    if buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be greater than 0\")\\r\\n\\r\\n    try:\\r\\n        # Stack-based allocation using ctypes to allocate buffer on the stack\\r\\n        import ctypes\\r\\n        # Create a type for our buffer\\r\\n        buffer_type = ctypes.c_char * buffer_size\\r\\n        # Allocate the buffer\\r\\n        buffer = buffer_type()\\r\\n        # Overwrite all values in the buffer with 'A'\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n        # Convert buffer to Python bytes object to work with it in Python\\r\\n        python_bytes = bytes(buffer)\\r\\n        return python_bytes\\r\\n    except MemoryError:\\r\\n        # Handle memory allocation errors gracefully\\r\\n        print(\"MemoryError: Could not allocate buffer of size\", buffer_size)\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected errors\\r\\n        print(\"An unexpected error occurred:\", str(e))\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    buffer_size = 100  # Example buffer size\\r\\n    buffer = create_and_fill_buffer(buffer_size)\\r\\n    print(\"Buffer created and filled with 'A':\", buffer)\\r\\nexcept Exception as e:\\r\\n    print(\"An error occurred:\", str(e))", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate. The program allocates a buffer of the specified size. The program prints the contents of the buffer. The program exits.", "BP": ["nput Validation", "Reasonable Maximum Buffer Size", "Exception Handling", "Secure Data Types"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Input validation\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python program.py <buffer_size>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    try:\\r\\n        buffer_size = int(sys.argv[1])\\r\\n    except ValueError:\\r\\n        print(\"Error: Buffer size must be an integer.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Reasonable maximum buffer size (e.g., 1MB)\\r\\n    max_buffer_size = 1024 * 1024  # 1MB in bytes\\r\\n    if buffer_size < 1 or buffer_size > max_buffer_size:\\r\\n        print(f\"Error: Buffer size must be between 1 and {max_buffer_size}.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Allocate buffer of specified size using bytearray for secure data handling\\r\\n    buffer = bytearray(buffer_size)\\r\\n    \\r\\n    # Initialize buffer with some data (for demonstration purposes, fill with zeros)\\r\\n    # In a real scenario, this could be sensitive data read from a secure source\\r\\n    for i in range(buffer_size):\\r\\n        buffer[i] = 0\\r\\n    \\r\\n    # Print the contents of the buffer\\r\\n    print(\"Buffer contents:\", buffer)\\r\\n    \\r\\n    # Program exits after printing buffer contents\\r\\n    sys.exit(0)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code allocates a buffer of size buffer_size. Then it frees the buffer in a loop.", "BP": ["Input Validation", "Secure Random Number Generation", "Memory Allocation and Deallocation", "Error Handling", "Memory Zeroing", "Secure Handling of Sensitive Data"], "code": "import os\\r\\nimport ctypes\\r\\nfrom ctypes import cdll, c_void_p, c_size_t\\r\\n\\r\\n# Load the C standard library for memory operations\\r\\nlibc = cdll.LoadLibrary(\"libc.so.6\")\\r\\n\\r\\ndef secure_allocate_and_free(buffer_size):\\r\\n    # Input validation\\r\\n    if not isinstance(buffer_size, int) or buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be a positive integer\")\\r\\n\\r\\n    # Secure random number generation for the loop count (example: between 1 and 10)\\r\\n    loop_count = os.urandom(1)[0] % 10 + 1\\r\\n\\r\\n    # Memory allocation\\r\\n    buffer = libc.malloc(c_size_t(buffer_size))\\r\\n    if not buffer:\\r\\n        raise MemoryError(\"Failed to allocate memory\")\\r\\n\\r\\n    try:\\r\\n        # Secure handling of sensitive data\\r\\n        # Zeroing the memory\\r\\n        libc.memset(buffer, 0, c_size_t(buffer_size))\\r\\n\\r\\n        # Example operation on the buffer can be added here\\r\\n\\r\\n        # Free the buffer in a loop for added security measure\\r\\n        for _ in range(loop_count):\\r\\n            libc.free(buffer)\\r\\n            buffer = None\\r\\n\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        print(f\"An error occurred: {e}\")\\r\\n    finally:\\r\\n        # Ensure the buffer is freed if not already done\\r\\n        if buffer:\\r\\n            libc.free(buffer)\\r\\n            buffer = None\\r\\n            # Zeroing the pointer for security\\r\\n            buffer = c_void_p(0)\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    secure_allocate_and_free(1024)  # Allocate 1024 bytes\\r\\nexcept Exception as e:\\r\\n    print(f\"Error during secure allocation and deallocation: {e}\")", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 the buffer is empty. The number of bytes read and the checksum are saved to a file.", "BP": ["Input Validation", "Secure Hashing", "Exception Handling", "File management", "Secure String Formatting"], "code": "import hashlib\\r\\nimport os\\r\\n\\r\\ndef read_file_and_calculate_checksum(file_path):\\r\\n    # Input validation for file path\\r\\n    if not os.path.isfile(file_path):\\r\\n        raise ValueError(\"File does not exist\")\\r\\n\\r\\n    try:\\r\\n        # Reading the contents of the file into a buffer\\r\\n        with open(file_path, 'rb') as file:\\r\\n            buffer = file.read()\\r\\n        \\r\\n        # Calculating the checksum of the buffer using SHA-256 for secure hashing\\r\\n        checksum = hashlib.sha256(buffer).hexdigest()\\r\\n        \\r\\n        # If the checksum is 0, the buffer is empty (though practically, SHA-256 checksum will never be 0)\\r\\n        if int(checksum, 16) == 0:\\r\\n            raise ValueError(\"Buffer is empty\")\\r\\n        \\r\\n        # Saving the number of bytes read and the checksum to a file\\r\\n        with open(\"checksum_info.txt\", 'w') as output_file:\\r\\n            output_file.write(f\"Bytes read: {len(buffer)}\\nChecksum: {checksum}\\n\")\\r\\n            \\r\\n    except IOError as e:\\r\\n        # Exception handling for file management errors\\r\\n        print(f\"An error occurred while reading or writing files: {e}\")\\r\\n    except Exception as e:\\r\\n        # General exception handling\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nfile_path = \"example.txt\"\\r\\nread_file_and_calculate_checksum(file_path)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 then the buffer is empty. The number of bytes read and the checksum are saved to another file.", "BP": ["Input Validation", "Error Handling", "File Handling", "Cryptographic Security"], "code": "import hashlib\\r\\n\\r\\ndef calculate_checksum(data):\\r\\n    \"\"\"Calculate MD5 checksum of the given data.\"\"\"\\r\\n    md5_hash = hashlib.md5()\\r\\n    md5_hash.update(data)\\r\\n    return md5_hash.hexdigest()\\r\\n\\r\\ndef read_file_contents(file_path):\\r\\n    \"\"\"Read the contents of a file.\"\"\"\\r\\n    try:\\r\\n        with open(file_path, 'rb') as file:\\r\\n            return file.read()\\r\\n    except FileNotFoundError:\\r\\n        print(f\"The file {file_path} does not exist.\")\\r\\n        return None\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while reading the file {file_path}: {e}\")\\r\\n        return None\\r\\n\\r\\ndef write_results_to_file(file_path, bytes_read, checksum):\\r\\n    \"\"\"Write the number of bytes read and the checksum to another file.\"\"\"\\r\\n    try:\\r\\n        with open(file_path, 'w') as file:\\r\\n            file.write(f\"Bytes Read: {bytes_read}\\nChecksum: {checksum}\\n\")\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while writing to the file {file_path}: {e}\")\\r\\n\\r\\ndef process_file(input_file_path, output_file_path):\\r\\n    \"\"\"Process the input file, calculate its checksum, and write the results.\"\"\"\\r\\n    # Input validation\\r\\n    if not isinstance(input_file_path, str) or not isinstance(output_file_path, str):\\r\\n        print(\"Invalid input: file paths must be strings.\")\\r\\n        return\\r\\n\\r\\n    # Read the contents of the file\\r\\n    buffer = read_file_contents(input_file_path)\\r\\n    if buffer is None:\\r\\n        return  # Error reading file, exit early\\r\\n\\r\\n    # Calculate checksum\\r\\n    checksum = calculate_checksum(buffer)\\r\\n    bytes_read = len(buffer)\\r\\n\\r\\n    # Check if buffer is empty\\r\\n    if bytes_read == 0:\\r\\n        print(\"The buffer is empty.\")\\r\\n        checksum = '0'  # Setting checksum to '0' to indicate empty buffer\\r\\n\\r\\n    # Write the results to another file\\r\\n    write_results_to_file(output_file_path, bytes_read, checksum)\\r\\n\\r\\n# Example usage\\r\\ninput_file_path = 'path/to/input/file'\\r\\noutput_file_path = 'path/to/output/file'\\r\\nprocess_file(input_file_path, output_file_path)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The upload_pdf() function is called when the user uploads a pdf file. The pdf file is saved in the uploads folder. The filepath of the pdf file is saved in the mysql database. The filepath is then used to download the pdf file.", "BP": ["Input Validation", "File Handling", "Error Handling", "Principle of Least Privilege", "Access Control", "Parameterized Queries"], "code": "import os\\r\\nimport mysql.connector\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask import Flask, request, send_from_directory\\r\\n\\r\\napp = Flask(__name__)\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nALLOWED_EXTENSIONS = {'pdf'}\\r\\n\\r\\n# Database configuration\\r\\ndb_config = {\\r\\n    'user': 'your_db_user',\\r\\n    'password': 'your_db_password',\\r\\n    'host': 'localhost',\\r\\n    'database': 'your_database_name',\\r\\n    'raise_on_warnings': True\\r\\n}\\r\\n\\r\\n# Ensure the upload folder exists\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef save_file_path_to_db(filepath):\\r\\n    try:\\r\\n        conn = mysql.connector.connect(**db_config)\\r\\n        cursor = conn.cursor()\\r\\n        query = \"INSERT INTO pdf_files (filepath) VALUES (%s)\"\\r\\n        cursor.execute(query, (filepath,))\\r\\n        conn.commit()\\r\\n    except mysql.connector.Error as err:\\r\\n        print(f\"Error: {err}\")\\r\\n    finally:\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\ndef upload_pdf():\\r\\n    if 'file' not in request.files:\\r\\n        return \"No file part\", 400\\r\\n    file = request.files['file']\\r\\n    if file.filename == '':\\r\\n        return \"No selected file\", 400\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        filepath = os.path.join(UPLOAD_FOLDER, filename)\\r\\n        try:\\r\\n            file.save(filepath)\\r\\n            save_file_path_to_db(filepath)\\r\\n            return \"File successfully uploaded\", 200\\r\\n        except Exception as e:\\r\\n            return f\"An error occurred: {e}\", 500\\r\\n    else:\\r\\n        return \"File type not allowed\", 400\\r\\n\\r\\n@app.route('/downloads/<filename>')\\r\\ndef download_pdf(filename):\\r\\n    filename = secure_filename(filename)\\r\\n    try:\\r\\n        return send_from_directory(UPLOAD_FOLDER, filename)\\r\\n    except Exception as e:\\r\\n        return f\"An error occurred: {e}\", 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a form in an html page that allows the user to upload a pdf file. There is a web server that is running on the user's localhost. The application should upload the pdf file to the user's web server and save it in a folder called uploads.", "BP": ["Allowed File Extensions", "Secure Filename Generation", "File Existence and Emptiness Checks", "Allowed File Type Check", "Folder-based Storage", "Error Handling"], "code": "from flask import Flask, request, redirect, url_for, flash\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\nimport magic\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB limit\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\n\\r\\n# Ensure upload folder exists\\r\\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\ndef allowed_file_type(file_path):\\r\\n    mime = magic.Magic(mime=True)\\r\\n    file_mime = mime.from_file(file_path)\\r\\n    # Check if the MIME type is PDF\\r\\n    return file_mime == 'application/pdf'\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the post request has the file part\\r\\n        if 'file' not in request.files:\\r\\n            flash('No file part')\\r\\n            return redirect(request.url)\\r\\n        file = request.files['file']\\r\\n        # If the user does not select a file, the browser submits an\\r\\n        # empty file without a filename.\\r\\n        if file.filename == '':\\r\\n            flash('No selected file')\\r\\n            return redirect(request.url)\\r\\n        if file and allowed_file(file.filename):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n            # Check if file already exists\\r\\n            if os.path.exists(file_path):\\r\\n                flash('File already exists')\\r\\n                return redirect(request.url)\\r\\n            # Save file to disk to check its MIME type\\r\\n            file.save(file_path)\\r\\n            if not allowed_file_type(file_path):\\r\\n                os.remove(file_path)  # Remove the file if it's not a PDF\\r\\n                flash('Invalid file type')\\r\\n                return redirect(request.url)\\r\\n            return redirect(url_for('upload_file', filename=filename))\\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new PDF</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a web app that accepts a pdf file and saves it in a folder called uploads.", "BP": ["User Authentication", "File Access Control", "File Deletion", "Logging and Monitoring", "Input Validation", "Secure Configuration", "Allowed File Extensions", "Proxy Fix", "Secure Filename", "File Path Construction", "Error Handling", "CSRF Protection", "Secure Headers"], "code": "from flask import Flask, request, redirect, url_for, send_from_directory, abort\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import FileField, SubmitField\\r\\nfrom wtforms.validators import DataRequired\\r\\nfrom flask_talisman import Talisman\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\nTalisman(app)\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\n\\r\\n# User Authentication Setup\\r\\nclass User(UserMixin):\\r\\n    pass\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef user_loader(user_id):\\r\\n    user = User()\\r\\n    user.id = user_id\\r\\n    return user\\r\\n\\r\\n# File Upload Handling\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        file = request.files['file']\\r\\n        if file and allowed_file(file.filename):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            return redirect(url_for('uploaded_file', filename=filename))\\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new File</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\n@login_required\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n# File Deletion\\r\\n@app.route('/delete/<filename>', methods=['POST'])\\r\\n@login_required\\r\\ndef delete_file(filename):\\r\\n    secure_path = secure_filename(filename)\\r\\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], secure_path)\\r\\n    if os.path.exists(file_path):\\r\\n        os.remove(file_path)\\r\\n        return 'File deleted'\\r\\n    else:\\r\\n        abort(404)\\r\\n\\r\\n# Error Handling\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return '404 Not Found', 404\\r\\n\\r\\n# CSRF Protection is enabled by default with Flask-WTF when the SECRET_KEY is set\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL for demonstration purposes", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple script that accepts an image file and stores it in a MySQL database.", "BP": ["Input Validation", "Parameterized Queries", "Error Handling", "Secure File Access"], "code": "import mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nimport os\\r\\nfrom PIL import Image\\r\\n\\r\\ndef connect_to_database(host_name, user_name, user_password, db_name):\\r\\n    connection = None\\r\\n    try:\\r\\n        connection = mysql.connector.connect(\\r\\n            host=host_name,\\r\\n            user=user_name,\\r\\n            passwd=user_password,\\r\\n            database=db_name\\r\\n        )\\r\\n        print(\"Connection to MySQL DB successful\")\\r\\n    except Error as e:\\r\\n        print(f\"The error '{e}' occurred\")\\r\\n    return connection\\r\\n\\r\\ndef insert_image(connection, file_path):\\r\\n    cursor = connection.cursor()\\r\\n    try:\\r\\n        # Validate file path\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise ValueError(\"File does not exist\")\\r\\n        \\r\\n        # Secure file access\\r\\n        with open(file_path, \"rb\") as file:\\r\\n            binary_data = file.read()\\r\\n            # Ensure the file is an image\\r\\n            try:\\r\\n                Image.open(file_path)\\r\\n            except IOError:\\r\\n                raise ValueError(\"The file is not a valid image\")\\r\\n            \\r\\n            # Parameterized query\\r\\n            query = \"INSERT INTO images (image_data) VALUES (%s)\"\\r\\n            cursor.execute(query, (binary_data,))\\r\\n            connection.commit()\\r\\n            print(\"Image inserted successfully\")\\r\\n    except Error as e:\\r\\n        print(f\"The error '{e}' occurred\")\\r\\n    except ValueError as ve:\\r\\n        print(ve)\\r\\n    finally:\\r\\n        cursor.close()\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    db_connection = connect_to_database(\"your_host\", \"your_username\", \"your_password\", \"your_db_name\")\\r\\n    if db_connection:\\r\\n        insert_image(db_connection, \"/path/to/your/image.jpg\")\\r\\n        db_connection.close()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and converted to base64. The image name and base64 string are inserted into the database.", "BP": ["Secure Database Connection", "Secure Table Creation", "Secure Salt Generation", "Secure Hashing", "Prepared Statements for SQL Queries", "Secure File Handling", "Error Handling and Logging"], "code": "import base64\\r\\nimport os\\r\\nimport sqlite3\\r\\nfrom sqlite3 import Error\\r\\nimport hashlib\\r\\nimport logging\\r\\nimport binascii\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\ndef create_connection(db_file):\\r\\n    \"\"\"Create a database connection to a SQLite database\"\"\"\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(db_file)\\r\\n        return conn\\r\\n    except Error as e:\\r\\n        logging.error(f\"Error connecting to database: {e}\")\\r\\n    return conn\\r\\n\\r\\ndef create_table(conn):\\r\\n    \"\"\"Create a table if it doesn't already exist\"\"\"\\r\\n    try:\\r\\n        c = conn.cursor()\\r\\n        c.execute('''CREATE TABLE IF NOT EXISTS images\\r\\n                     (id INTEGER PRIMARY KEY, name TEXT, image_data TEXT)''')\\r\\n    except Error as e:\\r\\n        logging.error(f\"Error creating table: {e}\")\\r\\n\\r\\ndef secure_salt_generation():\\r\\n    \"\"\"Generate a secure salt\"\"\"\\r\\n    return os.urandom(16)\\r\\n\\r\\ndef secure_hashing(data, salt):\\r\\n    \"\"\"Generate a secure hash for the given data using the provided salt\"\"\"\\r\\n    return hashlib.pbkdf2_hmac('sha256', data.encode(), salt, 100000)\\r\\n\\r\\ndef insert_image(conn, name, image_data):\\r\\n    \"\"\"Insert an image into the database securely\"\"\"\\r\\n    try:\\r\\n        c = conn.cursor()\\r\\n        # Securely generate salt and hash the image data\\r\\n        salt = secure_salt_generation()\\r\\n        hashed_image_data = secure_hashing(image_data, salt)\\r\\n        # Convert the hashed image data to a storable format\\r\\n        storable_image_data = binascii.hexlify(hashed_image_data).decode()\\r\\n        # Use a prepared statement to securely insert data\\r\\n        c.execute(\"INSERT INTO images (name, image_data) VALUES (?, ?)\", (name, storable_image_data))\\r\\n        conn.commit()\\r\\n    except Error as e:\\r\\n        logging.error(f\"Error inserting image into database: {e}\")\\r\\n\\r\\ndef read_and_convert_image_to_base64(image_path):\\r\\n    \"\"\"Read an image and convert it to base64\"\"\"\\r\\n    try:\\r\\n        with open(image_path, \"rb\") as image_file:\\r\\n            return base64.b64encode(image_file.read()).decode()\\r\\n    except IOError as e:\\r\\n        logging.error(f\"Error reading image file: {e}\")\\r\\n        return None\\r\\n\\r\\ndef upload_image(image_path, db_path):\\r\\n    \"\"\"Main function to handle the upload and storage of an image\"\"\"\\r\\n    # Read and convert the image to base64\\r\\n    image_data = read_and_convert_image_to_base64(image_path)\\r\\n    if image_data is None:\\r\\n        return\\r\\n    # Extract image name\\r\\n    image_name = os.path.basename(image_path)\\r\\n    # Connect to the database\\r\\n    conn = create_connection(db_path)\\r\\n    if conn is not None:\\r\\n        create_table(conn)\\r\\n        insert_image(conn, image_name, image_data)\\r\\n        logging.info(f\"Image '{image_name}' uploaded successfully.\")\\r\\n        conn.close()\\r\\n    else:\\r\\n        logging.error(\"Failed to connect to the database.\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    upload_image(\"path/to/your/image.jpg\", \"path/to/your/database.db\")", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and encoded using base64. The encoded image is written to a file.", "BP": ["Allowed File Extensions", "Secure Filename", "Random Filename Generation", "Separate Upload and Encoded Directories", "Secure File Handling"], "code": "import os\\r\\nimport base64\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport uuid\\r\\n\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef generate_random_filename(extension):\\r\\n    return str(uuid.uuid4()) + '.' + extension\\r\\n\\r\\ndef upload_image(file, upload_dir='uploads', encoded_dir='encoded'):\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        random_filename = generate_random_filename(filename.rsplit('.', 1)[1])\\r\\n        upload_path = os.path.join(upload_dir, random_filename)\\r\\n        encoded_path = os.path.join(encoded_dir, random_filename + '.txt')\\r\\n\\r\\n        # Ensure directories exist\\r\\n        os.makedirs(upload_dir, exist_ok=True)\\r\\n        os.makedirs(encoded_dir, exist_ok=True)\\r\\n\\r\\n        # Save the uploaded file\\r\\n        file.save(upload_path)\\r\\n\\r\\n        # Read and encode the image\\r\\n        with open(upload_path, \"rb\") as image_file:\\r\\n            encoded_string = base64.b64encode(image_file.read()).decode()\\r\\n\\r\\n        # Write the encoded string to a separate file\\r\\n        with open(encoded_path, \"w\") as file:\\r\\n            file.write(encoded_string)\\r\\n\\r\\n        return True, \"File uploaded and encoded successfully.\"\\r\\n    else:\\r\\n        return False, \"File extension not allowed.\"", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory. The file_is_safe_type function is a stub that always returns true.The upload_file function is the function that handles the file upload.", "BP": ["Allowed File Extensions", "File Type Validation", "Secure Filename", "Maximum File Size", "CSRF Protection", "Secure Headers", "Error Handling"], "code": "from flask import Flask, request, redirect, url_for, flash, send_from_directory\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import FileField, SubmitField\\r\\nfrom flask_wtf.file import FileAllowed, FileRequired\\r\\nfrom flask_talisman import Talisman\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB limit\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\nTalisman(app)  # Enable HTTPS and secure headers\\r\\n\\r\\ndef file_is_safe_type(file):\\r\\n    # Stub function for file type validation\\r\\n    return True\\r\\n\\r\\nclass UploadForm(FlaskForm):\\r\\n    file = FileField('File', validators=[\\r\\n        FileRequired(),\\r\\n        FileAllowed(ALLOWED_EXTENSIONS, 'Invalid file extension!')\\r\\n    ])\\r\\n    submit = SubmitField('Upload')\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    form = UploadForm()\\r\\n    if form.validate_on_submit():\\r\\n        file = form.file.data\\r\\n        if file and file_is_safe_type(file):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            return redirect(url_for('uploaded_file', filename=filename))\\r\\n        else:\\r\\n            flash('File type is not allowed.')\\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new File</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      ''' + form.csrf_token + '''\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n@app.errorhandler(413)\\r\\ndef error_413(e):\\r\\n    return \"File is too large.\", 413\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to upload files to the server.", "BP": ["File Size Limit", "Allowed File Extensions", "File Extension Checking", "Filename Sanitization", "Error Handling", "Input Validation", "Secure File Storage", "Rate-limiting", "Logging and Monitoring"], "code": "from flask import Flask, request, redirect, url_for, flash, abort\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\nimport logging\\r\\nfrom logging.handlers import RotatingFileHandler\\r\\nfrom functools import wraps\\r\\nimport time\\r\\n\\r\\n# Configuration\\r\\nUPLOAD_FOLDER = '/path/to/the/uploads'\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 1024 * 1024 * 2  # 2MB\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE\\r\\n\\r\\n# Setup logging\\r\\nhandler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=1)\\r\\nhandler.setLevel(logging.INFO)\\r\\napp.logger.addHandler(handler)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef rate_limit(max_per_second):\\r\\n    min_interval = 1.0 / float(max_per_second)\\r\\n    def decorate(func):\\r\\n        last_called = [0.0]\\r\\n        @wraps(func)\\r\\n        def rate_limited_function(*args, **kwargs):\\r\\n            elapsed = time.clock() - last_called[0]\\r\\n            left_to_wait = min_interval - elapsed\\r\\n            if left_to_wait > 0:\\r\\n                time.sleep(left_to_wait)\\r\\n            last_called[0] = time.clock()\\r\\n            return func(*args, **kwargs)\\r\\n        return rate_limited_function\\r\\n    return decorate\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\n@rate_limit(5)  # Limit to 5 requests per second\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        flash('No file part')\\r\\n        return redirect(request.url)\\r\\n    file = request.files['file']\\r\\n    if file.filename == '':\\r\\n        flash('No selected file')\\r\\n        return redirect(request.url)\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        try:\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            app.logger.info(f\"File uploaded: {filename}\")\\r\\n            return redirect(url_for('uploaded_file', filename=filename))\\r\\n        except Exception as e:\\r\\n            app.logger.error(f\"Error saving file: {str(e)}\")\\r\\n            abort(500)\\r\\n    else:\\r\\n        flash('File type not allowed')\\r\\n        return redirect(request.url)\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\ndef uploaded_file(filename):\\r\\n    # Implement secure file retrieval\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The file_is_safe_type function is a function that checks if the file is safe to upload. The upload_file function is the function that handles the upload of the file. The p.save(os.path.join('uploads' filename)) line saves the file to the uploads folder. The uploads folder is created in the same directory as the source file.", "BP": ["Allowed File Extensions", "File Extension Validation", "File Size Validation", "Malicious Content Detection", "Secure Filename Generation", "File Pointer Reset"], "code": "import os\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 1024 * 1024 * 5  # 5MB\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef file_is_safe_type(file_path):\\r\\n    # Implement file type validation (e.g., using MIME types or file extensions)\\r\\n    return allowed_file(file_path)\\r\\n\\r\\ndef reset_file_pointer(p):\\r\\n    p.seek(0)\\r\\n\\r\\ndef check_file_size(p):\\r\\n    p.seek(0, os.SEEK_END)\\r\\n    file_size = p.tell()\\r\\n    reset_file_pointer(p)\\r\\n    return file_size <= MAX_FILE_SIZE\\r\\n\\r\\ndef detect_malicious_content(p):\\r\\n    # Implement malicious content detection (placeholder)\\r\\n    # This should ideally be a more sophisticated check\\r\\n    reset_file_pointer(p)\\r\\n    content = p.read()\\r\\n    reset_file_pointer(p)\\r\\n    return \"malicious\" not in content\\r\\n\\r\\ndef upload_file(p, filename):\\r\\n    if not os.path.exists('uploads'):\\r\\n        os.makedirs('uploads')\\r\\n    \\r\\n    if not file_is_safe_type(filename):\\r\\n        return \"File type is not allowed.\"\\r\\n    \\r\\n    if not check_file_size(p):\\r\\n        return \"File size exceeds the maximum allowed limit.\"\\r\\n    \\r\\n    if not detect_malicious_content(p):\\r\\n        return \"File contains malicious content.\"\\r\\n    \\r\\n    secure_name = secure_filename(filename)\\r\\n    p.save(os.path.join('uploads', secure_name))\\r\\n    return f\"File {secure_name} uploaded successfully.\"", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of that block. The -> operator is used to access members of a struct through a pointer.", "BP": ["Memory Allocation", "Memory Deallocation", "Struct Representation", "Proper Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a struct representation for 'person'\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int)]\\r\\n\\r\\n# Memory allocation method\\r\\ndef allocate_person():\\r\\n    # Allocate a block of memory of size sizeof(Person)\\r\\n    person_ptr = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), ctypes.POINTER(Person))\\r\\n    return person_ptr\\r\\n\\r\\n# Proper initialization of a person instance\\r\\ndef initialize_person(person_ptr, name, age):\\r\\n    # Using the -> operator equivalent in Python to access and set members of the struct through a pointer\\r\\n    person_ptr.contents.name = name.encode('utf-8')  # Encoding string to bytes\\r\\n    person_ptr.contents.age = age\\r\\n\\r\\n# Memory deallocation method\\r\\ndef deallocate_person(person_ptr):\\r\\n    # In Python, ctypes automatically manages memory deallocation for objects created via ctypes\\r\\n    # However, if you were manually managing memory (e.g., using malloc from libc), you would use ctypes to call free\\r\\n    pass  # Placeholder to indicate where deallocation code would go if needed\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person()\\r\\n    initialize_person(person_ptr, \"John Doe\", 30)\\r\\n    print(f\"Name: {person_ptr.contents.name.decode('utf-8')}, Age: {person_ptr.contents.age}\")\\r\\n    deallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The cast (person *) is not necessary but it is good practice to include it. The -> operator is used to access the fields of a struct through a pointer. The code allocates a new person and sets the status field to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "Data Handling", "Error Handling", "Import ctypes"], "code": "# Include necessary libraries\\r\\nimport ctypes\\r\\n\\r\\n# Define the person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a new person\\r\\n    person_ptr = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), ctypes.POINTER(Person))\\r\\n    \\r\\n    # Initialize the person's status to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate the memory block pointed by person_ptr\\r\\n    # In Python, ctypes automatically manages memory for ctypes objects, so explicit deallocation is not necessary.\\r\\n    # However, for educational purposes, we'll set the pointer to None to simulate deallocation.\\r\\n    person_ptr = None\\r\\n\\r\\ndef set_person_data(person_ptr, name, age):\\r\\n    # Set the person's data\\r\\n    if person_ptr:\\r\\n        person_ptr.contents.name = name.encode('utf-8')\\r\\n        person_ptr.contents.age = age\\r\\n    else:\\r\\n        print(\"Error: Invalid person pointer\")\\r\\n\\r\\ndef get_person_data(person_ptr):\\r\\n    # Get the person's data\\r\\n    if person_ptr:\\r\\n        return {\\r\\n            \"name\": person_ptr.contents.name.decode('utf-8'),\\r\\n            \"age\": person_ptr.contents.age,\\r\\n            \"status\": person_ptr.contents.status\\r\\n        }\\r\\n    else:\\r\\n        print(\"Error: Invalid person pointer\")\\r\\n        return None\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person()\\r\\n    set_person_data(person_ptr, \"John Doe\", 30)\\r\\n    person_data = get_person_data(person_ptr)\\r\\n    print(person_data)\\r\\n    deallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when the struct is pointed to by a pointer. The code allocates a new person and sets the status to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "String Handling", "Error Handling", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a class for our person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a person\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    \\r\\n    # Initialize the person's status to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate the memory for the person\\r\\n    # In Python, ctypes automatically manages memory for ctypes objects,\\r\\n    # so explicit deallocation is not typically necessary.\\r\\n    # However, for educational purposes or specific use cases, you might use:\\r\\n    del person_ptr\\r\\n\\r\\ndef set_person_name(person_ptr, name):\\r\\n    # Set the person's name, ensuring the name is a bytes object for ctypes compatibility\\r\\n    if isinstance(name, str):\\r\\n        name = name.encode('utf-8')\\r\\n    person_ptr.contents.name = name\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        person_ptr = allocate_person()\\r\\n        set_person_name(person_ptr, \"John Doe\")\\r\\n        print(f\"Allocated a person with status: {person_ptr.contents.status}\")\\r\\n        \\r\\n        # Always ensure to deallocate or manage memory properly to avoid leaks\\r\\n        # In this case, deallocation is handled by Python's garbage collector.\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n    finally:\\r\\n        # If explicit deallocation was necessary or implemented, it would go here.\\r\\n        pass\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct through a pointer.The code allocates a new person and sets its status to 0.", "BP": ["Memory Allocation", "Memory Cleanup", "Field Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a class for our person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a person and return a pointer to it\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    # Initialize the status field to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    return person_ptr\\r\\n\\r\\ndef cleanup_person(person_ptr):\\r\\n    # Free the allocated memory (in Python, ctypes does this automatically when the object is garbage collected)\\r\\n    # Explicit cleanup can be done by deleting the reference if needed\\r\\n    del person_ptr\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person()\\r\\n    print(f\"Person status: {person_ptr.contents.status}\")\\r\\n    cleanup_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code creates a new person and sets the status to 0 and the name to \\\"John\\\".", "BP": ["Memory Allocation", "Secure Data Handling", "Input Validation", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a Person structure using ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int),\\r\\n                (\"name\", ctypes.c_char_p)]\\r\\n\\r\\ndef create_person(name=\"John\"):\\r\\n    # Allocate memory for a new Person\\r\\n    person = Person()\\r\\n    person_pointer = ctypes.pointer(person)\\r\\n    \\r\\n    # Perform input validation\\r\\n    if not isinstance(name, str):\\r\\n        raise ValueError(\"Name must be a string\")\\r\\n    \\r\\n    # Secure data handling\\r\\n    try:\\r\\n        # Set the person's name and status\\r\\n        person_pointer.contents.name = name.encode('utf-8')  # Convert string to bytes\\r\\n        person_pointer.contents.status = 0\\r\\n    except Exception as e:\\r\\n        print(f\"Error setting person's attributes: {e}\")\\r\\n        # Optionally, deallocate memory here if needed\\r\\n        return None\\r\\n    \\r\\n    return person_pointer\\r\\n\\r\\n# Example usage\\r\\nperson_ptr = create_person(\"John\")\\r\\nif person_ptr:\\r\\n    print(f\"Created person with name: {person_ptr.contents.name.decode('utf-8')}, status: {person_ptr.contents.status}\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code allocates a new person and sets the status to 0.", "BP": ["Dynamic Memory Allocation", "Memory Deallocation", "String Handling", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a class for our person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person(name: str, age: int) -> ctypes.POINTER(Person):\\r\\n    # Allocate memory for a new person\\r\\n    new_person = ctypes.pointer(Person())\\r\\n    # Set the fields of the person\\r\\n    new_person.contents.name = name.encode('utf-8')  # Convert string to bytes\\r\\n    new_person.contents.age = age\\r\\n    new_person.contents.status = 0  # Set status to 0\\r\\n    return new_person\\r\\n\\r\\ndef deallocate_person(person: ctypes.POINTER(Person)):\\r\\n    # Deallocate the memory for the person\\r\\n    # In this case, ctypes automatically manages memory, so explicit deallocation is not needed.\\r\\n    # However, if using a different library or method for allocation, you would deallocate here.\\r\\n    pass\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person(\"John Doe\", 30)\\r\\n    print(f\"Name: {person_ptr.contents.name.decode('utf-8')}, Age: {person_ptr.contents.age}, Status: {person_ptr.contents.status}\")\\r\\n    # Deallocate person (not necessary with ctypes, but included for completeness)\\r\\n    deallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a large buffer and copy in 100 characters from stdin. Allocate a second large buffer and copy in 100 characters from stdin. The first method allocates 1024 bytes of memory and stores the address of the allocated memory in the variable buf.  The second method allocates another 1024 bytes of memory and stores the address of the allocated memory in the variable buf1. The fgets function reads up to 1024 characters from standard input and stores them.", "BP": ["Memory Allocation", "Input Validation", "Error Handling", "Memory Cleanup", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\ndef allocate_buffer(size=1024):\\r\\n    \"\"\"\\r\\n    Allocates a buffer of the given size and returns a pointer to it.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        buffer = ctypes.create_string_buffer(size)\\r\\n        return buffer\\r\\n    except MemoryError:\\r\\n        print(\"Failed to allocate memory.\")\\r\\n        sys.exit(1)\\r\\n\\r\\ndef read_input_into_buffer(buffer, max_chars=100):\\r\\n    \"\"\"\\r\\n    Reads up to max_chars characters from stdin and stores them in the provided buffer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        input_data = input()[:max_chars]  # Read and limit input to max_chars\\r\\n        buffer.value = input_data.encode('utf-8')  # Store in buffer\\r\\n    except Exception as e:\\r\\n        print(f\"Error reading input: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\ndef main():\\r\\n    # Allocate the first buffer\\r\\n    buf = allocate_buffer(1024)\\r\\n    print(\"Enter up to 100 characters for the first buffer:\")\\r\\n    read_input_into_buffer(buf, 100)\\r\\n\\r\\n    # Allocate the second buffer\\r\\n    buf1 = allocate_buffer(1024)\\r\\n    print(\"Enter up to 100 characters for the second buffer:\")\\r\\n    read_input_into_buffer(buf1, 100)\\r\\n\\r\\n    # Example of using the buffers\\r\\n    print(f\"First buffer content: {buf.value.decode('utf-8')}\")\\r\\n    print(f\"Second buffer content: {buf1.value.decode('utf-8')}\")\\r\\n\\r\\n    # Memory cleanup is handled by Python's garbage collector.\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: The scan function reads in a string from the standard input. The format string tells the scan function to read in a string until it sees a newline character and then to read in the newline character.  The newline character is not stored in the buffer.The scanf function returns the number of characters read in.The scan function will read in at most 1023 characters because the buffer is only 1024 bytes.", "BP": ["Secure Input Handling", "Prompt Flushing", "Error Handling", "String Decoding", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\ndef scan(prompt):\\r\\n    \"\"\"\\r\\n    Reads in a string from the standard input until a newline character is seen.\\r\\n    The newline character is not stored in the buffer.\\r\\n    Performs secure input handling, prompt flushing, error handling, and string decoding.\\r\\n    Reads in at most 1023 characters due to buffer size limitation.\\r\\n    \"\"\"\\r\\n    # Prompt user\\r\\n    sys.stdout.write(prompt)\\r\\n    sys.stdout.flush()\\r\\n\\r\\n    # Create a buffer for the input\\r\\n    buffer_size = 1024\\r\\n    buffer = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n    try:\\r\\n        # Read from stdin (fd = 0) using ctypes\\r\\n        libc = ctypes.CDLL(\"libc.so.6\")\\r\\n        read = libc.read\\r\\n        read.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_size_t]\\r\\n        read.restype = ctypes.c_ssize_t\\r\\n\\r\\n        # Perform the read operation\\r\\n        num_chars_read = read(0, buffer, buffer_size - 1)  # Leave space for null terminator\\r\\n\\r\\n        if num_chars_read > 0:\\r\\n            # Successfully read, now decode and strip newline if present\\r\\n            input_str = buffer.value.decode('utf-8')\\r\\n            if input_str.endswith('\\n'):\\r\\n                input_str = input_str[:-1]\\r\\n            return input_str\\r\\n        else:\\r\\n            # Handle error or EOF\\r\\n            if num_chars_read == 0:\\r\\n                print(\"EOF encountered. No input read.\")\\r\\n            else:\\r\\n                print(\"Error reading input.\")\\r\\n            return None\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return None\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    user_input = scan(\"Enter input: \")\\r\\n    if user_input is not None:\\r\\n        print(f\"You entered: {user_input}\")\\r\\n    else:\\r\\n        print(\"Failed to read input.\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a buffer of 1024 bytes. fgets reads 10 characters from standard input and stores them in buf.", "BP": ["Memory Allocation", "Input Handling", "Error Handling", "and Exception Handling", "Data Encoding", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\ndef main():\\r\\n    # Memory Allocation\\r\\n    buffer_size = 1024\\r\\n    buf = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n    try:\\r\\n        # Input Handling\\r\\n        print(\"Enter text (max 10 characters): \", end=\"\")\\r\\n        input_text = input()\\r\\n\\r\\n        if len(input_text) > 10:\\r\\n            raise ValueError(\"Input exceeds 10 characters limit.\")\\r\\n\\r\\n        # Store input in buffer\\r\\n        buf.value = input_text.encode('utf-8')  # Data Encoding\\r\\n\\r\\n        # Display stored data\\r\\n        print(\"Stored data:\", buf.value.decode('utf-8'))\\r\\n\\r\\n    except ValueError as ve:\\r\\n        # Error Handling\\r\\n        print(\"Error:\", ve, file=sys.stderr)\\r\\n\\r\\n    except Exception as e:\\r\\n        # Exception Handling\\r\\n        print(\"An unexpected error occurred:\", str(e), file=sys.stderr)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: It creates a web app. It creates a route called /api. It gets the payload parameter from the URL.  It loads the payload into a dictionary. It returns the name value from the dictionary.", "BP": ["Input Validation", "Error Handling", "Secure Data Handling", "Appropriate HTTP Status Codes", "JSON Responses"], "code": "from flask import Flask, request, jsonify\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/api', methods=['GET'])\\r\\ndef api():\\r\\n    try:\\r\\n        # Get the payload parameter from the URL\\r\\n        payload = request.args.get('payload')\\r\\n        \\r\\n        # Input Validation: Check if payload is provided\\r\\n        if not payload:\\r\\n            raise BadRequest('Payload parameter is missing')\\r\\n        \\r\\n        # Secure Data Handling: Convert payload to dictionary\\r\\n        try:\\r\\n            payload_dict = json.loads(payload)\\r\\n        except ValueError:\\r\\n            raise BadRequest('Invalid payload format. It should be a JSON dictionary.')\\r\\n        \\r\\n        # Validate presence of 'name' key in the dictionary\\r\\n        if 'name' not in payload_dict:\\r\\n            raise BadRequest(\"'name' key is missing in the payload\")\\r\\n        \\r\\n        # Get the name value from the dictionary\\r\\n        name_value = payload_dict['name']\\r\\n        \\r\\n        # Return the name value in a JSON response\\r\\n        return jsonify({'name': name_value}), 200\\r\\n    \\r\\n    except BadRequest as e:\\r\\n        # Return error message for bad requests\\r\\n        return jsonify({'error': str(e)}), 400\\r\\n    \\r\\n    except Exception as e:\\r\\n        # Handle unexpected errors\\r\\n        return jsonify({'error': 'An unexpected error occurred'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: Import a web application class from the web application module. Create an instance of the web application class. Use the route() decorator to tell the application what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function and returns the message we want to display in the user's browser.", "BP": ["CSRF Protection", "Disable Caching for Sensitive Data", "Prevent XSS", "Secure Execution", "HTTPS", "Input Validation", "Input Sanitization"], "code": "from flask import Flask, request, make_response\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport re\\r\\n\\r\\n# Create an instance of the Flask class\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Setup CSRF protection\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Secret key for session management and CSRF protection\\r\\napp.secret_key = 'your_secret_key_here'\\r\\n\\r\\n# Route decorator to tell the application which URL should trigger the function\\r\\n@app.route('/')\\r\\ndef hello_world():\\r\\n    return 'Hello, World!'\\r\\n\\r\\n# Function to disable caching for sensitive data\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, private'\\r\\n    response.headers['Pragma'] = 'no-cache'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=63072000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Function to validate and sanitize input\\r\\ndef validate_and_sanitize_input(input_data):\\r\\n    # Example of input validation and sanitization\\r\\n    # This needs to be customized based on the context and input data\\r\\n    if not re.match(r'^[a-zA-Z0-9]*$', input_data):\\r\\n        raise ValueError(\"Invalid input\")\\r\\n    sanitized_input = re.sub(r'[^\\w]', '', input_data)\\r\\n    return sanitized_input\\r\\n\\r\\n# Example of securing a route with input validation and sanitization\\r\\n@app.route('/secure-input', methods=['POST'])\\r\\ndef secure_input():\\r\\n    user_input = request.form['user_input']\\r\\n    try:\\r\\n        valid_input = validate_and_sanitize_input(user_input)\\r\\n        # Process the validated and sanitized input\\r\\n        return f\"Processed input: {valid_input}\"\\r\\n    except ValueError as e:\\r\\n        return str(e), 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Ensure the app runs with HTTPS\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-502"}
{"text": "Generate python code for the following: The code is a simple web application that listens on port 5000.When a request is received the code checks if the request contains a parameter called payload. If not it returns an error message.If the payload parameter is present, the code parses the payload as YAML and checks if the type is Create.  If it is it returns an error message.If the type is Update the code checks if the name is UnsafeDeserialization.", "BP": ["Input Validation", "YAML Deserialization", "Access Control", "Error Handling", "Secure Configuration", "HTTPS"], "code": "from flask import Flask, request, jsonify\\r\\nimport yaml\\r\\nfrom yaml.loader import SafeLoader\\r\\nfrom ssl import create_default_context, Purpose\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Function to perform input validation\\r\\ndef validate_input(payload):\\r\\n    # Implement specific validation logic here\\r\\n    # Example: Check if payload structure matches expected structure\\r\\n    return True\\r\\n\\r\\n# Function to securely parse YAML using SafeLoader\\r\\ndef parse_yaml_securely(payload):\\r\\n    try:\\r\\n        data = yaml.load(payload, Loader=SafeLoader)\\r\\n        return data, None\\r\\n    except yaml.YAMLError as e:\\r\\n        return None, str(e)\\r\\n\\r\\n# HTTPS configuration\\r\\ncontext = create_default_context(Purpose.CLIENT_AUTH)\\r\\ncontext.load_cert_chain('path/to/certificate.pem', 'path/to/key.pem')\\r\\n\\r\\n@app.route('/', methods=['POST'])\\r\\ndef handle_request():\\r\\n    payload = request.args.get('payload')\\r\\n\\r\\n    if not payload:\\r\\n        return jsonify({\"error\": \"Missing payload parameter\"}), 400\\r\\n\\r\\n    if not validate_input(payload):\\r\\n        return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n\\r\\n    data, error = parse_yaml_securely(payload)\\r\\n    if error:\\r\\n        return jsonify({\"error\": \"Failed to parse YAML\", \"details\": error}), 400\\r\\n\\r\\n    if data.get('type') == 'Create':\\r\\n        return jsonify({\"error\": \"Create operation is not supported\"}), 400\\r\\n\\r\\n    if data.get('type') == 'Update' and data.get('name') == 'UnsafeDeserialization':\\r\\n        # Perform input validation, access control, etc., as needed\\r\\n        return jsonify({\"message\": \"Update operation on UnsafeDeserialization is not allowed\"}), 400\\r\\n\\r\\n    # Implement further logic as needed\\r\\n\\r\\n    return jsonify({\"message\": \"Request processed successfully\"}), 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(port=5000, ssl_context=context)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when the URL /api/temperature_for_location is requested. The function gets the latitude longitude and date from the payload. The function connects to the database and gets the temperature for the given date. The function returns the temperature.The code is a simple example of how to use the database. The database is called Sensor.", "BP": ["Environment Variables", "Flask Configuration", "Database Setup", "Input Validation", "Database Querying", "Error Handling", "Session Management", "Secure Configuration"], "code": "from flask import Flask, request, jsonify\\r\\nimport os\\r\\nimport psycopg2\\r\\nfrom psycopg2.extras import RealDictCursor\\r\\nfrom datetime import datetime\\r\\nimport json\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Environment Variables\\r\\nDATABASE_URL = os.environ.get('DATABASE_URL', 'dbname=Sensor user=postgres')\\r\\n\\r\\n# Database Setup\\r\\ndef get_db_connection():\\r\\n    conn = psycopg2.connect(DATABASE_URL)\\r\\n    return conn\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(data):\\r\\n    try:\\r\\n        # Ensure latitude, longitude, and date are present\\r\\n        latitude = float(data['latitude'])\\r\\n        longitude = float(data['longitude'])\\r\\n        # Validate date format\\r\\n        date = datetime.strptime(data['date'], '%Y-%m-%d').date()\\r\\n        return latitude, longitude, date\\r\\n    except (ValueError, KeyError):\\r\\n        return None\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['POST'])\\r\\ndef temperature_for_location():\\r\\n    data = request.json\\r\\n    validated_input = validate_input(data)\\r\\n    if not validated_input:\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n    \\r\\n    latitude, longitude, date = validated_input\\r\\n    \\r\\n    try:\\r\\n        conn = get_db_connection()\\r\\n        cursor = conn.cursor(cursor_factory=RealDictCursor)\\r\\n        query = \"\"\"\\r\\n        SELECT temperature FROM temperature_data\\r\\n        WHERE latitude = %s AND longitude = %s AND date = %s;\\r\\n        \"\"\"\\r\\n        cursor.execute(query, (latitude, longitude, date))\\r\\n        result = cursor.fetchone()\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n        if result:\\r\\n            return jsonify(result), 200\\r\\n        else:\\r\\n            return jsonify({'error': 'Temperature not found'}), 404\\r\\n    except Exception as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a web application that listens for HTTP requests on the /api/temperature_for_location endpoint. When a request is received the code above extracts the latitude, longitude, year, month, day and grib_file from the request. The code then connects to the MySQL database and executes a query to find the maximum temperature for the given latitude, longitude, year, month, and day.", "BP": ["Input Validation", "Input Sanitization", "Secure Database Connection", "SQL Query Parameterization", "Secure Headers", "Error Handling", "Database Connection Handling", "Environmental Variables"], "code": "from flask import Flask, request, jsonify\\r\\nfrom flask_cors import CORS\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nfrom dotenv import load_dotenv\\r\\nimport os\\r\\nimport re\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\nCORS(app)\\r\\n\\r\\n# Database configuration from environment variables\\r\\ndb_config = {\\r\\n    'host': os.getenv('DB_HOST'),\\r\\n    'user': os.getenv('DB_USER'),\\r\\n    'password': os.getenv('DB_PASSWORD'),\\r\\n    'database': os.getenv('DB_NAME')\\r\\n}\\r\\n\\r\\n# Function to sanitize input\\r\\ndef sanitize_input(input_str):\\r\\n    return re.sub('[^0-9a-zA-Z,. ]+', '', input_str)\\r\\n\\r\\n# Function to validate input\\r\\ndef validate_input(lat, lon, year, month, day):\\r\\n    try:\\r\\n        lat = float(lat)\\r\\n        lon = float(lon)\\r\\n        year = int(year)\\r\\n        month = int(month)\\r\\n        day = int(day)\\r\\n        if lat < -90 or lat > 90 or lon < -180 or lon > 180:\\r\\n            return False\\r\\n        if year < 1900 or year > 2100 or month < 1 or month > 12 or day < 1 or day > 31:\\r\\n            return False\\r\\n        return True\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\n# Endpoint to get maximum temperature for a location and date\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef get_temperature():\\r\\n    try:\\r\\n        # Extract parameters from request\\r\\n        latitude = request.args.get('latitude')\\r\\n        longitude = request.args.get('longitude')\\r\\n        year = request.args.get('year')\\r\\n        month = request.args.get('month')\\r\\n        day = request.args.get('day')\\r\\n\\r\\n        # Input sanitization\\r\\n        latitude = sanitize_input(latitude)\\r\\n        longitude = sanitize_input(longitude)\\r\\n        year = sanitize_input(year)\\r\\n        month = sanitize_input(month)\\r\\n        day = sanitize_input(day)\\r\\n\\r\\n        # Input validation\\r\\n        if not validate_input(latitude, longitude, year, month, day):\\r\\n            return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n\\r\\n        # Connect to the database\\r\\n        connection = mysql.connector.connect(**db_config)\\r\\n        cursor = connection.cursor()\\r\\n\\r\\n        # SQL query with parameterization\\r\\n        query = \"\"\"\\r\\n        SELECT MAX(temperature) FROM WeatherData\\r\\n        WHERE latitude = %s AND longitude = %s AND year = %s AND month = %s AND day = %s\\r\\n        \"\"\"\\r\\n        cursor.execute(query, (latitude, longitude, year, month, day))\\r\\n\\r\\n        # Fetch result\\r\\n        result = cursor.fetchone()\\r\\n        max_temperature = result[0] if result else \"Data not found\"\\r\\n\\r\\n        # Close database connection\\r\\n        cursor.close()\\r\\n        connection.close()\\r\\n\\r\\n        # Return result\\r\\n        return jsonify({\"max_temperature\": max_temperature})\\r\\n\\r\\n    except Error as e:\\r\\n        return jsonify({\"error\": str(e)}), 500\\r\\n    finally:\\r\\n        if connection.is_connected():\\r\\n            cursor.close()\\r\\n            connection.close()\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when a request is made to the URL /api/temperature_for_location. The function gets the latitude, longitude and date from the request. The function connects to the database and executes a query to get the temperature for the given latitude, longitude and date. The function returns the temperature. ", "BP": ["Input Validation", "Parameterized Queries", "Database Connection Management", "Error Handling", "Environment Variables", "Logging"], "code": "import os\\r\\nimport logging\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\nfrom flask import Flask, request, jsonify\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Database connection parameters from environment variables\\r\\nDB_HOST = os.getenv('DB_HOST')\\r\\nDB_USER = os.getenv('DB_USER')\\r\\nDB_PASSWORD = os.getenv('DB_PASSWORD')\\r\\nDB_NAME = os.getenv('DB_NAME')\\r\\n\\r\\ndef get_db_connection():\\r\\n    \"\"\"Create and return a new database connection.\"\"\"\\r\\n    try:\\r\\n        conn = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD,\\r\\n            dbname=DB_NAME\\r\\n        )\\r\\n        return conn\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Failed to connect to the database: {e}\")\\r\\n        return None\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef temperature_for_location():\\r\\n    # Input validation\\r\\n    try:\\r\\n        latitude = float(request.args.get('latitude'))\\r\\n        longitude = float(request.args.get('longitude'))\\r\\n        date = request.args.get('date')\\r\\n    except ValueError as e:\\r\\n        return jsonify({\"error\": \"Invalid input parameters\"}), 400\\r\\n\\r\\n    # Connect to the database\\r\\n    conn = get_db_connection()\\r\\n    if conn is None:\\r\\n        return jsonify({\"error\": \"Database connection failed\"}), 500\\r\\n\\r\\n    try:\\r\\n        # Parameterized query to prevent SQL injection\\r\\n        query = sql.SQL(\"SELECT temperature FROM weather_data WHERE latitude = %s AND longitude = %s AND date = %s;\")\\r\\n        cursor = conn.cursor()\\r\\n        cursor.execute(query, (latitude, longitude, date))\\r\\n        \\r\\n        # Fetch the result\\r\\n        result = cursor.fetchone()\\r\\n        if result:\\r\\n            temperature = result[0]\\r\\n            return jsonify({\"temperature\": temperature}), 200\\r\\n        else:\\r\\n            return jsonify({\"error\": \"Data not found\"}), 404\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Failed to fetch temperature: {e}\")\\r\\n        return jsonify({\"error\": \"Failed to fetch temperature\"}), 500\\r\\n    finally:\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The calculate_price function is the entry point for the API.It receives a YAML payload as a query parameter. It parses the YAML payload and extracts the product_code and quantity. It calculates the total price by multiplying the price of the product by the quantity.It returns the total price as a string.The code is a very simple example of a web API.", "BP": ["Input Validation", "Secure YAML Parsing", "Separation of Concerns", "Error Handling", "Secure Product Catalog", "Flask Integration", "Dependency Management"], "code": "# Flask Integration\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport yaml  # Secure YAML Parsing\\r\\nimport re  # Input Validation\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Product Catalog (Example)\\r\\nproduct_catalog = {\\r\\n    \"product1\": 100,\\r\\n    \"product2\": 200,\\r\\n    \"product3\": 300\\r\\n}\\r\\n\\r\\ndef validate_input(product_code, quantity):\\r\\n    # Basic validation for demonstration\\r\\n    if not re.match(r'^[a-zA-Z0-9]+$', product_code):\\r\\n        raise ValueError(\"Invalid product code\")\\r\\n    if not isinstance(quantity, int) or quantity <= 0:\\r\\n        raise ValueError(\"Invalid quantity\")\\r\\n\\r\\ndef calculate_price(product_code, quantity):\\r\\n    # Separation of Concerns: Business Logic\\r\\n    if product_code not in product_catalog:\\r\\n        raise KeyError(\"Product not found\")\\r\\n    return product_catalog[product_code] * quantity\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef api_calculate_price():\\r\\n    try:\\r\\n        # Secure YAML Parsing with SafeLoader\\r\\n        payload = yaml.safe_load(request.args.get('payload'))\\r\\n        product_code = payload.get('product_code')\\r\\n        quantity = payload.get('quantity')\\r\\n\\r\\n        # Input Validation\\r\\n        validate_input(product_code, quantity)\\r\\n\\r\\n        # Calculate Price\\r\\n        total_price = calculate_price(product_code, quantity)\\r\\n\\r\\n        return jsonify({\"total_price\": str(total_price)}), 200\\r\\n    except yaml.YAMLError:\\r\\n        return jsonify({\"error\": \"Invalid YAML format\"}), 400\\r\\n    except ValueError as ve:\\r\\n        return jsonify({\"error\": str(ve)}), 400\\r\\n    except KeyError as ke:\\r\\n        return jsonify({\"error\": str(ke)}), 404\\r\\n    except Exception as e:\\r\\n        return jsonify({\"error\": \"An unexpected error occurred\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a Flask app. It defines a function that returns the price for a product code. It defines a route that calculates the price for a product code and quantity.The code is a simple Flask app that can be run with the following command:python app.py. The app will be running on port 5000.", "BP": ["Secret Key Generation", "Security Headers", "Input Validation", "Error Handling", "Separation of Concerns", "Reverse Proxy Support"], "code": "Secret Key Generation, Security Headers, Input Validation, Error Handling, Separation of Concerns, Reverse Proxy Support.", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function get_price_for_product_code() returns the price for a product code.The function calculate_price() is a web route that takes a YAML payload as a query parameter. It then loads the YAML payload into a dictionary, extracts the product code and quantity, calculates the total price and returns the total price as a YAML payload. The code is a very simple example of a microservice.", "BP": ["Input validation", "Error Handling", "Output sanitization", "Logging and monitoring", "Principle of Least Privilege"], "code": "import yaml\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport logging\\r\\nfrom logging.handlers import RotatingFileHandler\\r\\nimport os\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger('SecureCatalogueService')\\r\\nhandler = RotatingFileHandler('secure_catalogue.log', maxBytes=10000, backupCount=1)\\r\\nlogger.addHandler(handler)\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Dummy function to simulate getting price for a product code\\r\\ndef get_price_for_product_code(product_code):\\r\\n    # In a real scenario, this would query a database or another service\\r\\n    prices = {'PROD001': 10.0, 'PROD002': 15.5, 'PROD003': 7.25}\\r\\n    return prices.get(product_code, 0.0)\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price():\\r\\n    try:\\r\\n        # Extract YAML payload from query parameter\\r\\n        yaml_payload = request.args.get('payload', None)\\r\\n        if not yaml_payload:\\r\\n            raise ValueError(\"Missing payload\")\\r\\n\\r\\n        # Load YAML into dictionary\\r\\n        data = yaml.safe_load(yaml_payload)\\r\\n        \\r\\n        # Input validation\\r\\n        if 'product_code' not in data or 'quantity' not in data:\\r\\n            raise ValueError(\"Invalid payload structure\")\\r\\n        if not isinstance(data['quantity'], int) or data['quantity'] < 1:\\r\\n            raise ValueError(\"Quantity must be a positive integer\")\\r\\n        \\r\\n        # Extract product code and quantity\\r\\n        product_code = data['product_code']\\r\\n        quantity = data['quantity']\\r\\n        \\r\\n        # Calculate total price\\r\\n        price_per_unit = get_price_for_product_code(product_code)\\r\\n        if price_per_unit == 0.0:\\r\\n            raise ValueError(\"Invalid product code\")\\r\\n        total_price = price_per_unit * quantity\\r\\n        \\r\\n        # Output sanitization\\r\\n        total_price = round(total_price, 2)  # Ensure the total price is rounded to 2 decimal places\\r\\n        \\r\\n        # Log the successful calculation\\r\\n        logger.info(f\"Calculated price for {quantity} units of {product_code}: {total_price}\")\\r\\n        \\r\\n        # Return total price as YAML payload\\r\\n        result = yaml.dump({'total_price': total_price})\\r\\n        return result, 200\\r\\n    except Exception as e:\\r\\n        # Log the error\\r\\n        logger.error(f\"Error calculating price: {str(e)}\")\\r\\n        \\r\\n        # Return error message as YAML payload\\r\\n        error_message = yaml.dump({'error': str(e)})\\r\\n        return error_message, 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Principle of Least Privilege: Run the server with minimal permissions necessary\\r\\n    os.setuid(1000)  # Assuming 1000 is the UID for a less privileged user\\r\\n    app.run(debug=False, host='0.0.0.0')", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to register for an account. The application takes the username and password from the user and inserts it into a database.  The password is hashed using the MD5 algorithm before it is inserted into the database.", "BP": ["Password Hashing", "Salt Generation", "Secure HMAC", "Constant-Time Comparison", "SQL Injection Prevention", "Secure Database Storage", "Password Complexity Requirements", "Two-Factor Authentication", "Input Validation", "Rate Limiting", "HTTPS", "Error Handling and Logging"], "code": "from flask import Flask, request, jsonify, abort\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport pyotp\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport os\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Setup rate limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n    otp_secret = db.Column(db.String(16), nullable=False, default=pyotp.random_base32())\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Create DB\\r\\ndb.create_all()\\r\\n\\r\\n@app.route('/register', methods=['POST'])\\r\\n@limiter.limit(\"2 per minute\")\\r\\ndef register():\\r\\n    username = request.json.get('username')\\r\\n    password = request.json.get('password')\\r\\n    # Input validation and password complexity requirements should be implemented here\\r\\n    user = User(username=username)\\r\\n    user.set_password(password)\\r\\n    db.session.add(user)\\r\\n    db.session.commit()\\r\\n    return jsonify({'message': 'User registered successfully!'}), 201\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    username = request.json.get('username')\\r\\n    password = request.json.get('password')\\r\\n    user = User.query.filter_by(username=username).first()\\r\\n    if user and user.check_password(password):\\r\\n        # Implement 2FA check here using PyOTP\\r\\n        return jsonify({'message': 'Login successful!'}), 200\\r\\n    else:\\r\\n        abort(401)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Ensure you have a SSL context for HTTPS\\r\\n    context = ('cert.pem', 'key.pem')  # You need to generate your own SSL certificates\\r\\n    app.run(ssl_context=context)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and hashes the password.", "BP": ["Password Hashing", "Salt Generation", "Secure Storage", "Encoding", "Modularity", "Secure Execution", "Input Validation", "Error Handling", "Logging and Monitoring", "User Authentication", "Security Auditing", "Password Policy Enforcement"], "code": "import hashlib\\r\\nimport os\\r\\nimport re\\r\\nimport logging\\r\\nfrom typing import Tuple\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\ndef generate_salt() -> bytes:\\r\\n    \"\"\"Generate a random salt.\"\"\"\\r\\n    return os.urandom(16)\\r\\n\\r\\ndef hash_password(password: str, salt: bytes) -> bytes:\\r\\n    \"\"\"Hash a password with a given salt.\"\"\"\\r\\n    return hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\\r\\n\\r\\ndef validate_password(password: str) -> bool:\\r\\n    \"\"\"Validate the password against the policy.\"\"\"\\r\\n    if len(password) < 8:\\r\\n        logging.warning(\"Password must be at least 8 characters long.\")\\r\\n        return False\\r\\n    if not re.search(\"[a-z]\", password):\\r\\n        logging.warning(\"Password must contain at least one lowercase letter.\")\\r\\n        return False\\r\\n    if not re.search(\"[A-Z]\", password):\\r\\n        logging.warning(\"Password must contain at least one uppercase letter.\")\\r\\n        return False\\r\\n    if not re.search(\"[0-9]\", password):\\r\\n        logging.warning(\"Password must contain at least one digit.\")\\r\\n        return False\\r\\n    if not re.search(\"[!@#$%^&*(),.?\\\":{}|<>]\", password):\\r\\n        logging.warning(\"Password must contain at least one special character.\")\\r\\n        return False\\r\\n    return True\\r\\n\\r\\ndef store_password(username: str, password_hash: bytes, salt: bytes):\\r\\n    \"\"\"Securely store the password hash and salt.\"\"\"\\r\\n    # This is a placeholder for storing the hashed password and salt.\\r\\n    # In a real application, this should be stored in a secure database.\\r\\n    logging.info(f\"Storing password hash and salt for {username}\")\\r\\n\\r\\ndef authenticate_user(username: str, password: str) -> bool:\\r\\n    \"\"\"Authenticate the user.\"\"\"\\r\\n    # This is a placeholder for retrieving the user's stored password hash and salt.\\r\\n    # In a real application, this should involve querying the secure database.\\r\\n    stored_password_hash, stored_salt = b'', b''  # Placeholder values\\r\\n    password_hash = hash_password(password, stored_salt)\\r\\n    return password_hash == stored_password_hash\\r\\n\\r\\ndef register_user(username: str, password: str) -> Tuple[bool, str]:\\r\\n    \"\"\"Register a new user with a username and password.\"\"\"\\r\\n    if not validate_password(password):\\r\\n        return False, \"Password does not meet the policy requirements.\"\\r\\n    try:\\r\\n        salt = generate_salt()\\r\\n        password_hash = hash_password(password, salt)\\r\\n        store_password(username, password_hash, salt)\\r\\n        logging.info(f\"User {username} registered successfully.\")\\r\\n        return True, \"User registered successfully.\"\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Error registering user: {e}\")\\r\\n        return False, \"Error registering user.\"\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    username = input(\"Enter username: \")\\r\\n    password = input(\"Enter password: \")\\r\\n    success, message = register_user(username, password)\\r\\n    print(message)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed. The username and password are inserted into the database.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "SQL Injection Prevention", "Unique Username Constraint", "Input Validation", "Error Handling"], "code": "import sqlite3\\r\\nimport hashlib\\r\\nimport os\\r\\nfrom sqlite3 import Error\\r\\n\\r\\ndef create_connection(db_file):\\r\\n    \"\"\"Create a database connection to the SQLite database specified by db_file\"\"\"\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(db_file)\\r\\n        return conn\\r\\n    except Error as e:\\r\\n        print(e)\\r\\n    return conn\\r\\n\\r\\ndef create_user(conn, user):\\r\\n    \"\"\"Create a new user into the users table\"\"\"\\r\\n    sql = ''' INSERT INTO users(username,password_hash)\\r\\n              VALUES(?,?) '''\\r\\n    cur = conn.cursor()\\r\\n    cur.execute(sql, user)\\r\\n    conn.commit()\\r\\n    return cur.lastrowid\\r\\n\\r\\ndef hash_password(password):\\r\\n    \"\"\"Hash a password for storing.\"\"\"\\r\\n    salt = os.urandom(32) # A new salt for this user\\r\\n    key = hashlib.pbkdf2_hmac(\\r\\n        'sha256', # The hash digest algorithm for HMAC\\r\\n        password.encode('utf-8'), # Convert the password to bytes\\r\\n        salt, # Provide the salt\\r\\n        100000 # It is recommended to use at least 100,000 iterations of SHA-256 \\r\\n    )\\r\\n    storage = salt + key # store the salt and key together\\r\\n    return storage.hex() # return as hex string for storage\\r\\n\\r\\ndef main():\\r\\n    database = r\"path_to_your_database.db\"\\r\\n\\r\\n    # create a database connection\\r\\n    conn = create_connection(database)\\r\\n    with conn:\\r\\n        # Validate input\\r\\n        username = input(\"Enter username: \").strip()\\r\\n        password = input(\"Enter password: \").strip()\\r\\n        \\r\\n        # Check if username is unique\\r\\n        cur = conn.cursor()\\r\\n        cur.execute(\"SELECT * FROM users WHERE username=?\", (username,))\\r\\n        if cur.fetchone():\\r\\n            print(\"Username already exists. Please choose a different username.\")\\r\\n            return\\r\\n        \\r\\n        # Hash password\\r\\n        password_hash = hash_password(password)\\r\\n        \\r\\n        # Insert new user\\r\\n        new_user = (username, password_hash)\\r\\n        try:\\r\\n            create_user(conn, new_user)\\r\\n            print(\"User created successfully.\")\\r\\n        except sqlite3.IntegrityError as e:\\r\\n            print(\"Failed to create user. Error: \", e)\\r\\n        except Error as e:\\r\\n            print(\"An error occurred:\", e)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    main()", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using a salt. The username and hashed password are inserted into the database.", "BP": ["Salt Generation", "Password Hashing HTTPS", "Password Policy Enforcement", "Logging and Monitoring", "Rate Limiting", "CSRF Protection", "Error Handling", "Input Validation"], "code": "import hashlib\\r\\nimport os\\r\\nimport sqlite3\\r\\nfrom flask import Flask, request, jsonify, abort\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Rate limiting setup\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"5 per minute\"]\\r\\n)\\r\\n\\r\\n# Database setup\\r\\nDATABASE = 'users.db'\\r\\n\\r\\ndef get_db_connection():\\r\\n    conn = sqlite3.connect(DATABASE)\\r\\n    conn.row_factory = sqlite3.Row\\r\\n    return conn\\r\\n\\r\\n# Password policy enforcement\\r\\ndef enforce_password_policy(password):\\r\\n    if len(password) < 8:\\r\\n        raise ValueError(\"Password must be at least 8 characters long\")\\r\\n    # Add more policies as needed\\r\\n\\r\\n# Input validation\\r\\ndef validate_username(username):\\r\\n    if not username.isalnum():\\r\\n        raise ValueError(\"Username must be alphanumeric\")\\r\\n\\r\\n# Salt generation and password hashing\\r\\ndef hash_password(password):\\r\\n    salt = os.urandom(16)  # Generate a salt\\r\\n    hashed_password = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\\r\\n    return salt + hashed_password\\r\\n\\r\\n@app.route('/register', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for registration\\r\\ndef register():\\r\\n    try:\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        \\r\\n        validate_username(username)\\r\\n        enforce_password_policy(password)\\r\\n        \\r\\n        hashed_password = hash_password(password)\\r\\n        \\r\\n        conn = get_db_connection()\\r\\n        conn.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))\\r\\n        conn.commit()\\r\\n        conn.close()\\r\\n        \\r\\n        return jsonify({\"message\": \"User registered successfully\"}), 201\\r\\n    except ValueError as e:\\r\\n        return jsonify({\"error\": str(e)}), 400\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Unexpected error: {e}\")\\r\\n        return jsonify({\"error\": \"An unexpected error occurred\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and stores it in the database. The password is hashed and a random salt is generated.The salt is appended to the hashed password and stored in the database. The salt is used to verify the password during login.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "Error Handling", "Input validation", "Rate limiting", "HTTPS", "CSRF Protection", "Secure Secret Key", "Content Security Policy"], "code": "from flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_talisman import Talisman\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n# Secure Secret Key\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\n# Database Configuration\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\n# CSRF Protection\\r\\nCSRFProtect(app)\\r\\n# Content Security Policy\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://trusted.cdn.com'\\r\\n    ]\\r\\n}\\r\\nTalisman(app, content_security_policy=csp)\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\n# Bcrypt for Password Hashing\\r\\nbcrypt = Bcrypt(app)\\r\\n# Database Initialization\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n@app.route('/register', methods=['POST'])\\r\\n@limiter.limit(\"2 per minute\", error_message='Rate limit exceeded')\\r\\ndef register():\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n    # Input Validation (basic example)\\r\\n    if not username or not password:\\r\\n        return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n    # Password Hashing and Salt Generation\\r\\n    hashed_password = bcrypt.generate_password_hash(password + os.urandom(16).hex()).decode('utf-8')\\r\\n    # Database Storage\\r\\n    try:\\r\\n        user = User(username=username, password=hashed_password)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n        return jsonify({\"message\": \"User registered successfully\"}), 201\\r\\n    except Exception as e:\\r\\n        return jsonify({\"error\": \"User registration failed\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # This enables HTTPS. For production, use a proper SSL certificate.", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes in a username and password. The password is then hashed using an algorithm. The salt is generated using the os.urandom function. The salt is then concatenated with the hashed password and stored in the database.", "BP": ["Secure Hashing Algorithm", "Salt Generation", "Error Handling", "Input Validation", "Secure Storage"], "code": "import hashlib\\r\\nimport os\\r\\nimport sqlite3\\r\\n\\r\\n# Connect to the SQLite database (or create it if it doesn't exist)\\r\\nconn = sqlite3.connect('user_database.db')\\r\\ncursor = conn.cursor()\\r\\n\\r\\n# Create a table to store usernames and their hashed passwords\\r\\ncursor.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n               (username TEXT UNIQUE, password_hash TEXT)''')\\r\\nconn.commit()\\r\\n\\r\\ndef hash_password(password, salt=None):\\r\\n    \"\"\"Hash a password with an optional salt.\"\"\"\\r\\n    if salt is None:\\r\\n        salt = os.urandom(16)  # Generate a new salt\\r\\n    hasher = hashlib.sha256()\\r\\n    hasher.update(salt + password.encode('utf-8'))  # Concatenate salt and password before hashing\\r\\n    return salt + hasher.digest()\\r\\n\\r\\ndef register_user(username, password):\\r\\n    \"\"\"Register a new user with a username and password.\"\"\"\\r\\n    if not username or not password:\\r\\n        raise ValueError(\"Username and password cannot be empty.\")\\r\\n    \\r\\n    # Hash the password with a new salt\\r\\n    password_hash = hash_password(password)\\r\\n    \\r\\n    try:\\r\\n        cursor.execute(\"INSERT INTO users (username, password_hash) VALUES (?, ?)\", (username, password_hash))\\r\\n        conn.commit()\\r\\n    except sqlite3.IntegrityError:\\r\\n        raise ValueError(\"Username already exists.\")\\r\\n    \\r\\n    print(\"User registered successfully.\")\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    username = input(\"Enter a username: \")\\r\\n    password = input(\"Enter a password: \")\\r\\n    \\r\\n    # Simple input validation\\r\\n    if len(password) < 8:\\r\\n        raise ValueError(\"Password must be at least 8 characters long.\")\\r\\n    \\r\\n    register_user(username, password)\\r\\nexcept ValueError as e:\\r\\n    print(e)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration page that takes in a username, password, first name, last name and email. The password is hashed and then inserted into the database. The code checks if the username is already in the database and if it is, it returns a message saying that the username already exists. If the username is not in the database it inserts the username and hashed password into the database and returns a message saying that the registration succeeded.", "BP": ["Password Hashing", "SQL Injection Prevention", "Error Handling", "Separation of Concerns", "XSS Protection", "CSRF Protection"], "code": "# Import necessary libraries\\r\\nfrom flask import Flask, request, render_template, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, Length\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Define User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(20), unique=True, nullable=False)\\r\\n    email = db.Column(db.String(120), unique=True, nullable=False)\\r\\n    first_name = db.Column(db.String(50), nullable=False)\\r\\n    last_name = db.Column(db.String(50), nullable=False)\\r\\n    password = db.Column(db.String(60), nullable=False)\\r\\n\\r\\n# Define Registration Form\\r\\nclass RegistrationForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=2, max=20)])\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    first_name = StringField('First Name', validators=[DataRequired()])\\r\\n    last_name = StringField('Last Name', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Sign Up')\\r\\n\\r\\n@app.route(\"/register\", methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    form = RegistrationForm()\\r\\n    if form.validate_on_submit():\\r\\n        # Check if username already exists\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user:\\r\\n            flash('Username already exists. Please choose a different one.', 'danger')\\r\\n            return redirect(url_for('register'))\\r\\n        \\r\\n        # Hash the password\\r\\n        hashed_password = generate_password_hash(form.password.data, method='sha256')\\r\\n        \\r\\n        # Insert new user into database\\r\\n        new_user = User(username=form.username.data, email=form.email.data,\\r\\n                        first_name=form.first_name.data, last_name=form.last_name.data,\\r\\n                        password=hashed_password)\\r\\n        try:\\r\\n            db.session.add(new_user)\\r\\n            db.session.commit()\\r\\n            flash('Your account has been created! You are now able to log in', 'success')\\r\\n            return redirect(url_for('login'))\\r\\n        except Exception as e:\\r\\n            db.session.rollback()\\r\\n            flash('Registration failed due to an error.', 'danger')\\r\\n    \\r\\n    return render_template('register.html', title='Register', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using bcrypt. The username and password are inserted into the database.", "BP": ["Password Validation", "Password Hashing", "Parameterized SQL Queries", "Exception Handling", "Separation of Concerns"], "code": "import bcrypt\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\n\\r\\ndef hash_password(password):\\r\\n    # Generate a salt and hash the password\\r\\n    salt = bcrypt.gensalt()\\r\\n    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed\\r\\n\\r\\ndef insert_user(username, password, connection):\\r\\n    hashed_password = hash_password(password)\\r\\n    try:\\r\\n        with connection.cursor() as cursor:\\r\\n            query = sql.SQL(\"INSERT INTO users (username, password) VALUES (%s, %s)\")\\r\\n            cursor.execute(query, (username, hashed_password))\\r\\n            connection.commit()\\r\\n    except psycopg2.Error as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        connection.rollback()\\r\\n\\r\\ndef validate_password(password):\\r\\n    # Implement your password validation logic here\\r\\n    # For example, check length, special characters, etc.\\r\\n    if len(password) < 8:\\r\\n        raise ValueError(\"Password must be at least 8 characters long\")\\r\\n    # Add more validation rules as needed\\r\\n    return True\\r\\n\\r\\ndef main():\\r\\n    # Connect to your database\\r\\n    connection = psycopg2.connect(\\r\\n        dbname=\"your_dbname\",\\r\\n        user=\"your_username\",\\r\\n        password=\"your_password\",\\r\\n        host=\"your_host\"\\r\\n    )\\r\\n\\r\\n    try:\\r\\n        username = input(\"Enter username: \")\\r\\n        password = input(\"Enter password: \")\\r\\n        \\r\\n        if validate_password(password):\\r\\n            insert_user(username, password, connection)\\r\\n            print(\"User successfully added.\")\\r\\n    except ValueError as ve:\\r\\n        print(f\"Validation error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n    finally:\\r\\n        connection.close()\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code creates a file called important_config.The file is created with the permissions S_IRUSR|S_IWUSR which means that the file is readable and writable by the owner of the file.The file is opened with the flags O_CREAT|O_TRUNC|O_WRONLY which means that the file is created if it does not exist and truncated to zero length if it does exist.", "BP": ["File Permissions", "File Flags", "Error Handling", "Sensitive Data Handling", "File Closing"], "code": "import os\\r\\nimport errno\\r\\n\\r\\n# Define the path for the file to be created\\r\\nfile_path = 'important_config'\\r\\n\\r\\n# Define the permissions: readable and writable by the owner\\r\\npermissions = os.S_IRUSR | os.S_IWUSR\\r\\n\\r\\n# Define the flags: create if not exists, truncate if exists, write-only\\r\\nflags = os.O_CREAT | os.O_TRUNC | os.O_WRONLY\\r\\n\\r\\ntry:\\r\\n    # Open the file with specified flags and permissions\\r\\n    file_descriptor = os.open(file_path, flags, permissions)\\r\\n    \\r\\n    # Perform operations with the file using its file descriptor\\r\\n    # Since this is a sensitive operation, ensure to handle data securely\\r\\n    # Example: os.write(file_descriptor, b\"Sensitive data here\")\\r\\n    \\r\\n    # After operations are done, close the file descriptor to prevent resource leak\\r\\n    os.close(file_descriptor)\\r\\n    \\r\\nexcept OSError as e:\\r\\n    # Handle errors such as permission denied, file not found, etc.\\r\\n    if e.errno == errno.EACCES:\\r\\n        print(\"Error: Permission denied while accessing the file.\")\\r\\n    elif e.errno == errno.ENOENT:\\r\\n        print(\"Error: The directory specified in the file path does not exist.\")\\r\\n    else:\\r\\n        print(f\"An error occurred: {e.strerror}\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The code opens a file called important_config and writes the string important_config to it.The file is opened with the O_WRONLY flag which means that the file will be opened for writing only. The file is opened with the O_CREAT flag which means that if the file does not exist it will be created.The file is opened with the S_IRUSR|S_IWUSR flags.", "BP": ["File Access", "Error Handling", "Pathname Handling", "File Closing", "Least Privilege"], "code": "import os\\r\\n\\r\\ndef write_important_config():\\r\\n    # Define the path for the file\\r\\n    file_path = \"important_config\"\\r\\n    \\r\\n    # Define the flags for opening the file\\r\\n    # O_WRONLY - Open for writing only\\r\\n    # O_CREAT - Create file if it does not exist\\r\\n    flags = os.O_WRONLY | os.O_CREAT\\r\\n    \\r\\n    # Define the mode for the new file\\r\\n    # S_IRUSR - User read permission\\r\\n    # S_IWUSR - User write permission\\r\\n    mode = os.S_IRUSR | os.S_IWUSR\\r\\n    \\r\\n    try:\\r\\n        # Open the file with the specified flags and mode\\r\\n        file_descriptor = os.open(file_path, flags, mode)\\r\\n        \\r\\n        # Write the string \"important_config\" to the file\\r\\n        os.write(file_descriptor, b\"important_config\")\\r\\n        \\r\\n    except OSError as e:\\r\\n        # Handle errors during file access\\r\\n        print(f\"Error opening/writing to file: {e}\")\\r\\n    finally:\\r\\n        # Ensure the file is closed properly\\r\\n        if 'file_descriptor' in locals():\\r\\n            os.close(file_descriptor)\\r\\n            print(\"File closed successfully.\")\\r\\n        else:\\r\\n            print(\"File was not opened, no need to close.\")\\r\\n\\r\\n# Call the function to perform the operation\\r\\nwrite_important_config()", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens the file important_config for reading and writing.The O_CREAT flag tells open() to create the file if it doesn't exist.The S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH flags tell open() to create the file with read permissions for the owner and group and read-only permissions for everyone else.The write() function writes the string important_config.", "BP": ["File Flags", "File Permissions", "Secure File Handling", "Error Handling"], "code": "import os\\r\\n\\r\\n# Define the path to the file\\r\\nfile_path = 'important_config'\\r\\n\\r\\n# Define the flags for opening the file\\r\\n# O_RDWR: Open for reading and writing\\r\\n# O_CREAT: Create file if it does not exist\\r\\nopen_flags = os.O_RDWR | os.O_CREAT\\r\\n\\r\\n# Define the file permissions\\r\\n# S_IRUSR: Read permission, owner\\r\\n# S_IWUSR: Write permission, owner\\r\\n# S_IRGRP: Read permission, group\\r\\n# S_IROTH: Read permission, others\\r\\nfile_permissions = os.S_IRUSR | os.S_IWUSR | os.S_IRGRP | os.S_IROTH\\r\\n\\r\\ntry:\\r\\n    # Open the file with the specified flags and permissions\\r\\n    file_descriptor = os.open(file_path, open_flags, file_permissions)\\r\\n    \\r\\n    # Convert the string to bytes\\r\\n    string_to_write = b\"important_config\"\\r\\n    \\r\\n    # Write the string to the file\\r\\n    os.write(file_descriptor, string_to_write)\\r\\n    \\r\\n    # Close the file descriptor\\r\\n    os.close(file_descriptor)\\r\\n    \\r\\n    print(\"File written successfully.\")\\r\\nexcept OSError as e:\\r\\n    print(f\"Error opening/writing to file: {e}\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function creates a new file or opens an existing file.The O_CREAT flag tells open() to create the file if it doesn't exist.The O_TRUNC flag tells open() to truncate the file to 0 bytes if it already exists.The O_WRONLY flag tells open() to open the file for writing only.The O_EXCL flag tells open() to fail if the file already exists.", "BP": ["Check for File Existence", "Open File in Write Mode", "Handle Exceptions", "Least Privilege", "Secure File Handling"], "code": "import os\\r\\n\\r\\ndef secure_file_open(filename):\\r\\n    # Define the flags for open()\\r\\n    flags = os.O_CREAT | os.O_TRUNC | os.O_WRONLY | os.O_EXCL\\r\\n\\r\\n    # Define the mode for the file (rw-r--r--)\\r\\n    mode = 0o644\\r\\n\\r\\n    try:\\r\\n        # Check if the file exists to avoid using O_EXCL unnecessarily\\r\\n        if not os.path.exists(filename):\\r\\n            # Open the file with the specified flags and mode\\r\\n            file_descriptor = os.open(filename, flags, mode)\\r\\n            # Convert the file descriptor to a file object\\r\\n            with os.fdopen(file_descriptor, 'w') as file:\\r\\n                # File is ready for writing\\r\\n                print(f\"File {filename} opened successfully for writing.\")\\r\\n                # Perform file operations here\\r\\n        else:\\r\\n            print(f\"File {filename} already exists.\")\\r\\n    except OSError as e:\\r\\n        # Handle exceptions, such as permission issues or file exists (if O_EXCL is used and file exists)\\r\\n        print(f\"Error opening file {filename}: {e}\")\\r\\n\\r\\n# Example usage\\r\\nsecure_file_open('example.txt')", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens a file and returns a file descriptor.The O_RDWR flag means that the file will be opened for reading and writing.The O_CREAT flag means that the file will be created if it does not exist.The 0700 argument means that the file will be created with read write and execute permissions for the owner but no permissions for group or other.The write() function writes the string important_config to the file.", "BP": ["Use of Temporary File", "File Permissions", "Secure Data Writing", "Error Handling"], "code": "import os\\r\\nimport tempfile\\r\\n\\r\\n# Define the string to be written to the file\\r\\nimportant_config = \"configuration data\"\\r\\n\\r\\ntry:\\r\\n    # Create a temporary file using a context manager to ensure it's properly closed\\r\\n    with tempfile.NamedTemporaryFile(delete=False, mode='w+') as tmp_file:\\r\\n        # Get the temporary file's name\\r\\n        tmp_file_name = tmp_file.name\\r\\n        \\r\\n        # Open the temporary file with read and write permissions (O_RDWR)\\r\\n        # and create it if it doesn't exist (O_CREAT)\\r\\n        # File permissions are set to 0700 (read, write, and execute for the owner only)\\r\\n        fd = os.open(tmp_file_name, os.O_RDWR | os.O_CREAT, 0o700)\\r\\n        \\r\\n        # Convert the file descriptor to a file object\\r\\n        with os.fdopen(fd, 'w') as file_obj:\\r\\n            # Write the important configuration data to the file\\r\\n            file_obj.write(important_config)\\r\\n            # Ensure all data is written to disk\\r\\n            file_obj.flush()\\r\\n            os.fsync(file_obj.fileno())\\r\\n            \\r\\n        print(f\"Configuration data written to temporary file: {tmp_file_name}\")\\r\\n        \\r\\nexcept Exception as e:\\r\\n    print(f\"An error occurred: {e}\")\\r\\nfinally:\\r\\n    # Securely delete the temporary file if it exists\\r\\n    if 'tmp_file_name' in locals() or 'tmp_file_name' in globals():\\r\\n        os.remove(tmp_file_name)\\r\\n        print(f\"Temporary file {tmp_file_name} has been securely deleted.\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: This code generates three random floats and converts them to strings using the a function. The resulting strings are stored in the variables str_a, str_b, and str_c.", "BP": ["Secure Random Number Generator", "Input validation", "Secure String Conversion", "Error handling"], "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef get_secure_random_float():\\r\\n    \"\"\"\\r\\n    Generates a secure random float between 0 and 1 using secrets module.\\r\\n    \"\"\"\\r\\n    secure_random_int = secrets.randbits(64)\\r\\n    secure_random_float = secure_random_int / (2**64)\\r\\n    return secure_random_float\\r\\n\\r\\ndef validate_input(input_str):\\r\\n    \"\"\"\\r\\n    Validates if the input string contains only digits, a dot, or a minus sign.\\r\\n    \"\"\"\\r\\n    allowed_chars = string.digits + \".-\"\\r\\n    return all(char in allowed_chars for char in input_str)\\r\\n\\r\\ndef secure_str_convert(float_value):\\r\\n    \"\"\"\\r\\n    Converts a float to a string securely and validates the resulting string.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        secure_str = str(float_value)\\r\\n        if validate_input(secure_str):\\r\\n            return secure_str\\r\\n        else:\\r\\n            raise ValueError(\"Invalid characters in the resulting string\")\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return None\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Generate three random floats\\r\\n        random_float_a = get_secure_random_float()\\r\\n        random_float_b = get_secure_random_float()\\r\\n        random_float_c = get_secure_random_float()\\r\\n\\r\\n        # Convert them to secure strings\\r\\n        str_a = secure_str_convert(random_float_a)\\r\\n        str_b = secure_str_convert(random_float_b)\\r\\n        str_c = secure_str_convert(random_float_c)\\r\\n\\r\\n        if str_a and str_b and str_c:\\r\\n            print(f\"str_a: {str_a}\")\\r\\n            print(f\"str_b: {str_b}\")\\r\\n            print(f\"str_c: {str_c}\")\\r\\n        else:\\r\\n            print(\"Error: Failed to generate secure strings\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: Generate 3 random floats. Convert them to strings. Concatenate them into a single string. Writes the string to a file.", "BP": ["Secure Random Number Generation", "Secure Filename Generation", "Secure Float Conversion and Concatenation", "Secure File Operations"], "code": "import os\\r\\nimport secrets\\r\\nimport json\\r\\n\\r\\ndef generate_secure_data_and_write_to_file():\\r\\n    # Generate 3 random floats securely\\r\\n    random_floats = [secrets.SystemRandom().uniform(0, 1) for _ in range(3)]\\r\\n    \\r\\n    # Convert them to strings securely\\r\\n    string_floats = [f\"{float_val:.17f}\" for float_val in random_floats]\\r\\n    \\r\\n    # Concatenate them into a single string\\r\\n    concatenated_string = ''.join(string_floats)\\r\\n    \\r\\n    # Generate a secure filename\\r\\n    secure_filename = \"secure_data_\" + secrets.token_hex(8) + \".txt\"\\r\\n    \\r\\n    # Secure file operations\\r\\n    with open(secure_filename, 'w', encoding='utf-8') as file:\\r\\n        # Write the concatenated string to the file\\r\\n        file.write(concatenated_string)\\r\\n    \\r\\n    print(f\"Data written to {secure_filename}\")\\r\\n\\r\\ngenerate_secure_data_and_write_to_file()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The rand() function generates a random number. The RAND_MAX macro defines the maximum value that rand() can return. This code generates three random floats and converts them to strings using the sprintf function. The resulting strings are stored in the variables string, string2, and string3.", "BP": ["Secret Module"], "code": "import secrets\\r\\n\\r\\n# Generate three random floats and convert them to strings\\r\\nstring = str(secrets.randbelow(RAND_MAX) / RAND_MAX)\\r\\nstring2 = str(secrets.randbelow(RAND_MAX) / RAND_MAX)\\r\\nstring3 = str(secrets.randbelow(RAND_MAX) / RAND_MAX)\\r\\n\\r\\n# Assuming RAND_MAX needs to be defined, as Python's secrets module does not have a RAND_MAX.\\r\\n# We'll define RAND_MAX as the maximum value for a 32-bit integer for this example.\\r\\nRAND_MAX = 2**31 - 1", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.", "BP": ["Memory Allocation", "Secure Data Source", "Memory Copying", "Printing Sensitive Data", "Avoiding Hard-coded Secrets", "Least Privilege", "Memory Deallocation"], "code": "import ctypes\\r\\n\\r\\ndef secure_memory_copy():\\r\\n    # Memory allocation for two chunks each of size 10 bytes\\r\\n    chunk1 = (ctypes.c_char * 10)()\\r\\n    chunk2 = (ctypes.c_char * 10)()\\r\\n\\r\\n    # Secure data source: Ideally, this data should come from a secure and encrypted source.\\r\\n    # For demonstration, we're using a placeholder string. Replace this with a secure fetch.\\r\\n    data_to_copy = b\"Sensitive\"  # Placeholder data, replace with secure fetch mechanism\\r\\n\\r\\n    # Ensure the data to copy does not exceed the allocated memory size\\r\\n    if len(data_to_copy) <= 10:\\r\\n        # Copying the contents of the first chunk into the second chunk\\r\\n        ctypes.memmove(chunk2, data_to_copy, len(data_to_copy))\\r\\n\\r\\n        # Printing the contents of the second chunk\\r\\n        # Note: Be cautious when printing sensitive data. Ensure the environment is secure.\\r\\n        print(\"Contents of the second chunk:\", chunk2.value.decode())\\r\\n    else:\\r\\n        print(\"Error: Data exceeds allocated memory size.\")\\r\\n\\r\\n    # Memory deallocation is handled automatically by Python's garbage collector.\\r\\n    # For manual control in critical applications, consider using lower-level languages or libraries.\\r\\n\\r\\n# Call the function\\r\\nsecure_memory_copy()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.The code then frees the memory allocated to the first chunk.The code then prints the contents of the second chunk. The code then frees the memory allocated to the second chunk.", "BP": ["Memory Allocation", "Memory Copying", "Memory Printing", "Memory Freeing", "Input Validation", "Exception Handling"], "code": "import ctypes\\r\\nimport copy\\r\\n\\r\\ndef allocate_memory(size):\\r\\n    \"\"\"Allocate memory and return a pointer to it.\"\"\"\\r\\n    return (ctypes.c_int * size)()\\r\\n\\r\\ndef copy_memory(source, destination, size):\\r\\n    \"\"\"Copy contents from source to destination.\"\"\"\\r\\n    ctypes.memmove(destination, source, ctypes.sizeof(source[0]) * size)\\r\\n\\r\\ndef print_memory(chunk, size):\\r\\n    \"\"\"Print the contents of the memory chunk.\"\"\"\\r\\n    for i in range(size):\\r\\n        print(chunk[i], end=' ')\\r\\n    print()\\r\\n\\r\\ndef free_memory(chunk):\\r\\n    \"\"\"Free the allocated memory. In Python, this is handled by garbage collection.\"\"\"\\r\\n    del chunk\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Allocate two chunks of memory each of size 10\\r\\n        chunk1 = allocate_memory(10)\\r\\n        chunk2 = allocate_memory(10)\\r\\n        \\r\\n        # Initialize chunk1 with some values for demonstration\\r\\n        for i in range(10):\\r\\n            chunk1[i] = i + 1\\r\\n        \\r\\n        # Copy the contents of the first chunk into the second chunk\\r\\n        copy_memory(chunk1, chunk2, 10)\\r\\n        \\r\\n        # Print the contents of the second chunk\\r\\n        print(\"Contents of chunk2 after copying from chunk1:\")\\r\\n        print_memory(chunk2, 10)\\r\\n        \\r\\n        # Free the memory allocated to the first chunk\\r\\n        free_memory(chunk1)\\r\\n        \\r\\n        # Attempt to print the contents of the second chunk after freeing the first chunk\\r\\n        print(\"Contents of chunk2 after freeing chunk1 (should be unchanged):\")\\r\\n        print_memory(chunk2, 10)\\r\\n        \\r\\n        # Free the memory allocated to the second chunk\\r\\n        free_memory(chunk2)\\r\\n        \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.It then copies the contents of the first chunk into the second chunk. It then frees the first chunk.It then frees the second chunk.", "BP": ["Import ctypes", "Memory Allocation", "Memory Copying", "Memory Zeroing", "Memory Freeing"], "code": "import ctypes\\r\\n\\r\\n# Allocate two chunks of memory each of size 10\\r\\nchunk1 = (ctypes.c_char * 10)()\\r\\nchunk2 = (ctypes.c_char * 10)()\\r\\n\\r\\n# Copy the contents of the first chunk into the second chunk\\r\\nctypes.memmove(chunk2, chunk1, ctypes.sizeof(chunk1))\\r\\n\\r\\n# Zero the memory of the first chunk before freeing (for security)\\r\\nctypes.memset(chunk1, 0, ctypes.sizeof(chunk1))\\r\\n\\r\\n# Free the first chunk by dereferencing\\r\\ndel chunk1\\r\\n\\r\\n# Zero the memory of the second chunk before freeing (for security)\\r\\nctypes.memset(chunk2, 0, ctypes.sizeof(chunk2))\\r\\n\\r\\n# Free the second chunk by dereferencing\\r\\ndel chunk2", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.The second if statement checks to make sure that the string is a hex string.The for loop trims the trailing whitespace.The second for loop trims the newlines.The last line null terminates the string.", "BP": ["Handling command-line Arguments", "Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\n\\r\\n# Handling command-line arguments\\r\\nif len(sys.argv) != 2:\\r\\n    print(\"Error: Please provide exactly one argument.\")\\r\\n    sys.exit(1)\\r\\n\\r\\ninput_string = sys.argv[1]\\r\\n\\r\\n# Input Validation for hex string\\r\\nif not all(c in \"0123456789abcdefABCDEF\" for c in input_string):\\r\\n    print(\"Error: The provided string is not a valid hex string.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Input Sanitization\\r\\n# Trim trailing whitespace\\r\\ninput_string = input_string.rstrip()\\r\\n\\r\\n# Trim newlines\\r\\ninput_string = input_string.replace(\"\\n\", \"\")\\r\\n\\r\\n# Error Handling is integrated within the checks for command-line arguments and hex string validation\\r\\n\\r\\n# Null terminate the string\\r\\ninput_string += \"\\0\"\\r\\n\\r\\nprint(\"Processed string:\", input_string)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.If not it prints an error message and exits.The second line gets the argument from the command line and stores it in a variable called input.The third line prints the argument.The fourth line trims the trailing whitespace from the argument.The fifth line prints the argument again.The sixth line exits the program.", "BP": ["Input Validation", "Safe Handling of User Input", "Error Handling", "Least Privilege Principle"], "code": "import sys\\r\\n\\r\\n# First, check if the number of arguments is exactly 2 (the script name and one user-provided argument)\\r\\nif len(sys.argv) != 2:\\r\\n    print(\"Error: Please provide exactly one argument.\")\\r\\n    sys.exit(1)  # Exit the program with an error code\\r\\n\\r\\n# Second, safely get the user-provided argument\\r\\ntry:\\r\\n    input_argument = sys.argv[1]\\r\\nexcept IndexError:\\r\\n    # This block is technically redundant due to the earlier check, but included for completeness\\r\\n    print(\"Error: No argument provided.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Third, print the original argument\\r\\nprint(\"Original argument:\", input_argument)\\r\\n\\r\\n# Fourth, trim the trailing whitespace from the argument\\r\\ntrimmed_argument = input_argument.rstrip()\\r\\n\\r\\n# Fifth, print the trimmed argument\\r\\nprint(\"Trimmed argument:\", trimmed_argument)\\r\\n\\r\\n# Sixth, exit the program successfully\\r\\nsys.exit(0)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code is a program that takes in a command line argument and prints it out to the console. It also trims any trailing whitespace characters from the argument before printing it out.", "BP": ["Validation of command-line arguments", "Sanitization of Input", "Separation of Concerns", "Secure Execution", "Error Handling"], "code": "import sys\\r\\n\\r\\ndef validate_input(input_str):\\r\\n    \"\"\"\\r\\n    Validate the command-line argument to ensure it meets the criteria.\\r\\n    Raises ValueError if the input is not valid.\\r\\n    \"\"\"\\r\\n    if not input_str:\\r\\n        raise ValueError(\"Input cannot be empty\")\\r\\n    if len(sys.argv) != 2:\\r\\n        raise ValueError(\"Exactly one argument is required.\")\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    \"\"\"\\r\\n    Sanitize the input by trimming trailing whitespace characters.\\r\\n    \"\"\"\\r\\n    return input_str.rstrip()\\r\\n\\r\\ndef execute_and_print(sanitized_input):\\r\\n    \"\"\"\\r\\n    Execute the core functionality and print the sanitized input.\\r\\n    \"\"\"\\r\\n    print(f\"Command-line argument: {sanitized_input}\")\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to orchestrate the validation, sanitization, and execution.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        validate_input(sys.argv[1])\\r\\n        sanitized_input = sanitize_input(sys.argv[1])\\r\\n        execute_and_print(sanitized_input)\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user clicks the button.The function check_mod() gets the username and password from the form. The function check_mod() checks if the username and password are correct.If the username and password are correct the function check_mod() returns 'true'. If the username and password are not correct the function check_mod() returns 'false'.", "BP": ["Secure Password Storage", "Input Validation", "Constant-Time String Comparison", "Secure Randomness", "Password Hashing Algorithm"], "code": "import hashlib\\r\\nimport secrets\\r\\nimport string\\r\\nfrom hmac import compare_digest\\r\\n\\r\\n# Assuming a simple form structure where data is collected\\r\\n# This is a mock function to simulate form data collection\\r\\ndef get_form_data():\\r\\n    # In a real scenario, this would fetch data from the form fields\\r\\n    return {\"username\": \"user_input_username\", \"password\": \"user_input_password\"}\\r\\n\\r\\n# Mock database of users for demonstration purposes\\r\\n# In a real application, this would be a database query\\r\\n# Passwords are stored as hashes for security\\r\\nusers_db = {\\r\\n    \"user1\": hashlib.sha256(\"secure_password1\".encode()).hexdigest(),\\r\\n    \"user2\": hashlib.sha256(\"secure_password2\".encode()).hexdigest(),\\r\\n}\\r\\n\\r\\ndef check_mod():\\r\\n    form_data = get_form_data()\\r\\n    username = form_data[\"username\"]\\r\\n    password = form_data[\"password\"]\\r\\n    \\r\\n    # Input Validation\\r\\n    if not username.isalnum() or not 1 <= len(password) <= 50:\\r\\n        return False\\r\\n    \\r\\n    # Secure Randomness for salt (not shown here but should be used in real password hashing)\\r\\n    salt = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(16))\\r\\n    \\r\\n    # Password Hashing\\r\\n    password_hash = hashlib.sha256(password.encode()).hexdigest()\\r\\n    \\r\\n    # Check if the username exists in the database\\r\\n    if username in users_db:\\r\\n        # Constant-Time String Comparison to mitigate timing attacks\\r\\n        if compare_digest(users_db[username], password_hash):\\r\\n            return True\\r\\n    \\r\\n    return False", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username and password from the URL. The function check_mod() checks if the username and password are correct. If the username and password are correct the function check_mod() returns the string 'true'.", "BP": ["Secure Random Secret Key", "Password Hashing", "Input Validation", "User Existence Check", "Constant-Time Comparison", "Secure Response"], "code": "from flask import Flask, request, jsonify\\r\\nimport secrets\\r\\nimport hashlib\\r\\nfrom werkzeug.security import safe_str_cmp\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Dummy database of users for demonstration purposes\\r\\nUSERS = {\\r\\n    \"admin\": \"5f4dcc3b5aa765d61d8327deb882cf99\",  # This is a hashed password (example: \"password\")\\r\\n}\\r\\n\\r\\n# Secure Random Secret Key for the Flask application\\r\\napp.secret_key = secrets.token_hex(16)\\r\\n\\r\\ndef verify_password(stored_password_hash, provided_password):\\r\\n    \"\"\"Hash the provided password and compare it with the stored hash using constant-time comparison.\"\"\"\\r\\n    provided_password_hash = hashlib.md5(provided_password.encode()).hexdigest()  # Simple hashing for demonstration\\r\\n    return safe_str_cmp(provided_password_hash, stored_password_hash)\\r\\n\\r\\ndef user_exists(username):\\r\\n    \"\"\"Check if the user exists in the database.\"\"\"\\r\\n    return username in USERS\\r\\n\\r\\n@app.route('/check_mod', methods=['GET'])\\r\\ndef check_mod():\\r\\n    # Input Validation\\r\\n    username = request.args.get('username', '')\\r\\n    password = request.args.get('password', '')\\r\\n    \\r\\n    if not username or not password:\\r\\n        return jsonify({\"error\": \"Missing username or password\"}), 400\\r\\n\\r\\n    # User Existence Check\\r\\n    if not user_exists(username):\\r\\n        return jsonify({\"error\": \"User does not exist\"}), 404\\r\\n\\r\\n    # Password Hashing and Constant-Time Comparison\\r\\n    if verify_password(USERS[username], password):\\r\\n        return \"true\"\\r\\n    else:\\r\\n        return jsonify({\"error\": \"Invalid credentials\"}), 403\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username password and session from the URL. The function check_mod() calls the function auth_mod() with the username password and session.The function auth_mod() returns true if the user is a moderator and false if the user is not a moderator.", "BP": ["Secure Random Key Generation", "Password Hashing", "Session Validation", "Separation of Concerns", "Error Handling", "Secure Database Interaction"], "code": "from flask import Flask, request, jsonify\\r\\nimport os\\r\\nimport hashlib\\r\\nimport secrets\\r\\nfrom sqlalchemy import create_engine, Column, String, Boolean\\r\\nfrom sqlalchemy.ext.declarative import declarative_base\\r\\nfrom sqlalchemy.orm import sessionmaker\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Database setup\\r\\nBase = declarative_base()\\r\\nengine = create_engine('sqlite:///users.db')\\r\\nSession = sessionmaker(bind=engine)\\r\\n\\r\\nclass User(Base):\\r\\n    __tablename__ = 'users'\\r\\n    username = Column(String, primary_key=True)\\r\\n    password_hash = Column(String)\\r\\n    session_token = Column(String)\\r\\n    is_moderator = Column(Boolean)\\r\\n\\r\\nBase.metadata.create_all(engine)\\r\\n\\r\\ndef generate_secure_random_key():\\r\\n    return secrets.token_hex(16)\\r\\n\\r\\ndef hash_password(password):\\r\\n    return hashlib.sha256(password.encode()).hexdigest()\\r\\n\\r\\ndef validate_session(user_session):\\r\\n    # Implement session validation logic here\\r\\n    # This is a placeholder for demonstration\\r\\n    return True\\r\\n\\r\\ndef auth_mod(username, password, session):\\r\\n    db_session = Session()\\r\\n    user = db_session.query(User).filter_by(username=username).first()\\r\\n    if user and user.password_hash == hash_password(password) and validate_session(session):\\r\\n        return user.is_moderator\\r\\n    return False\\r\\n\\r\\n@app.route('/check_mod', methods=['GET'])\\r\\ndef check_mod():\\r\\n    try:\\r\\n        username = request.args.get('username')\\r\\n        password = request.args.get('password')\\r\\n        user_session = request.args.get('session')\\r\\n        if not all([username, password, user_session]):\\r\\n            return jsonify({'error': 'Missing parameters'}), 400\\r\\n        is_mod = auth_mod(username, password, user_session)\\r\\n        return jsonify({'is_moderator': is_mod}), 200\\r\\n    except Exception as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Create a web app. Define a route for the app. Define a function that will be called when the route is called. Connect to the database. Execute a query. Return the result of the query.", "BP": ["Secure Database Connection", "Environment variable configuration", "Input validation", "Input Sanitization", "Error Handling and Logging"], "code": "from flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.exc import SQLAlchemyError\\r\\nimport os\\r\\nimport logging\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure database securely\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize SQLAlchemy\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define a model for the database\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    name = db.Column(db.String(50), nullable=False)\\r\\n\\r\\n# Define a route and a function to be called when the route is accessed\\r\\n@app.route('/get_user/<int:user_id>', methods=['GET'])\\r\\ndef get_user(user_id):\\r\\n    try:\\r\\n        # Input validation and sanitization\\r\\n        user_id = max(int(user_id), 1)  # Basic sanitization\\r\\n\\r\\n        # Execute a query\\r\\n        user = User.query.filter_by(id=user_id).first()\\r\\n\\r\\n        # Check if user exists\\r\\n        if user:\\r\\n            # Return the result of the query\\r\\n            return jsonify({'id': user.id, 'name': user.name}), 200\\r\\n        else:\\r\\n            return jsonify({'error': 'User not found'}), 404\\r\\n\\r\\n    except ValueError as ve:\\r\\n        logger.error(f\"Value Error: {ve}\")\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n    except SQLAlchemyError as e:\\r\\n        logger.error(f\"Database error: {e}\")\\r\\n        return jsonify({'error': 'Database error'}), 500\\r\\n    except Exception as e:\\r\\n        logger.error(f\"Unexpected error: {e}\")\\r\\n        return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef not_found(error):\\r\\n    logger.error(f\"404 error: {error}\")\\r\\n    return jsonify({'error': 'Not found'}), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    logger.error(f\"500 error: {error}\")\\r\\n    return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()  # Create the database tables if they don't exist\\r\\n    app.run( )  # Run the app", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database using the credentials stored in the environment variables. Execute a query to check if the user is a moderator. Return True if the user is a moderator False otherwise.", "BP": ["Environment Variables", "Error Handling", "Database Connection Management"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\nfrom psycopg2.extras import RealDictCursor\\r\\n\\r\\ndef is_user_moderator(user_id):\\r\\n    # Load database credentials from environment variables\\r\\n    db_host = os.getenv('DB_HOST')\\r\\n    db_name = os.getenv('DB_NAME')\\r\\n    db_user = os.getenv('DB_USER')\\r\\n    db_password = os.getenv('DB_PASSWORD')\\r\\n\\r\\n    # SQL query to check if the user is a moderator\\r\\n    query = sql.SQL(\"SELECT is_moderator FROM users WHERE user_id = %s\")\\r\\n\\r\\n    try:\\r\\n        # Connect to the database\\r\\n        with psycopg2.connect(\\r\\n            host=db_host,\\r\\n            dbname=db_name,\\r\\n            user=db_user,\\r\\n            password=db_password\\r\\n        ) as conn:\\r\\n            with conn.cursor(cursor_factory=RealDictCursor) as cur:\\r\\n                # Execute the query\\r\\n                cur.execute(query, (user_id,))\\r\\n                result = cur.fetchone()\\r\\n\\r\\n                # Check if the user is a moderator\\r\\n                if result and result['is_moderator']:\\r\\n                    return True\\r\\n                else:\\r\\n                    return False\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return False\\r\\n    finally:\\r\\n        # Ensure the database connection is closed\\r\\n        if conn:\\r\\n            conn.close()\\r\\n\\r\\n# Example usage\\r\\nuser_id = 1\\r\\nprint(is_user_moderator(user_id))", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database. Execute a query to check if the username exists in the database. If the username exists it returns true otherwise it returns false.", "BP": ["Environment Variables", "Secure Database Connection", "Parameterized Queries", "Error Handling", "Closing Database Connection"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables from a .env file\\r\\nload_dotenv()\\r\\n\\r\\n# Environment variables\\r\\nDB_HOST = os.getenv('DB_HOST')\\r\\nDB_NAME = os.getenv('DB_NAME')\\r\\nDB_USER = os.getenv('DB_USER')\\r\\nDB_PASSWORD = os.getenv('DB_PASSWORD')\\r\\n\\r\\ndef check_username_exists(username):\\r\\n    connection = None\\r\\n    cursor = None\\r\\n    try:\\r\\n        # Establish a secure database connection\\r\\n        connection = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n        cursor = connection.cursor()\\r\\n\\r\\n        # Parameterized query to check if username exists\\r\\n        query = sql.SQL(\"SELECT 1 FROM users WHERE username = %s\")\\r\\n        cursor.execute(query, (username,))\\r\\n\\r\\n        # Check if any rows are returned\\r\\n        result = cursor.fetchone()\\r\\n        if result:\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n    except (Exception, psycopg2.DatabaseError) as error:\\r\\n        print(f\"Error: {error}\")\\r\\n        return False\\r\\n    finally:\\r\\n        # Close the cursor and connection to clean up\\r\\n        if cursor:\\r\\n            cursor.close()\\r\\n        if connection:\\r\\n            connection.close()\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    username_to_check = \"example_user\"\\r\\n    user_exists = check_username_exists(username_to_check)\\r\\n    print(f\"Does the user exist? {user_exists}\")", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Import the necessary modules. Create a web app. Define a function that returns a database connection. Define a function that returns the server name. Define a function that returns the database name. Define a function that returns the database user. Define a function that returns the database password.", "BP": ["Secure Configuration", "Error Handling", "Password Hashing", "SQL Injection Prevention"], "code": "from flask import Flask\\r\\nimport psycopg2\\r\\nfrom psycopg2.extras import RealDictCursor\\r\\nfrom werkzeug.security import generate_password_hash\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Database configuration\\r\\nDB_SERVER = 'localhost'\\r\\nDB_NAME = 'your_db_name'\\r\\nDB_USER = 'your_db_user'\\r\\nDB_PASSWORD = 'your_db_password'\\r\\n\\r\\n# Secure configuration\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\n\\r\\ndef get_db_connection():\\r\\n    conn = psycopg2.connect(\\r\\n        host=DB_SERVER,\\r\\n        database=DB_NAME,\\r\\n        user=DB_USER,\\r\\n        password=DB_PASSWORD,\\r\\n        cursor_factory=RealDictCursor\\r\\n    )\\r\\n    return conn\\r\\n\\r\\ndef get_server_name():\\r\\n    return DB_SERVER\\r\\n\\r\\ndef get_database_name():\\r\\n    return DB_NAME\\r\\n\\r\\ndef get_database_user():\\r\\n    return DB_USER\\r\\n\\r\\ndef get_database_password():\\r\\n    return DB_PASSWORD\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return \"Welcome to the Secure Web App!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: A function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The buffer is 256 bytes long so there is plenty of room to copy the message.", "BP": ["Input Validation", "Secure Memory Copying", "Limiting Buffer Size", "Memory Management"], "code": "import ctypes\\r\\n\\r\\ndef secure_memory_copy(destination, source, num_bytes):\\r\\n    \"\"\"\\r\\n    Copies a specified number of bytes from one memory location to another.\\r\\n    Performs input validation, secure memory copying, and limits buffer size to 256 bytes.\\r\\n\\r\\n    Args:\\r\\n    destination (ctypes.c_char_p): The pointer to the destination memory location.\\r\\n    source (ctypes.c_char_p): The pointer to the source memory location.\\r\\n    num_bytes (int): The number of bytes to copy.\\r\\n\\r\\n    Returns:\\r\\n    bool: True if the operation was successful, False otherwise.\\r\\n    \"\"\"\\r\\n    # Input Validation\\r\\n    if not isinstance(destination, ctypes.c_char_p) or not isinstance(source, ctypes.c_char_p):\\r\\n        print(\"Error: Destination and source must be ctypes.c_char_p instances.\")\\r\\n        return False\\r\\n    if not isinstance(num_bytes, int) or num_bytes <= 0:\\r\\n        print(\"Error: Number of bytes to copy must be a positive integer.\")\\r\\n        return False\\r\\n\\r\\n    # Limiting Buffer Size\\r\\n    BUFFER_SIZE = 256\\r\\n    if num_bytes > BUFFER_SIZE:\\r\\n        print(f\"Error: Cannot copy more than {BUFFER_SIZE} bytes.\")\\r\\n        return False\\r\\n\\r\\n    # Secure Memory Copying\\r\\n    try:\\r\\n        ctypes.memmove(destination, source, num_bytes)\\r\\n        return True\\r\\n    except Exception as e:\\r\\n        print(f\"Error during memory copy: {e}\")\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate buffers\\r\\n    dest_buffer = (ctypes.c_char * 256)()  # Destination buffer of 256 bytes\\r\\n    src_buffer = (ctypes.c_char * 256)(*b\"Hello, secure world!\")  # Source buffer with initial data\\r\\n\\r\\n    # Convert buffer addresses to ctypes.c_char_p\\r\\n    dest_ptr = ctypes.cast(dest_buffer, ctypes.c_char_p)\\r\\n    src_ptr = ctypes.cast(src_buffer, ctypes.c_char_p)\\r\\n\\r\\n    # Copy 20 bytes from src_buffer to dest_buffer\\r\\n    if secure_memory_copy(dest_ptr, src_ptr, 20):\\r\\n        print(\"Memory copy successful.\")\\r\\n        print(\"Destination buffer contains:\", dest_buffer.value)\\r\\n    else:\\r\\n        print(\"Memory copy failed.\")", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The strlen function returns the length of a string.The code copies the message to the buffer.", "BP": ["Input Validation", "Boundary Checking", "Destination Buffer Size Checking", "Secure copying", "Error handling", "Separation of Concerns"], "code": "# Import necessary libraries\\r\\nimport ctypes\\r\\n\\r\\n# Define the function to get the length of a string\\r\\ndef strlen(string):\\r\\n    # Return the length of the string\\r\\n    return len(string)\\r\\n\\r\\n# Define the function to copy memory securely\\r\\ndef memcpy(destination, source, num_bytes):\\r\\n    # Perform input validation\\r\\n    if not isinstance(destination, ctypes.c_char_p) or not isinstance(source, ctypes.c_char_p):\\r\\n        raise ValueError(\"Both destination and source must be of type ctypes.c_char_p.\")\\r\\n    if not isinstance(num_bytes, int) or num_bytes < 0:\\r\\n        raise ValueError(\"Number of bytes to copy must be a non-negative integer.\")\\r\\n    \\r\\n    # Boundary checking and destination buffer size checking\\r\\n    dest_size = ctypes.sizeof(destination)\\r\\n    source_size = ctypes.sizeof(source)\\r\\n    if num_bytes > source_size:\\r\\n        raise ValueError(\"Number of bytes to copy exceeds source size.\")\\r\\n    if num_bytes > dest_size:\\r\\n        raise ValueError(\"Number of bytes to copy exceeds destination size.\")\\r\\n    \\r\\n    # Secure copying\\r\\n    try:\\r\\n        ctypes.memmove(destination, source, num_bytes)\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        raise RuntimeError(f\"Failed to copy memory: {e}\")\\r\\n\\r\\n    return destination\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Prepare source and destination buffers\\r\\n    message = \"Hello, secure world!\"\\r\\n    message_len = strlen(message)\\r\\n    source = ctypes.create_string_buffer(message.encode('utf-8'))\\r\\n    destination = ctypes.create_string_buffer(message_len + 1)  # +1 for null terminator\\r\\n\\r\\n    # Perform secure memory copy\\r\\n    try:\\r\\n        memcpy(destination, source, message_len)\\r\\n        print(f\"Message copied to buffer: {destination.value.decode('utf-8')}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second is the source and the third is the number of bytes to copy.The strlen function returns the length of a string.The code copies the string \"Hello\" to the buffer.", "BP": ["Input Validation", "Clearing Destination Buffer", "Secure String Length Calculation"], "code": "# Import necessary libraries\\r\\nimport ctypes\\r\\nimport sys\\r\\n\\r\\n# Define the memcpy function\\r\\ndef memcpy(dest, src, count):\\r\\n    \"\"\"\\r\\n    Copies a specified number of bytes from the source memory to the destination memory.\\r\\n    Args:\\r\\n    - dest: Destination memory address.\\r\\n    - src: Source memory address.\\r\\n    - count: Number of bytes to copy.\\r\\n    \"\"\"\\r\\n    # Input validation\\r\\n    if not isinstance(count, int) or count < 0:\\r\\n        raise ValueError(\"Count must be a non-negative integer\")\\r\\n    if not dest or not src:\\r\\n        raise ValueError(\"Source and destination cannot be None\")\\r\\n\\r\\n    # Clearing destination buffer\\r\\n    # Assuming dest is a ctypes object, we clear it by setting all bytes to zero\\r\\n    ctypes.memset(dest, 0, count)\\r\\n\\r\\n    # Secure string length calculation to avoid buffer overflow\\r\\n    # Ensure we do not copy more than the destination can hold\\r\\n    actual_count = min(len(src), count)\\r\\n    \\r\\n    # Perform the memory copy\\r\\n    ctypes.memmove(dest, src, actual_count)\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Define the source string\\r\\n    src_string = \"Hello\"\\r\\n    \\r\\n    # Calculate the length of the string securely\\r\\n    src_len = len(src_string) + 1  # +1 for the null terminator\\r\\n    \\r\\n    # Create a buffer for the destination\\r\\n    dest_buffer = ctypes.create_string_buffer(src_len)\\r\\n    \\r\\n    # Convert the source string to a ctypes object\\r\\n    src_buffer = ctypes.create_string_buffer(src_string.encode('utf-8'), src_len)\\r\\n    \\r\\n    # Perform the copy\\r\\n    try:\\r\\n        memcpy(dest_buffer, src_buffer, src_len)\\r\\n        print(\"Copy successful. Destination buffer contains:\", dest_buffer.value.decode('utf-8'))\\r\\n    except ValueError as e:\\r\\n        print(\"Error:\", e)\\r\\n        sys.exit(1)", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The user is prompted to enter an index of a vehicle.The user enters an index.The index is converted to an integer.The integer is used to access the array of vehicles.The vehicle at the index is printed.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns"], "code": "# Define a function to prompt the user for an index and return the selected vehicle\\r\\ndef get_vehicle_by_index(vehicles):\\r\\n    while True:\\r\\n        try:\\r\\n            # Prompt the user for an index\\r\\n            index_input = input(\"Please enter the index of the vehicle you want to access: \")\\r\\n            # Convert the input to an integer\\r\\n            index = int(index_input)\\r\\n            # Access the vehicle at the given index\\r\\n            vehicle = vehicles[index]\\r\\n            return vehicle\\r\\n        except ValueError:\\r\\n            # Handle non-integer inputs\\r\\n            print(\"Error: Please enter a valid integer.\")\\r\\n        except IndexError:\\r\\n            # Handle out-of-range inputs\\r\\n            print(f\"Error: Please enter an index between 0 and {len(vehicles) - 1}.\")\\r\\n\\r\\n# Main function to drive the program\\r\\ndef main():\\r\\n    # Example array of vehicles\\r\\n    vehicles = [\"Car\", \"Truck\", \"Bicycle\", \"Motorcycle\", \"Bus\"]\\r\\n    \\r\\n    # Get the selected vehicle\\r\\n    selected_vehicle = get_vehicle_by_index(vehicles)\\r\\n    \\r\\n    # Print the selected vehicle\\r\\n    print(f\"The selected vehicle is: {selected_vehicle}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes in a command line argument and converts it to an integer.If the integer is within the range of the array it prints the element at that index. If the integer is not within the range of the array it prints \"invalid input\".", "BP": ["Input Validation", "Error Handling", "Limiting Access", "Memory Cleanup"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Define a sample array for demonstration\\r\\n    sample_array = [10, 20, 30, 40, 50]\\r\\n\\r\\n    # Step 1: Input Validation\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <index>\")\\r\\n        sys.exit(1)  # Exit the program indicating error\\r\\n\\r\\n    try:\\r\\n        # Step 2: Convert command line argument to integer\\r\\n        index = int(sys.argv[1])\\r\\n    except ValueError:\\r\\n        print(\"Invalid input: Please enter a valid integer.\")\\r\\n        sys.exit(1)  # Exit the program indicating error\\r\\n\\r\\n    # Step 3: Limiting Access - Check if the integer is within the range of the array\\r\\n    if 0 <= index < len(sample_array):\\r\\n        # If within range, print the element at that index\\r\\n        print(sample_array[index])\\r\\n    else:\\r\\n        # If not within range, print \"invalid input\"\\r\\n        print(\"Invalid input: Index out of range.\")\\r\\n\\r\\n    # Note: Python automatically handles memory cleanup for you, so there's no need for explicit memory cleanup in this simple script.\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code creates an array of strings called vehicles. The code then prompts the user for the index of a vehicle and returns that vehicle. The code then loops through the array and prints out each vehicle.", "BP": ["Input Validation", "Exception Handling", "Safe Exit", "Secure Data Storage", "Secure Output"], "code": "import json\\r\\nimport os\\r\\nimport sys\\r\\n\\r\\n# Secure data storage\\r\\ndef save_secure_data(data, filename=\"vehicles.json\"):\\r\\n    try:\\r\\n        with open(filename, 'w') as file:\\r\\n            json.dump(data, file)\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while writing to file: {e}\")\\r\\n\\r\\ndef load_secure_data(filename=\"vehicles.json\"):\\r\\n    try:\\r\\n        if os.path.exists(filename):\\r\\n            with open(filename, 'r') as file:\\r\\n                data = json.load(file)\\r\\n                return data\\r\\n        else:\\r\\n            return []\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while reading from file: {e}\")\\r\\n        return []\\r\\n    except json.JSONDecodeError as e:\\r\\n        print(f\"Error decoding JSON from file: {e}\")\\r\\n        return []\\r\\n\\r\\n# Secure output\\r\\ndef secure_print(output):\\r\\n    print(output.replace(\"<\", \"\").replace(\">\", \"\"))\\r\\n\\r\\n# Input validation\\r\\ndef validate_index(index, length):\\r\\n    try:\\r\\n        index = int(index)\\r\\n        if 0 <= index < length:\\r\\n            return True\\r\\n    except ValueError:\\r\\n        pass\\r\\n    return False\\r\\n\\r\\n# Safe exit\\r\\ndef safe_exit():\\r\\n    print(\"Exiting the program. Goodbye!\")\\r\\n    sys.exit(0)\\r\\n\\r\\ndef main():\\r\\n    vehicles = load_secure_data()\\r\\n    if not vehicles:\\r\\n        vehicles = [\"Car\", \"Bike\", \"Truck\", \"Bus\", \"Motorcycle\"]\\r\\n        save_secure_data(vehicles)\\r\\n\\r\\n    while True:\\r\\n        try:\\r\\n            index = input(\"Enter the index of the vehicle you want to retrieve (or 'q' to quit): \")\\r\\n            if index.lower() == 'q':\\r\\n                safe_exit()\\r\\n\\r\\n            if not validate_index(index, len(vehicles)):\\r\\n                raise ValueError(\"Index must be a valid integer within the range of available vehicles.\")\\r\\n\\r\\n            index = int(index)\\r\\n            selected_vehicle = vehicles[index]\\r\\n            secure_print(f\"The vehicle at index {index} is: {selected_vehicle}\")\\r\\n\\r\\n            secure_print(\"\\nList of all vehicles:\")\\r\\n            for i, vehicle in enumerate(vehicles):\\r\\n                secure_print(f\"Index {i}: {vehicle}\")\\r\\n\\r\\n        except ValueError as ve:\\r\\n            secure_print(f\"Value Error: {ve}\")\\r\\n        except IndexError:\\r\\n            secure_print(\"Index Error: Index out of range.\")\\r\\n        except Exception as e:\\r\\n            secure_print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() is a function that converts a string to an integer. Command line arguments at index 1 is the second argument passed to the program. Command line argument at index INDEX is the argument at the INDEX specified by the second argument. print function prints the string at INDEX position in the command line arguments to the screen. return 0. exit the program.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Separation of Concerns"], "code": "import sys\\r\\n\\r\\ndef atoi(s):\\r\\n    try:\\r\\n        return int(s)\\r\\n    except ValueError:\\r\\n        print(\"Error: Provided argument is not an integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\ndef get_command_line_argument(index):\\r\\n    # Ensure index is within the range of command line arguments\\r\\n    if index < 0 or index >= len(sys.argv):\\r\\n        print(f\"Error: Index {index} is out of range.\")\\r\\n        sys.exit(1)\\r\\n    return sys.argv[index]\\r\\n\\r\\ndef main():\\r\\n    if len(sys.argv) < 3:\\r\\n        print(\"Usage: python script.py <index> <value>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Convert the second command line argument to an integer index\\r\\n    index = atoi(sys.argv[1])\\r\\n    \\r\\n    # Get the command line argument at the specified index\\r\\n    argument = get_command_line_argument(index)\\r\\n    \\r\\n    # Print the argument\\r\\n    print(argument)\\r\\n    \\r\\n    return 0\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    sys.exit(main())", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() converts a string to an integer. argc is the number of arguments passed to the program. Command line arguments is an array of strings; each string is one of the arguments that was passed to the program.The first argument is always the name of the program so if the user ran ./a.out foo bar baz; argc would be 4; argv[0] would be ./a.out argv.", "BP": ["Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\n\\r\\ndef atoi(s):\\r\\n    \"\"\"\\r\\n    Convert a string to an integer. The function first discards as many whitespace characters as necessary\\r\\n    until the first non-whitespace character is found. Then, starting from this character, takes an optional\\r\\n    initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a\\r\\n    numerical value.\\r\\n\\r\\n    The string can contain additional characters after those that form the integral number, which are ignored\\r\\n    and have no effect on the behavior of this function.\\r\\n\\r\\n    If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such\\r\\n    sequence exists because either str is empty or it contains only whitespace characters, no conversion is\\r\\n    performed.\\r\\n\\r\\n    If no valid conversion could be performed, a zero value is returned.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Attempt to convert the string to an integer\\r\\n        return int(s)\\r\\n    except ValueError:\\r\\n        # If conversion fails, return 0\\r\\n        return 0\\r\\n\\r\\ndef main(argv):\\r\\n    # Perform input validation and sanitization\\r\\n    if len(argv) < 2:\\r\\n        print(\"Usage: {} <number>\".format(argv[0]))\\r\\n        sys.exit(1)\\r\\n\\r\\n    # argv[1] is the first command line argument passed to the program\\r\\n    input_str = argv[1]\\r\\n\\r\\n    # Sanitize input to ensure it's a valid string representation of an integer\\r\\n    # This is a basic sanitization and might need to be adjusted based on specific requirements\\r\\n    sanitized_input = ''.join(filter(str.isdigit, input_str))\\r\\n\\r\\n    # Convert the sanitized string to an integer\\r\\n    number = atoi(sanitized_input)\\r\\n\\r\\n    print(\"Converted number:\", number)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main(sys.argv)", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes an index as an argument and prints the corresponding argument from the command line arguments. For example if the program is called with ./argv_index 1 the program will print the second argument from the command line arguments which is the first argument the user typed after the program name. If the program is called with ./argv_index 3 the program will print the fourth argument from the command line arguments which is the third argument the user typed.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling"], "code": "import sys\\r\\n\\r\\ndef get_command_line_argument(index):\\r\\n    \"\"\"\\r\\n    This function takes an index as an argument and returns the corresponding\\r\\n    command line argument. It performs input validation and error handling.\\r\\n    \\r\\n    Parameters:\\r\\n    - index (int): The index of the command line argument to retrieve.\\r\\n    \\r\\n    Returns:\\r\\n    - str: The command line argument at the specified index, if valid.\\r\\n    \"\"\"\\r\\n    # Validate the index is an integer\\r\\n    try:\\r\\n        index = int(index)\\r\\n    except ValueError:\\r\\n        return \"Error: The index must be an integer.\"\\r\\n    \\r\\n    # Validate the index is within the range of command line arguments\\r\\n    if index < 0 or index >= len(sys.argv) - 1:\\r\\n        return \"Error: Index out of range. Please provide a valid index.\"\\r\\n    \\r\\n    # Return the command line argument at the specified index\\r\\n    return sys.argv[index + 1]\\r\\n\\r\\ndef main():\\r\\n    # Check if the user has provided an index argument\\r\\n    if len(sys.argv) < 3:\\r\\n        print(\"Usage: ./argv_index <index>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Get the index argument from the command line\\r\\n    index_argument = sys.argv[1]\\r\\n    \\r\\n    # Retrieve and print the command line argument at the specified index\\r\\n    result = get_command_line_argument(index_argument)\\r\\n    print(result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is out of bounds it returns -1. Otherwise it returns the value at the given index.The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer. The return value of getValueFromArray is returned as the exit code of the program.", "BP": ["Input Validation", "Array Bounds Checking", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef getValueFromArray(arr, size, index):\\r\\n    \"\"\"\\r\\n    This function takes an array of integers, its size, and an index as parameters.\\r\\n    It checks if the index is within the bounds of the array. If not, it returns -1.\\r\\n    Otherwise, it returns the value at the given index.\\r\\n    \"\"\"\\r\\n    # Array bounds checking\\r\\n    if index < 0 or index >= size:\\r\\n        return -1\\r\\n    else:\\r\\n        return arr[index]\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    The main function reads an integer from the standard input and calls getValueFromArray\\r\\n    with the id_sequence array, its size, and the read integer. The return value of\\r\\n    getValueFromArray is returned as the exit code of the program.\\r\\n    \"\"\"\\r\\n    # Sample array for demonstration. Replace with actual array as needed.\\r\\n    id_sequence = [10, 20, 30, 40, 50]\\r\\n    size = len(id_sequence)\\r\\n    \\r\\n    try:\\r\\n        # Reading integer from standard input and performing input validation\\r\\n        index = int(input(\"Enter an index: \"))\\r\\n    except ValueError:\\r\\n        print(\"Error: Please enter a valid integer.\")\\r\\n        sys.exit(1)  # Exiting with error code 1 to indicate input error\\r\\n    \\r\\n    # Calling getValueFromArray and handling the return value\\r\\n    value = getValueFromArray(id_sequence, size, index)\\r\\n    \\r\\n    if value == -1:\\r\\n        print(\"Index out of bounds.\")\\r\\n        sys.exit(2)  # Exiting with error code 2 to indicate out of bounds error\\r\\n    else:\\r\\n        print(f\"Value at index {index}: {value}\")\\r\\n        sys.exit(0)  # Exiting with code 0 to indicate successful execution\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers; its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array; its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef getValueFromArray(arr, size, index):\\r\\n    \"\"\"\\r\\n    Returns the value at the specified index if the index is within the bounds of the array.\\r\\n    Otherwise, returns -1.\\r\\n    \"\"\"\\r\\n    if 0 <= index < size:\\r\\n        return arr[index]\\r\\n    else:\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Reading an integer from standard input\\r\\n        index = int(input(\"Enter an index: \"))\\r\\n    except ValueError:\\r\\n        print(\"Error: Please enter a valid integer.\")\\r\\n        return -1  # Exiting with -1 to indicate error\\r\\n\\r\\n    # Example array, replace with actual array as needed\\r\\n    id_sequence = [10, 20, 30, 40, 50]\\r\\n    size = len(id_sequence)\\r\\n\\r\\n    # Input validation\\r\\n    if index < 0:\\r\\n        print(\"Error: Index cannot be negative.\")\\r\\n        return -1\\r\\n\\r\\n    # Calling the function with the user-provided index\\r\\n    value = getValueFromArray(id_sequence, size, index)\\r\\n\\r\\n    if value == -1:\\r\\n        print(\"Index out of bounds.\")\\r\\n    else:\\r\\n        print(f\"Value at index {index}: {value}\")\\r\\n\\r\\n    # Returning the value as exit code, note: exit codes are typically used to indicate status, not data\\r\\n    sys.exit(value)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Exception Handling", "Exception Handling", "Least Privilege Principle"], "code": "import sys\\r\\n\\r\\ndef getValueFromArray(arr, size, index):\\r\\n    # Input validation\\r\\n    if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\\r\\n        raise ValueError(\"Array must be a list of integers\")\\r\\n    if not isinstance(size, int) or size < 0:\\r\\n        raise ValueError(\"Size must be a non-negative integer\")\\r\\n    if not isinstance(index, int):\\r\\n        raise ValueError(\"Index must be an integer\")\\r\\n    \\r\\n    # Check if index is within the bounds of the array\\r\\n    if 0 <= index < size:\\r\\n        return arr[index]\\r\\n    else:\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Read an integer from standard input\\r\\n        input_index = int(input(\"Enter an index: \"))\\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Please enter an integer.\")\\r\\n        return -1  # Exit code for invalid input\\r\\n    \\r\\n    # Example array, replace with actual array if needed\\r\\n    id_sequence = [10, 20, 30, 40, 50]\\r\\n    size = len(id_sequence)\\r\\n    \\r\\n    # Call getValueFromArray and return its value as exit code\\r\\n    result = getValueFromArray(id_sequence, size, input_index)\\r\\n    return result\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    sys.exit(main())", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. If the index value is out of bounds the function returns -1. The function is called in the main function. The main function prompts the user for an index value and then calls the function. The function returns the value at the index in the array id_sequence. If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Separation of Concerns", "Secure Execution"], "code": "def get_id_at_index(index, id_sequence):\\r\\n    \"\"\"\\r\\n    This function takes an index and an array id_sequence.\\r\\n    It returns the value at the given index in id_sequence.\\r\\n    If the index is out of bounds, it returns -1.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Ensure the index is an integer and within the bounds of id_sequence\\r\\n        index = int(index)\\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            return -1\\r\\n        return id_sequence[index]\\r\\n    except ValueError:\\r\\n        # Handle the case where the index is not an integer\\r\\n        return -1\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected exceptions\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function that prompts the user for an index value,\\r\\n    calls get_id_at_index to get the value at that index in the array id_sequence,\\r\\n    and prints the result.\\r\\n    \"\"\"\\r\\n    id_sequence = [10, 20, 30, 40, 50]  # Example array, replace with actual id_sequence\\r\\n    try:\\r\\n        index = input(\"Enter an index value: \")\\r\\n        result = get_id_at_index(index, id_sequence)\\r\\n        if result == -1:\\r\\n            print(\"Index out of bounds or invalid input.\")\\r\\n        else:\\r\\n            print(f\"The value at index {index} is {result}.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. The function first prompts the user for an index value.Then the function checks if the index value is in bounds. If it is not the function returns -1. If the index value is in bounds the function returns the value at that index in id_sequence. The function returns 0 if the program runs.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Secure Execution"], "code": "def get_value_at_index(id_sequence):\\r\\n    \"\"\"\\r\\n    This function prompts the user for an index value, checks if the index is within the bounds of id_sequence,\\r\\n    and returns the value at that index if it is. If the index is out of bounds or an invalid input is provided,\\r\\n    it returns -1. The function returns 0 if it runs without encountering exceptions.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        index = int(input(\"Enter an index value: \"))\\r\\n        \\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Index is out of bounds.\")\\r\\n            return -1\\r\\n        \\r\\n        value = id_sequence[index]\\r\\n        print(f\"Value at index {index} is: {value}\")\\r\\n        return 0\\r\\n    \\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Please enter a valid integer index.\")\\r\\n        return -1\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return -1\\r\\n\\r\\n# Example usage:\\r\\nid_sequence = [10, 20, 30, 40, 50]\\r\\n\\r\\n# Test cases\\r\\nresult = get_value_at_index(id_sequence)\\r\\nprint(f\"Function execution result: {result}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence.The function first prompts the user for an index value.Then the function checks if the index value is in bounds.If it is the function returns the value at the index in id_sequence.If the index value is not in bounds the function returns 0.", "BP": ["Input Validation", "Exception Handling", "Least Privilege Principle", "Bounds Checking"], "code": "def get_id_value(id_sequence):\\r\\n    try:\\r\\n        # Prompt the user for an index value\\r\\n        index = int(input(\"Enter the index value: \"))\\r\\n        \\r\\n        # Perform bounds checking\\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Index out of bounds.\")\\r\\n            return 0\\r\\n        \\r\\n        # Return the value at the index if in bounds\\r\\n        return id_sequence[index]\\r\\n    except ValueError:\\r\\n        # Handle non-integer inputs gracefully\\r\\n        print(\"Invalid input. Please enter an integer.\")\\r\\n        return 0\\r\\n    except Exception as e:\\r\\n        # General exception handling to adhere to the principle of least privilege\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return 0", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is -1 the code will return -1.If the input is 10 the code will return -1.If the input is 0 the code will return the value at index 0 of the array.", "BP": ["Input Validation", "Secure String Operations", "Exception Handling"], "code": "def get_value_at_index(arr):\\r\\n    \"\"\"\\r\\n    This function takes an integer as input and returns the value at the index of the integer in the array.\\r\\n    If the input is -1 or out of the array's bounds, it returns -1.\\r\\n    It performs input validation, secure string operations, and exception handling.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Input validation\\r\\n        index = input(\"Please enter an integer index: \")\\r\\n        if not index.isdigit() and not (index.startswith('-') and index[1:].isdigit()):\\r\\n            raise ValueError(\"Input is not a valid integer.\")\\r\\n\\r\\n        index = int(index)\\r\\n\\r\\n        # Check for valid index range\\r\\n        if index == -1 or index >= len(arr):\\r\\n            return -1\\r\\n\\r\\n        # Secure string operation: Ensure index is within bounds\\r\\n        if 0 <= index < len(arr):\\r\\n            return arr[index]\\r\\n        else:\\r\\n            return -1\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return -1\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return -1\\r\\n\\r\\n# Example usage\\r\\narr = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\\r\\nresult = get_value_at_index(arr)\\r\\nprint(f\"Result: {result}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes in a number from the user and returns the value at that index in the array.If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Array Index Bounds Checking", "Error Handling", "Sanitizing User Input"], "code": "def get_value_at_index(arr):\\r\\n    # Input validation and sanitizing\\r\\n    try:\\r\\n        index = input(\"Please enter an index: \")\\r\\n        # Sanitize input to ensure it's an integer\\r\\n        index = int(index.strip())  # Strip removes leading/trailing spaces\\r\\n    except ValueError:\\r\\n        print(\"Error: Please enter a valid integer.\")\\r\\n        return -1\\r\\n\\r\\n    # Array index bounds checking\\r\\n    if index < 0 or index >= len(arr):\\r\\n        print(\"Error: Index out of bounds.\")\\r\\n        return -1\\r\\n\\r\\n    # Return value at index if no errors\\r\\n    return arr[index]\\r\\n\\r\\n# Example usage\\r\\narr = [10, 20, 30, 40, 50]\\r\\nresult = get_value_at_index(arr)\\r\\nprint(\"Value at index:\", result)", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is out of bounds the code will return -1.For example if the input is 10 the code will return -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Modularity"], "code": "def get_value_at_index(arr):\\r\\n    \"\"\"\\r\\n    This function takes an array and prompts the user to enter an integer.\\r\\n    It returns the value at the index of the integer in the array.\\r\\n    If the input is out of bounds, it returns -1.\\r\\n    \"\"\"\\r\\n    def input_integer(prompt):\\r\\n        \"\"\"\\r\\n        Prompts the user for an integer input and validates it.\\r\\n        Returns the integer if valid, otherwise prompts again.\\r\\n        \"\"\"\\r\\n        while True:\\r\\n            try:\\r\\n                value = int(input(prompt))\\r\\n                return value\\r\\n            except ValueError:\\r\\n                print(\"Invalid input. Please enter an integer.\")\\r\\n\\r\\n    index = input_integer(\"Enter an index: \")\\r\\n\\r\\n    try:\\r\\n        if index < 0 or index >= len(arr):\\r\\n            raise IndexError(\"Index out of bounds.\")\\r\\n        return arr[index]\\r\\n    except IndexError as e:\\r\\n        print(e)\\r\\n        return -1\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    sample_array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\\r\\n    result = get_value_at_index(sample_array)\\r\\n    print(f\"Value at the given index: {result}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The regular expression is compiled once when the module is loaded.The regular expression is used to match the target URL. If the target URL matches, it is used as the redirect target.If the target URL does not match a default URL is used. The regular expression is not used to construct the redirect URL.", "BP": ["Regular Expression Compilation", "Trusted Domains", "URL Sanitization", "Redirect Handling", "Default Redirect URL", "Secure Libraries"], "code": "import re\\r\\nfrom urllib.parse import urlparse\\r\\n\\r\\n# Compile the regular expression once when the module is loaded\\r\\n# This example assumes the trusted domains are example.com and sub.example.com\\r\\ntrusted_domains_pattern = re.compile(r'https?://(www\\.)?(example\\.com|sub\\.example\\.com)/.*')\\r\\n\\r\\n# Default URL to redirect to if the target URL does not match the trusted pattern\\r\\nDEFAULT_REDIRECT_URL = 'https://defaultsafe.example.com'\\r\\n\\r\\ndef is_url_trusted(target_url):\\r\\n    \"\"\"\\r\\n    Check if the target URL matches the trusted domains pattern.\\r\\n    \"\"\"\\r\\n    return bool(trusted_domains_pattern.match(target_url))\\r\\n\\r\\ndef sanitize_url(target_url):\\r\\n    \"\"\"\\r\\n    Sanitize the target URL to prevent Open Redirect vulnerabilities.\\r\\n    Only allow redirects to trusted domains.\\r\\n    \"\"\"\\r\\n    # Parse the target URL to ensure it's a valid URL\\r\\n    try:\\r\\n        parsed_url = urlparse(target_url)\\r\\n        # Reconstruct the URL to include scheme and netloc only for validation\\r\\n        reconstructed_url = f'{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}'\\r\\n        if is_url_trusted(reconstructed_url):\\r\\n            return reconstructed_url\\r\\n    except Exception as e:\\r\\n        print(f\"Error parsing URL: {e}\")\\r\\n    # Return the default URL if the target URL is not trusted\\r\\n    return DEFAULT_REDIRECT_URL\\r\\n\\r\\ndef redirect_to(url):\\r\\n    \"\"\"\\r\\n    Simulate a redirect to the given URL.\\r\\n    In a real application, this function would use a web framework's redirect method.\\r\\n    \"\"\"\\r\\n    print(f\"Redirecting to: {url}\")\\r\\n\\r\\n# Example usage\\r\\ntarget_url = 'https://example.com/some/path'\\r\\nredirect_to(sanitize_url(target_url))", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple Web application that has a single route.The route takes a target parameter and redirects to it. Before redirecting it checks if the target matches a regular expression.If the target matches the regular expression it redirects to it. If the target does not match the regular expression it redirects to /.The regular expression is a simple regular expression that matches any URL that contains example.com.", "BP": ["Input Sanitization", "URL Validation", "Secure Redirect", "URL Scheme Enforcement"], "code": "from flask import Flask, redirect, request, abort\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Regular expression to match URLs containing 'example.com'\\r\\nurl_pattern = re.compile(r'https?://(?:[-\\w.]|(?:%[\\da-fA-F]{2}))+/example\\.com')\\r\\n\\r\\n@app.route('/redirect')\\r\\ndef redirect_to_target():\\r\\n    target = request.args.get('target', None)\\r\\n    \\r\\n    # Input Sanitization and URL Validation\\r\\n    if not target or not re.match(url_pattern, target):\\r\\n        # If the target is not valid or does not match the pattern, redirect to '/'\\r\\n        return redirect('/')\\r\\n    \\r\\n    # Secure Redirect with URL Scheme Enforcement\\r\\n    if target.startswith('http://') or target.startswith('https://'):\\r\\n        return redirect(target)\\r\\n    else:\\r\\n        # If the URL scheme is not HTTP or HTTPS, abort the request for security reasons\\r\\n        abort(400)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The regular expression matches a string that starts with one or more alphanumeric characters or hyphens followed by a period. The target variable is set to the value of the target query parameter. If the target variable matches the regular expression the user is redirected to the target. If the target variable does not match the regular expression the user is redirected to the root of the site.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect"], "code": "import re\\r\\nfrom flask import Flask, request, redirect\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/redirect')\\r\\ndef secure_redirect():\\r\\n    # Regular expression to match the required pattern\\r\\n    pattern = r'^[a-zA-Z0-9-]+\\.'\\r\\n\\r\\n    # Retrieve the target query parameter value\\r\\n    target = request.args.get('target', '')\\r\\n\\r\\n    try:\\r\\n        # Input Sanitization by escaping special characters\\r\\n        sanitized_target = re.escape(target)\\r\\n\\r\\n        # Input Validation to check if the target matches the regular expression\\r\\n        if re.match(pattern, sanitized_target):\\r\\n            # Secure Redirect if the target matches the pattern\\r\\n            return redirect(sanitized_target, code=302)\\r\\n        else:\\r\\n            # Redirect to the root of the site if the target does not match the pattern\\r\\n            return redirect('/', code=302)\\r\\n    except Exception as e:\\r\\n        # Error Handling: Log the error and redirect to the root of the site\\r\\n        app.logger.error(f'Error during redirection: {e}')\\r\\n        return redirect('/', code=302)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The redirect_url function takes a url as an argument. The urlparse function from an imported module is used to parse the url. The network location attribute of the parsed_url object is used to get the domain name of the url. If the domain name is example.com the url is redirected. If the domain name is not example.com a 404 error is returned.", "BP": ["Standard Library", "Input Validation", "Exception Handling", "Custom Exception", "Secure Redirect"], "code": "from urllib.parse import urlparse\\r\\nfrom flask import redirect, abort\\r\\n\\r\\nclass UnsafeRedirectException(Exception):\\r\\n    \"\"\"Custom exception for unsafe redirect attempts.\"\"\"\\r\\n    pass\\r\\n\\r\\ndef redirect_url(url):\\r\\n    try:\\r\\n        # Validate the input URL\\r\\n        if not url.startswith(('http://', 'https://')):\\r\\n            raise ValueError(\"Invalid URL: URL must start with http:// or https://\")\\r\\n\\r\\n        # Parse the URL to get the domain name\\r\\n        parsed_url = urlparse(url)\\r\\n        domain_name = parsed_url.netloc\\r\\n\\r\\n        # Check if the domain name is example.com and redirect\\r\\n        if domain_name == 'example.com':\\r\\n            return redirect(url)\\r\\n        else:\\r\\n            # If the domain name is not example.com, return a 404 error\\r\\n            return abort(404)\\r\\n    except ValueError as e:\\r\\n        # Handle invalid URL input\\r\\n        raise UnsafeRedirectException(f\"Invalid URL provided: {e}\")\\r\\n    except Exception as e:\\r\\n        # Handle other exceptions\\r\\n        raise UnsafeRedirectException(f\"An error occurred during redirect: {e}\")", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route /redirect/<url> that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. If it is not it returns an error message.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect", "Separation of Concerns", "Secure Libraries", "Secure Regular Expressions"], "code": "from flask import Flask, redirect, request, abort\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    # Use a secure regular expression to validate the URL is from example.com\\r\\n    # This regex checks for http://example.com, https://example.com, and subdomains\\r\\n    pattern = re.compile(r'https?://([a-zA-Z0-9]+\\.)*example\\.com(/.*)?$', re.IGNORECASE)\\r\\n    return pattern.match(url) is not None\\r\\n\\r\\ndef sanitize_url(url):\\r\\n    # Basic sanitization to prevent common attacks (e.g., removing JavaScript: schemes)\\r\\n    # This is a simplistic approach; consider using more comprehensive libraries for production\\r\\n    return re.sub(r'javascript:', '', url, flags=re.IGNORECASE)\\r\\n\\r\\n@app.route('/redirect/<path:url>')\\r\\ndef redirect_invalid_url(url):\\r\\n    try:\\r\\n        # Input validation\\r\\n        if not is_valid_url(url):\\r\\n            return \"Error: Invalid URL. Only URLs from example.com are allowed.\", 400\\r\\n        \\r\\n        # Input sanitization\\r\\n        sanitized_url = sanitize_url(url)\\r\\n        \\r\\n        # Secure redirect\\r\\n        return redirect(sanitized_url)\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        abort(500, description=\"Internal Server Error\")\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route redirect url that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. Else it returns an error message.", "BP": ["Input Validation", "Hostname Validation", "Error Handling", "Separation of Concerns"], "code": "from flask import Flask, request, redirect, abort\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    # Simple regex for checking if it's a valid URL (basic check for format)\\r\\n    regex = re.compile(\\r\\n        r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n        r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)$'  # domain\\r\\n        r'(?::\\d+)?'  # optional port\\r\\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n    return re.match(regex, url) is not None\\r\\n\\r\\ndef is_example_com(url):\\r\\n    # Check if the hostname in the URL is from example.com\\r\\n    return 'example.com' in url\\r\\n\\r\\n@app.route('/redirect_url')\\r\\ndef redirect_url():\\r\\n    url = request.args.get('url', '')\\r\\n    try:\\r\\n        if not is_valid_url(url):\\r\\n            raise ValueError(\"Invalid URL format.\")\\r\\n        if is_example_com(url):\\r\\n            return redirect(url)\\r\\n        else:\\r\\n            return \"Error: URL is not from example.com\", 400\\r\\n    except Exception as e:\\r\\n        # Generic error handling\\r\\n        return f\"An error occurred: {str(e)}\", 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code reads a file from the /safe/ directory.", "BP": ["Input Validation", "Error Handling", "Directory Restriction", "Resource Cleanup", "Separation of Concerns"], "code": "import os\\r\\n\\r\\ndef read_file_from_safe_dir(file_name):\\r\\n    \"\"\"\\r\\n    Reads a file from the /safe/ directory with input validation, error handling,\\r\\n    directory restriction, and resource cleanup.\\r\\n    \"\"\"\\r\\n    # Define the safe directory path\\r\\n    safe_dir = \"/safe/\"\\r\\n    \\r\\n    try:\\r\\n        # Input Validation: Check if the file name is a string and not empty\\r\\n        if not isinstance(file_name, str) or not file_name:\\r\\n            raise ValueError(\"File name must be a non-empty string.\")\\r\\n        \\r\\n        # Directory Restriction: Ensure the file path is within the /safe/ directory\\r\\n        full_path = os.path.abspath(os.path.join(safe_dir, file_name))\\r\\n        if not full_path.startswith(os.path.abspath(safe_dir)):\\r\\n            raise ValueError(\"Access to the specified file is forbidden.\")\\r\\n        \\r\\n        # Attempt to open the file\\r\\n        with open(full_path, 'r') as file:\\r\\n            # Read the file content\\r\\n            content = file.read()\\r\\n            return content\\r\\n    except FileNotFoundError:\\r\\n        print(\"The specified file does not exist.\")\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n    finally:\\r\\n        # Resource Cleanup: The 'with' statement automatically closes the file.\\r\\n        print(\"File reading operation completed.\")\\r\\n\\r\\n# Example usage\\r\\nfile_content = read_file_from_safe_dir(\"example.txt\")\\r\\nif file_content is not None:\\r\\n    print(file_content)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads a requested file from the /safe/ directory.", "BP": ["Avoid Hardcoding Sensitive Paths", "Validate File Path", "Exception Handling", "Secure File Access", "Avoid Information Leaks"], "code": "import os\\r\\n\\r\\ndef read_file_securely(filename):\\r\\n    # Define the safe base directory\\r\\n    safe_base_path = \"/safe/\"\\r\\n    \\r\\n    # Validate the filename to avoid directory traversal attacks\\r\\n    if not os.path.basename(filename) == filename:\\r\\n        raise ValueError(\"Invalid filename. Directory traversal is not allowed.\")\\r\\n    \\r\\n    # Construct the full path and ensure it's within the safe directory\\r\\n    full_path = os.path.abspath(os.path.join(safe_base_path, filename))\\r\\n    if not full_path.startswith(os.path.abspath(safe_base_path)):\\r\\n        raise ValueError(\"Access denied. File is outside the allowed directory.\")\\r\\n    \\r\\n    try:\\r\\n        # Open the file in read-only mode to avoid unintended modifications\\r\\n        with open(full_path, 'r', encoding='utf-8') as file:\\r\\n            content = file.read()\\r\\n            return content\\r\\n    except FileNotFoundError:\\r\\n        # Handle file not found error without revealing the path or existence\\r\\n        raise FileNotFoundError(\"Requested file is not available.\")\\r\\n    except Exception as e:\\r\\n        # Generic exception handling to avoid information leaks\\r\\n        raise Exception(\"An error occurred while reading the file.\") from e", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads the requested file from the safe directory.", "BP": ["Error Handling", "Preventing Code Injection Vulnerabilities", "Secure File Reading"], "code": "import os\\r\\n\\r\\ndef safe_file_read(file_path, safe_dir):\\r\\n    \"\"\"\\r\\n    Reads the content of a file within a safe directory securely.\\r\\n    Prevents directory traversal and ensures the file is within the specified safe directory.\\r\\n\\r\\n    Parameters:\\r\\n    - file_path: The path to the file to be read.\\r\\n    - safe_dir: The directory considered safe to read files from.\\r\\n\\r\\n    Returns:\\r\\n    - The content of the file if it's within the safe directory and exists.\\r\\n    - None, if the file is outside the safe directory or an error occurs.\\r\\n    \"\"\"\\r\\n\\r\\n    # Normalize the paths to prevent directory traversal\\r\\n    safe_dir = os.path.normpath(safe_dir)\\r\\n    full_path = os.path.normpath(os.path.join(safe_dir, file_path))\\r\\n\\r\\n    # Check if the file is within the safe directory\\r\\n    if not full_path.startswith(safe_dir):\\r\\n        print(\"Access denied: Attempt to access a file outside the safe directory.\")\\r\\n        return None\\r\\n\\r\\n    # Attempt to read the file\\r\\n    try:\\r\\n        with open(full_path, 'r', encoding='utf-8') as file:\\r\\n            return file.read()\\r\\n    except FileNotFoundError:\\r\\n        print(\"Error: The file does not exist.\")\\r\\n    except PermissionError:\\r\\n        print(\"Error: Permission denied.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n    return None\\r\\n\\r\\n# Example usage\\r\\nsafe_dir = \"/path/to/safe/directory\"\\r\\nfile_path = input(\"Enter the relative path of the file to read: \").strip()\\r\\ncontent = safe_file_read(file_path, safe_dir)\\r\\nif content is not None:\\r\\n    print(\"File content:\")\\r\\n    print(content)\\r\\nelse:\\r\\n    print(\"Failed to read the file.\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator above the img() function associates the URL of /img with this function.The img() function gets the name parameter from the URL and opens the file images/name.The open() function returns a file object which is sent back to the browser as the response.", "BP": ["Input Sanitization", "File Type Validation", "Error Handling"], "code": "from flask import Flask, send_file, abort\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef validate_image(f):\\r\\n    def wrapper(name):\\r\\n        # Input sanitization to ensure the filename is secure\\r\\n        name = os.path.basename(name)\\r\\n        # File type validation to ensure it's an image\\r\\n        if not name.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):\\r\\n            abort(400, description=\"Unsupported file type.\")\\r\\n        image_path = os.path.join('images', name)\\r\\n        # Error handling if the file does not exist\\r\\n        if not os.path.isfile(image_path):\\r\\n            abort(404, description=\"Image not found.\")\\r\\n        return f(image_path)\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/img/<name>')\\r\\n@validate_image\\r\\ndef img(name):\\r\\n    return send_file(name)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator is used to tell Flask what URL should trigger our function.The function checks if the file exists in the images folder. If the file exists it sends the file to the browser.", "BP": ["Directory Traversal Protection", "Unauthorized Access Prevention", "Error Handling"], "code": "from flask import Flask, send_from_directory, abort\\r\\nimport os\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Define the base directory for images\\r\\nIMAGES_DIR = os.path.join(app.root_path, 'images')\\r\\n\\r\\n@app.route('/images/<filename>')\\r\\ndef serve_image(filename):\\r\\n    try:\\r\\n        # Secure the filename to prevent directory traversal\\r\\n        secure_name = secure_filename(filename)\\r\\n        # Check if the file exists to prevent unauthorized access\\r\\n        if not os.path.exists(os.path.join(IMAGES_DIR, secure_name)):\\r\\n            # If the file does not exist, return a 404 error\\r\\n            abort(404)\\r\\n        # Serve the file from the images directory\\r\\n        return send_from_directory(IMAGES_DIR, secure_name)\\r\\n    except Exception as e:\\r\\n        # Log the error or handle it as needed\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        # Return a generic error message to the user\\r\\n        abort(500)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The img() function is called when the user visits the /img route.The request.args.get('file') function gets the value of the file parameter in the URL.The open() function opens the file in read binary mode. The read() function reads the file and returns it.", "BP": ["Input Validation", "Error Handling", "File Contents Retrieval", "Response Handling", "Secure File Path"], "code": "from flask import Flask, request, send_file, abort\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/img')\\r\\ndef img():\\r\\n    # Input Validation\\r\\n    file_name = request.args.get('file')\\r\\n    if not file_name:\\r\\n        return abort(400, description=\"No file specified\")\\r\\n\\r\\n    # Secure File Path\\r\\n    # Ensure the file path is within a specific directory to prevent directory traversal attacks\\r\\n    base_directory = os.path.abspath(\"/path/to/your/images\")\\r\\n    secure_path = os.path.join(base_directory, file_name)\\r\\n    secure_path = os.path.abspath(secure_path)\\r\\n\\r\\n    if not secure_path.startswith(base_directory):\\r\\n        return abort(403, description=\"Access denied\")\\r\\n\\r\\n    # Error Handling\\r\\n    try:\\r\\n        # File Contents Retrieval\\r\\n        if os.path.exists(secure_path) and os.path.isfile(secure_path):\\r\\n            # Response Handling\\r\\n            return send_file(secure_path, as_attachment=True)\\r\\n        else:\\r\\n            return abort(404, description=\"File not found\")\\r\\n    except Exception as e:\\r\\n        return abort(500, description=str(e))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Unzip all files from the archive to the /tmp/unpack directory.", "BP": ["Secure File Handling", "Input Validation", "Error Handling"], "code": "import tarfile\\r\\nimport os\\r\\n\\r\\ndef unpack_archive(archive_path, extract_path=\"/tmp/unpack\"):\\r\\n    # Secure File Handling\\r\\n    if not os.path.isfile(archive_path):\\r\\n        print(\"Error: The archive path provided does not exist or is not a file.\")\\r\\n        return False\\r\\n\\r\\n    # Input Validation\\r\\n    if not archive_path.endswith('.zip'):\\r\\n        print(\"Error: The archive format is not supported. Please provide a .zip file.\")\\r\\n        return False\\r\\n\\r\\n    try:\\r\\n        # Ensure the extract_path directory exists\\r\\n        os.makedirs(extract_path, exist_ok=True)\\r\\n\\r\\n        # Using tarfile to open and extract .zip files\\r\\n        with tarfile.open(archive_path, 'r:gz') as archive:\\r\\n            archive.extractall(path=extract_path)\\r\\n        print(f\"Archive extracted successfully to {extract_path}\")\\r\\n        return True\\r\\n    except tarfile.TarError as e:\\r\\n        print(f\"Error extracting the archive: {e}\")\\r\\n        return False\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\narchive_path = \"archive.zip\"\\r\\nif unpack_archive(archive_path):\\r\\n    print(\"Unpacking completed successfully.\")\\r\\nelse:\\r\\n    print(\"Unpacking failed.\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Extract all files from the archive to the /tmp/unpack directory.", "BP": ["Use of Temporary Directory", "Error Handling", "File Validation", "Cleanup"], "code": "import tarfile\\r\\nimport tempfile\\r\\nimport os\\r\\nimport shutil\\r\\n\\r\\ndef extract_tarfile_to_temp_directory(archive_path):\\r\\n    # Step 1: Validate the archive file\\r\\n    if not os.path.isfile(archive_path):\\r\\n        raise FileNotFoundError(f\"The archive file {archive_path} does not exist.\")\\r\\n    if not tarfile.is_tarfile(archive_path):\\r\\n        raise ValueError(f\"The file {archive_path} is not a valid tar archive.\")\\r\\n\\r\\n    # Step 2: Use a temporary directory for extraction\\r\\n    with tempfile.TemporaryDirectory() as temp_dir:\\r\\n        try:\\r\\n            # Step 3: Open the tarfile and extract it to the temporary directory\\r\\n            with tarfile.open(archive_path, \"r\") as tar:\\r\\n                tar.extractall(path=temp_dir)\\r\\n                print(f\"Successfully extracted {archive_path} to {temp_dir}\")\\r\\n\\r\\n            # Step 4: Move extracted files to the target directory (/tmp/unpack)\\r\\n            target_dir = \"/tmp/unpack\"\\r\\n            if not os.path.exists(target_dir):\\r\\n                os.makedirs(target_dir)\\r\\n            for file_name in os.listdir(temp_dir):\\r\\n                shutil.move(os.path.join(temp_dir, file_name), target_dir)\\r\\n            print(f\"All files have been moved to {target_dir}\")\\r\\n\\r\\n        except Exception as e:\\r\\n            # Handle errors during extraction and moving\\r\\n            print(f\"An error occurred: {e}\")\\r\\n\\r\\n        finally:\\r\\n            # Step 5: Cleanup is handled by the TemporaryDirectory context manager automatically\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    archive_path = \"archive.zip\"\\r\\n    extract_tarfile_to_temp_directory(archive_path)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The with statement is used to wrap the execution of a block with methods defined by a context manager.The tarfile module makes it possible to read and write tar archives including those using gzip or bz2 compression.The open() function opens and returns a file handle that can be used to read or write a file in the usual way.", "BP": ["Input Validation", "Exception Handling", "Secure File Extraction", "Separation of Concerns", "Handling of Relative and Absolute Paths"], "code": "import os\\r\\nimport tarfile\\r\\nfrom contextlib import ExitStack\\r\\n\\r\\ndef is_safe_path(base_path, path, follow_symlinks=True):\\r\\n    \"\"\"\\r\\n    Ensure the path is within the base_path directory.\\r\\n    \"\"\"\\r\\n    if follow_symlinks:\\r\\n        return os.path.realpath(path).startswith(os.path.realpath(base_path))\\r\\n    else:\\r\\n        return os.path.abspath(path).startswith(os.path.abspath(base_path))\\r\\n\\r\\ndef extract_tarfile_safe(tar_path, extract_path='./extracted', follow_symlinks=True):\\r\\n    \"\"\"\\r\\n    Extracts a tar file ensuring that the contents are extracted to a designated directory without\\r\\n    escaping the base directory using path traversal vulnerabilities.\\r\\n    \"\"\"\\r\\n    if not is_safe_path(os.getcwd(), tar_path, follow_symlinks):\\r\\n        raise ValueError(\"Unsafe tar file path provided.\")\\r\\n\\r\\n    if not os.path.exists(extract_path):\\r\\n        os.makedirs(extract_path, exist_ok=True)\\r\\n\\r\\n    with ExitStack() as stack:\\r\\n        tar = stack.enter_context(tarfile.open(tar_path, 'r:*'))\\r\\n        for member in tar.getmembers():\\r\\n            member_path = os.path.join(extract_path, member.name)\\r\\n            if is_safe_path(extract_path, member_path, follow_symlinks):\\r\\n                tar.extract(member, path=extract_path)\\r\\n            else:\\r\\n                raise ValueError(f\"Attempt to extract file outside of target directory: {member.name}\")\\r\\n\\r\\ndef read_or_write_file(file_path, mode='r', content=None):\\r\\n    \"\"\"\\r\\n    Opens a file to read or write to it, ensuring the file path is safe and does not lead outside\\r\\n    of the intended directory.\\r\\n    \"\"\"\\r\\n    if not is_safe_path(os.getcwd(), file_path):\\r\\n        raise ValueError(\"Unsafe file path provided.\")\\r\\n\\r\\n    try:\\r\\n        with open(file_path, mode) as file:\\r\\n            if mode == 'r':\\r\\n                return file.read()\\r\\n            elif mode in ['w', 'a']:\\r\\n                if content is not None:\\r\\n                    file.write(content)\\r\\n                else:\\r\\n                    raise ValueError(\"Content must be provided for writing.\")\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while accessing the file: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    try:\\r\\n        # Extract tar file safely\\r\\n        extract_tarfile_safe('example.tar.gz', './safe_extraction')\\r\\n\\r\\n        # Read from a file\\r\\n        content = read_or_write_file('./safe_extraction/readme.txt', 'r')\\r\\n        print(content)\\r\\n\\r\\n        # Write to a file\\r\\n        read_or_write_file('./safe_extraction/output.txt', 'w', 'This is a secure file write operation.')\\r\\n    except ValueError as e:\\r\\n        print(f\"Validation error: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code executes the command getent passwd <username> and stores the output in the file pointer output. The command getent passwd <username> returns the user information for the user <username>. The command getent passwd <username> is executed by the system() function. The command getent passwd <username> is executed by the popen() function.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Secure File Handling", "Error Handling", "Principle of Least Privilege"], "code": "import subprocess\\r\\nimport shlex\\r\\nimport os\\r\\n\\r\\ndef get_user_info(username):\\r\\n    # Input Sanitization\\r\\n    if not username.isalnum():\\r\\n        raise ValueError(\"Username must be alphanumeric.\")\\r\\n    \\r\\n    # Secure Subprocess Execution with popen()\\r\\n    try:\\r\\n        # Using shlex to ensure that the username is safely incorporated into the command\\r\\n        command = shlex.split(f'getent passwd {username}')\\r\\n        \\r\\n        # Using subprocess.Popen for secure subprocess execution\\r\\n        with subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) as proc:\\r\\n            output, errors = proc.communicate()\\r\\n            \\r\\n            # Error Handling\\r\\n            if proc.returncode != 0:\\r\\n                raise Exception(f\"Error executing command: {errors}\")\\r\\n            \\r\\n            # Secure File Handling\\r\\n            # Principle of Least Privilege: Using 'w' mode to ensure only write operation on the file\\r\\n            with open(\"user_info.txt\", \"w\") as file_pointer:\\r\\n                file_pointer.write(output)\\r\\n                \\r\\n            print(\"User information successfully written to user_info.txt\")\\r\\n            \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nget_user_info(\"exampleusername\")", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code is a simple program that takes a username as a command line argument and prints the user information from the /etc/passwd file. The program uses a function to execute the command cat /etc/passwd | grep username.The function executes the command specified in its argument. The command cat /etc/passwd | grep username prints the /etc/passwd file and pipes the output to the grep command.", "BP": ["Input Sanitization", "Error Handling", "Principle of Least Privilege", "Secure File Reading", "Secure Pattern Matching"], "code": "import subprocess\\r\\nimport sys\\r\\nimport re\\r\\n\\r\\ndef get_user_info(username):\\r\\n    # Input Sanitization\\r\\n    if not re.match(r'^[a-zA-Z0-9_-]+$', username):\\r\\n        raise ValueError(\"Invalid username. Username must consist of letters, numbers, underscores, or dashes.\")\\r\\n\\r\\n    # Secure Pattern Matching\\r\\n    safe_username = re.escape(username)\\r\\n\\r\\n    # Secure File Reading and Command Execution\\r\\n    try:\\r\\n        command = f\"grep '{safe_username}' /etc/passwd\"\\r\\n        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)\\r\\n        output, error = process.communicate()\\r\\n\\r\\n        if process.returncode != 0:\\r\\n            raise subprocess.CalledProcessError(process.returncode, command, output=output, stderr=error)\\r\\n\\r\\n        if output:\\r\\n            print(output)\\r\\n        else:\\r\\n            print(f\"No user information found for {username}\")\\r\\n\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error executing command: {e.stderr}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <username>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    username = sys.argv[1]\\r\\n\\r\\n    # Principle of Least Privilege\\r\\n    if not subprocess.getoutput('id -u') == '0':\\r\\n        print(\"This script should not be run as root or with sudo privileges for security reasons.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    get_user_info(username)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code takes a username as a command line argument.It then uses the a function to run the command id <username>. The id command prints information about the user. The function returns the exit status of the command. If the command is successful the exit status is 0.If the command fails the exit status is non-zero.The code prints the exit status of the command.", "BP": ["Input Validation", "Input Sanitization", "Secure Command Execution", "Error Handling", "Secure Exit"], "code": "import subprocess\\r\\nimport sys\\r\\nimport re\\r\\n\\r\\ndef run_id_command(username):\\r\\n    # Input validation and sanitization\\r\\n    if not re.match(r\"^[a-zA-Z0-9._-]+$\", username):\\r\\n        print(\"Invalid username. Only alphanumeric characters, dots, underscores, and dashes are allowed.\")\\r\\n        return 1  # Non-zero exit status for invalid input\\r\\n\\r\\n    try:\\r\\n        # Secure command execution\\r\\n        completed_process = subprocess.run([\"id\", username], check=True, text=True, capture_output=True)\\r\\n        print(completed_process.stdout)\\r\\n        return 0  # Zero exit status for success\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"An error occurred while executing the command: {e}\")\\r\\n        return e.returncode  # Non-zero exit status for command failure\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return 1  # Non-zero exit status for unexpected errors\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <username>\")\\r\\n        sys.exit(1)  # Secure exit with non-zero status for incorrect usage\\r\\n\\r\\n    exit_status = run_id_command(sys.argv[1])\\r\\n    print(f\"Exit status: {exit_status}\")\\r\\n    sys.exit(exit_status)  # Secure exit with the command's exit status", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator tells the web application what URL should trigger our function.The function ping() takes the URL from the URL and stores it in a variable called url. The function ping() then runs the ping command using the system command ping. The output of the ping command is stored in a variable called output. The function ping() returns the output of the ping command.", "BP": ["Input Validation", "Subprocess Handling", "Output Escaping", "URL Validation", "Error Handling"], "code": "import subprocess\\r\\nfrom flask import Flask, request, escape\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef validate_url(func):\\r\\n    def wrapper(*args, **kwargs):\\r\\n        url = request.args.get('url', '')\\r\\n        # Basic URL validation pattern, adjust as needed\\r\\n        pattern = re.compile(\\r\\n            r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n            r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)'  # domain\\r\\n            r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n        if not pattern.match(url):\\r\\n            return \"Invalid URL\", 400\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/ping', methods=['GET'])\\r\\n@validate_url\\r\\ndef ping():\\r\\n    try:\\r\\n        url = request.args.get('url', '')\\r\\n        # Ensure the URL is safe to pass to a shell command\\r\\n        safe_url = re.sub(r'[^a-zA-Z0-9.:-]', '', url)\\r\\n        # Use subprocess to safely run the ping command\\r\\n        result = subprocess.run(['ping', '-c', '4', safe_url], capture_output=True, text=True)\\r\\n        output = result.stdout\\r\\n        # Escape the output to prevent XSS attacks if displaying in a web page\\r\\n        safe_output = escape(output)\\r\\n        return safe_output\\r\\n    except Exception as e:\\r\\n        return f\"An error occurred: {str(e)}\", 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The URL is returned to the browser. The code is a simple example of how to run a system command.", "BP": ["Input Sanitization", "Use of subprocess", "Validation of Request Method", "Validation of URL Parameter", "Error Handling", "Appropriate HTTP Status Codes"], "code": "import subprocess\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Decorator for binding a function to a URL\\r\\ndef route(url):\\r\\n    def decorator(func):\\r\\n        app.route(url, methods=['GET', 'POST'])(func)\\r\\n        return func\\r\\n    return decorator\\r\\n\\r\\n# Input sanitization and validation for URL\\r\\ndef is_valid_url(url):\\r\\n    # Simple regex for URL validation\\r\\n    regex = re.compile(\\r\\n        r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\\r\\n        r'localhost|'  # localhost...\\r\\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\\r\\n        r'(?::\\d+)?'  # optional port\\r\\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n    return re.match(regex, url) is not None\\r\\n\\r\\n@route('/ping')\\r\\ndef ping():\\r\\n    if request.method == 'POST':\\r\\n        url = request.form.get('url', '')\\r\\n        if is_valid_url(url):\\r\\n            try:\\r\\n                # Using subprocess to run the ping command securely\\r\\n                result = subprocess.run(['ping', '-c', '4', url], capture_output=True, text=True)\\r\\n                if result.returncode == 0:\\r\\n                    return jsonify({'url': url, 'output': result.stdout}), 200\\r\\n                else:\\r\\n                    return jsonify({'error': 'Ping failed'}), 400\\r\\n            except Exception as e:\\r\\n                return jsonify({'error': str(e)}), 500\\r\\n        else:\\r\\n            return jsonify({'error': 'Invalid URL'}), 400\\r\\n    else:\\r\\n        return jsonify({'error': 'Invalid request method'}), 405\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The output of the ping command is stored in the variable \"pong\". If the ping command returns 0 the URL is alive.Else the URL is not alive.", "BP": ["Input Validation", "Input Sanitization", "Principle of Least Privilege", "Exception Handling", "Secure Output"], "code": "import subprocess\\r\\nfrom functools import wraps\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef validate_url(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        url = kwargs.get('url', args[0] if args else '')\\r\\n        # Basic URL validation\\r\\n        if not re.match(r'^https?://[a-zA-Z0-9.-]+(?:\\:[0-9]+)?$', url):\\r\\n            return jsonify({\"error\": \"Invalid URL\"}), 400\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\ndef secure_ping(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        try:\\r\\n            # Sanitize URL to prevent command injection\\r\\n            sanitized_url = re.sub(r'[^a-zA-Z0-9.:/-]', '', kwargs['url'])\\r\\n            # Execute ping command securely\\r\\n            result = subprocess.run([\"ping\", \"-c\", \"1\", sanitized_url], capture_output=True, text=True)\\r\\n            pong = result.stdout\\r\\n            if result.returncode == 0:\\r\\n                return jsonify({\"url\": sanitized_url, \"alive\": True, \"output\": pong})\\r\\n            else:\\r\\n                return jsonify({\"url\": sanitized_url, \"alive\": False, \"output\": pong})\\r\\n        except Exception as e:\\r\\n            return jsonify({\"error\": str(e)}), 500\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/ping/<path:url>')\\r\\n@validate_url\\r\\n@secure_ping\\r\\ndef ping(url):\\r\\n    # The actual ping logic is handled by the decorators\\r\\n    pass\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a system function to execute the ls command.The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the system function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Error Handling", "Principle of Least Privilege"], "code": "import subprocess\\r\\nimport shlex\\r\\n\\r\\ndef secure_ls_command(directory):\\r\\n    \"\"\"\\r\\n    Executes the 'ls' command securely on the specified directory, ensuring input sanitization,\\r\\n    secure subprocess execution, error handling, and adherence to the principle of least privilege.\\r\\n    \\r\\n    Parameters:\\r\\n    directory (str): The directory to list contents of.\\r\\n    \"\"\"\\r\\n    # Input sanitization\\r\\n    if not isinstance(directory, str):\\r\\n        raise ValueError(\"Directory path must be a string.\")\\r\\n    sanitized_directory = shlex.quote(directory)\\r\\n    \\r\\n    # Secure subprocess execution with error handling\\r\\n    try:\\r\\n        # Using subprocess.run for secure execution, avoiding shell=True\\r\\n        result = subprocess.run([\"ls\", sanitized_directory], text=True, capture_output=True, check=True)\\r\\n        print(result.stdout)\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"An error occurred while trying to list the contents of {sanitized_directory}: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nsecure_ls_command(\"/path/to/directory\")", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a function to execute the ls command.The function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Subprocess Execution", "Secure Command Execution"], "code": "import subprocess\\r\\nimport shlex\\r\\n\\r\\ndef execute_command(command):\\r\\n    \"\"\"\\r\\n    Executes a given command securely using subprocess module.\\r\\n    \\r\\n    Args:\\r\\n    - command (str): The command to be executed.\\r\\n    \\r\\n    Returns:\\r\\n    - output (str): The output of the executed command.\\r\\n    - error (str): The error message if command execution fails.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Securely parse the command to avoid shell injection vulnerabilities\\r\\n        safe_command = shlex.split(command)\\r\\n        \\r\\n        # Execute the command without opening a shell\\r\\n        process = subprocess.Popen(safe_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\\r\\n        output, error = process.communicate()\\r\\n        \\r\\n        if process.returncode == 0:\\r\\n            return output, None\\r\\n        else:\\r\\n            return None, error\\r\\n    except Exception as e:\\r\\n        return None, str(e)\\r\\n\\r\\ndef main():\\r\\n    # Example usage\\r\\n    directory = \"/path/to/directory\"\\r\\n    \\r\\n    # Input validation and sanitization\\r\\n    if not isinstance(directory, str):\\r\\n        print(\"Error: Directory path must be a string.\")\\r\\n        return\\r\\n    \\r\\n    # Replace potentially dangerous characters or sequences\\r\\n    sanitized_directory = directory.replace(\";\", \"\").replace(\"&\", \"\").replace(\"`\", \"\")\\r\\n    \\r\\n    # Construct the command string securely\\r\\n    command = f\"ls {shlex.quote(sanitized_directory)}\"\\r\\n    \\r\\n    # Execute the command\\r\\n    output, error = execute_command(command)\\r\\n    \\r\\n    if error:\\r\\n        print(f\"Error executing command: {error}\")\\r\\n    else:\\r\\n        print(f\"Command output:\\n{output}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses the system function to execute the ls command. The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Command Execution"], "code": "import os\\r\\nimport shlex\\r\\nimport subprocess\\r\\n\\r\\ndef secure_ls_command(directory):\\r\\n    # Input Validation\\r\\n    if not isinstance(directory, str):\\r\\n        raise ValueError(\"Directory path must be a string.\")\\r\\n    \\r\\n    # Input Sanitization\\r\\n    sanitized_directory = shlex.quote(directory)\\r\\n    \\r\\n    # Secure Command Execution\\r\\n    command = f\"ls {sanitized_directory}\"\\r\\n    try:\\r\\n        # Using subprocess.run instead of os.system for better security and control\\r\\n        result = subprocess.run(command, shell=True, check=True, text=True, capture_output=True)\\r\\n        print(f\"Contents of {directory}:\\n{result.stdout}\")\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"An error occurred while trying to list the contents of {directory}: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\ndirectory = \"/path/to/directory\"\\r\\nsecure_ls_command(directory)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The function http_hello_page is called when the server receives a request for the URL /hello. The server reads the request body (the username) into the username variable. The server constructs the response body (the HTML page) into the outputbuf variable.The server writes the response body to the response stream. The server closes the response stream.The server is now ready to handle the next request.", "BP": ["Input Sanitization", "Separation of Concerns", "Error Handling", "Secure Handling Request Body", "Secure Handling Response Body"], "code": "from http.server import BaseHTTPRequestHandler, HTTPServer\\r\\nimport cgi\\r\\n\\r\\nclass RequestHandler(BaseHTTPRequestHandler):\\r\\n    def do_POST(self):\\r\\n        if self.path == '/hello':\\r\\n            try:\\r\\n                # Input Sanitization\\r\\n                ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\\r\\n                if ctype != 'multipart/form-data':\\r\\n                    raise ValueError(\"Content type must be multipart/form-data\")\\r\\n                \\r\\n                # Read the request body\\r\\n                form = cgi.FieldStorage(fp=self.rfile, headers=self.headers, environ={'REQUEST_METHOD': 'POST'})\\r\\n                username = form.getvalue('username')\\r\\n                if not username:\\r\\n                    raise ValueError(\"Username is required\")\\r\\n                \\r\\n                # Secure Handling Request Body\\r\\n                username = self.sanitize_input(username)\\r\\n                \\r\\n                # Construct the response body\\r\\n                outputbuf = self.construct_response(username)\\r\\n                \\r\\n                # Secure Handling Response Body\\r\\n                outputbuf = self.secure_response(outputbuf)\\r\\n                \\r\\n                # Write the response body to the response stream\\r\\n                self.send_response(200)\\r\\n                self.send_header('Content-type', 'text/html')\\r\\n                self.end_headers()\\r\\n                self.wfile.write(outputbuf.encode())\\r\\n                \\r\\n            except Exception as e:\\r\\n                # Error Handling\\r\\n                self.send_error(400, str(e))\\r\\n            finally:\\r\\n                # Close the response stream\\r\\n                self.wfile.close()\\r\\n\\r\\n    def sanitize_input(self, input_data):\\r\\n        # Implement sanitization logic here\\r\\n        # For example, escaping HTML characters, limiting length, etc.\\r\\n        sanitized = cgi.escape(input_data, quote=True)\\r\\n        return sanitized[:100]  # Limiting length to 100 characters\\r\\n\\r\\n    def construct_response(self, username):\\r\\n        # Separation of Concerns: Constructing response separately\\r\\n        return f\"<html><body><h2>Hello, {username}!</h2></body></html>\"\\r\\n\\r\\n    def secure_response(self, response):\\r\\n        # Implement any additional security measures for the response\\r\\n        # For example, adding security headers\\r\\n        return response\\r\\n\\r\\ndef run(server_class=HTTPServer, handler_class=RequestHandler, port=8080):\\r\\n    server_address = ('', port)\\r\\n    httpd = server_class(server_address, handler_class)\\r\\n    print(f'Server running on port {port}...')\\r\\n    httpd.serve_forever()\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    run()", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The function http_hello_page takes in a request and a response. The request is a file stream that contains the request from the client. The response is a file stream that we can write to in order to send a response to the client. The request contains the username that the client entered. We read the username from the request. We construct a response that says \"Hello [username]\". We write the response to the response file stream.", "BP": ["Input Sanitization", "Error Handling", "Separation of Concerns"], "code": "import html\\r\\n\\r\\ndef read_username_from_request(request):\\r\\n    \"\"\"\\r\\n    Reads the username from the request file stream.\\r\\n    Assumes the username is sent in a simple format: \"username: <username>\"\\r\\n    \"\"\"\\r\\n    try:\\r\\n        for line in request:\\r\\n            if line.startswith(\"username:\"):\\r\\n                # Extracting the username part and sanitizing it to prevent HTML injection\\r\\n                return html.escape(line.strip().split(\":\", 1)[1].strip())\\r\\n    except Exception as e:\\r\\n        print(f\"Error reading username from request: {e}\")\\r\\n    return None\\r\\n\\r\\ndef construct_hello_response(username):\\r\\n    \"\"\"\\r\\n    Constructs a hello response message for the given username.\\r\\n    \"\"\"\\r\\n    if username:\\r\\n        return f\"Hello {username}\"\\r\\n    else:\\r\\n        return \"Hello anonymous user\"\\r\\n\\r\\ndef http_hello_page(request, response):\\r\\n    \"\"\"\\r\\n    Handles the HTTP request by reading the username from the request,\\r\\n    constructing a hello message, and writing it to the response file stream.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        username = read_username_from_request(request)\\r\\n        hello_message = construct_hello_response(username)\\r\\n        response.write(hello_message)\\r\\n    except Exception as e:\\r\\n        print(f\"Error handling HTTP request: {e}\")\\r\\n        response.write(\"An error occurred while processing your request.\")\\r\\n\\r\\n# Example usage\\r\\nwith open(\"request.txt\", \"r\") as request_stream, open(\"response.txt\", \"w\") as response_stream:\\r\\n    http_hello_page(request_stream, response_stream)", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The function http_hello_page takes in a request and a response. The request is a file stream that contains the request from the client. The response is a file stream that we can write to. The request contains the username that the client entered. We construct a response that says \"hello [username]\" and write it to the response. The response is sent back to the client.The function escape_html is a function that escapes HTML.", "BP": ["Input Sanitization", "Escaping HTML Characters", "Separation of Concerns", "Error Handling"], "code": "import html\\r\\n\\r\\ndef escape_html(input_string):\\r\\n    \"\"\"\\r\\n    Escapes HTML characters in the input string to prevent HTML injection attacks.\\r\\n    \"\"\"\\r\\n    return html.escape(input_string)\\r\\n\\r\\ndef read_username_from_request(request_stream):\\r\\n    \"\"\"\\r\\n    Reads the username from the request file stream, sanitizes the input,\\r\\n    and escapes HTML characters.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        for line in request_stream:\\r\\n            if line.startswith(\"username:\"):\\r\\n                username = line.strip().split(\":\", 1)[1].strip()\\r\\n                sanitized_username = escape_html(username)\\r\\n                return sanitized_username\\r\\n    except Exception as e:\\r\\n        print(f\"Error reading username from request: {e}\")\\r\\n    return None\\r\\n\\r\\ndef construct_hello_response(username):\\r\\n    \"\"\"\\r\\n    Constructs a hello response message for the given username.\\r\\n    \"\"\"\\r\\n    if username:\\r\\n        return f\"Hello {username}\"\\r\\n    else:\\r\\n        return \"Hello anonymous user\"\\r\\n\\r\\ndef http_hello_page(request_stream, response_stream):\\r\\n    \"\"\"\\r\\n    Handles the HTTP request by reading the username from the request,\\r\\n    constructing a hello message, and writing it to the response file stream.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        username = read_username_from_request(request_stream)\\r\\n        hello_message = construct_hello_response(username)\\r\\n        response_stream.write(hello_message)\\r\\n    except Exception as e:\\r\\n        print(f\"Error handling HTTP request: {e}\")\\r\\n        response_stream.write(\"An error occurred while processing your request.\")\\r\\n\\r\\n# Example usage with file streams (for demonstration purposes)\\r\\nif __name__ == \"__main__\":\\r\\n    from io import StringIO\\r\\n\\r\\n    # Simulate a request with a username\\r\\n    request_stream = StringIO(\"username: example_user\")\\r\\n    response_stream = StringIO()\\r\\n\\r\\n    http_hello_page(request_stream, response_stream)\\r\\n\\r\\n    # Output the response content\\r\\n    print(response_stream.getvalue())", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The render_response_from_env function takes an environment as an argument. The function gets the name parameter from the request. The function gets the template from the environment. The function renders the template with the name parameter. The function returns a response with the rendered template. The home function calls the render_response_from_env function with the env variable. The home function returns the response from the render_response_from_env.", "BP": ["Input Sanitization", "Security Headers", "Separation of Concerns"], "code": "from flask import Flask, request, make_response\\r\\nfrom jinja2 import Environment, FileSystemLoader, select_autoescape\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Initialize Jinja2 environment\\r\\nenv = Environment(\\r\\n    loader=FileSystemLoader('templates'),\\r\\n    autoescape=select_autoescape(['html', 'xml'])\\r\\n)\\r\\n\\r\\ndef sanitize_input(input_string):\\r\\n    \"\"\"\\r\\n    Sanitize the input to prevent injection attacks.\\r\\n    \"\"\"\\r\\n    # Basic sanitization. This should be expanded based on the context and expected inputs.\\r\\n    return input_string.replace('<', '').replace('>', '').replace('\"', '').replace(\"'\", '')\\r\\n\\r\\ndef add_security_headers(response):\\r\\n    \"\"\"\\r\\n    Add security headers to the response to improve security.\\r\\n    \"\"\"\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    return response\\r\\n\\r\\ndef render_response_from_env(environment):\\r\\n    \"\"\"\\r\\n    Renders a response from the environment using a template and a name parameter from the request.\\r\\n    \"\"\"\\r\\n    # Get the name parameter from the request and sanitize it\\r\\n    name = sanitize_input(request.args.get('name', ''))\\r\\n    \\r\\n    # Get the template from the environment\\r\\n    template = environment.get_template('greeting.html')\\r\\n    \\r\\n    # Render the template with the name parameter\\r\\n    rendered_template = template.render(name=name)\\r\\n    \\r\\n    # Create a response and add security headers\\r\\n    response = make_response(rendered_template)\\r\\n    response = add_security_headers(response)\\r\\n    \\r\\n    return response\\r\\n\\r\\n@app.route('/')\\r\\ndef home():\\r\\n    \"\"\"\\r\\n    Home route that renders a response using the environment.\\r\\n    \"\"\"\\r\\n    response = render_response_from_env(env)\\r\\n    return response\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The render_response_from_env function takes an environment as an argument. The function gets the name parameter from the request. The function gets the template from the environment. The function renders the template with the name parameter. The function returns a response with the rendered template. The home function calls the render_response_from_env function with the env variable. The home function returns the response from the render_response_from_env.", "BP": ["Input Sanitization", "Automatic HTML Escaping", "Error Handling"], "code": "from flask import Flask, request, make_response\\r\\nfrom jinja2 import Environment, FileSystemLoader, select_autoescape\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef render_response_from_env(environment):\\r\\n    try:\\r\\n        # Get the 'name' parameter from the request, perform input sanitization\\r\\n        name = request.args.get('name', 'World')\\r\\n        if not isinstance(name, str) or any(c in name for c in \"<>\\\"'&\"):\\r\\n            raise ValueError(\"Invalid name parameter.\")\\r\\n\\r\\n        # Get the template from the environment\\r\\n        template = environment.get_template('hello_template.html')\\r\\n\\r\\n        # Render the template with the name parameter, automatic HTML escaping is enabled by default\\r\\n        rendered_template = template.render(name=name)\\r\\n\\r\\n        # Return a response with the rendered template\\r\\n        return make_response(rendered_template)\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        return make_response(f\"An error occurred: {str(e)}\", 500)\\r\\n\\r\\ndef home():\\r\\n    # Assuming 'env' is a Jinja2 Environment object initialized elsewhere in your code\\r\\n    env = Environment(\\r\\n        loader=FileSystemLoader('path/to/templates'),\\r\\n        autoescape=select_autoescape(['html', 'xml'])\\r\\n    )\\r\\n    # Call the render_response_from_env function with the env variable\\r\\n    response = render_response_from_env(env)\\r\\n    # Return the response from render_response_from_env\\r\\n    return response\\r\\n\\r\\n# Example route\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return home()", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The render_response_from_env function takes an environment as an argument. The function gets the name parameter from the user request. The function gets the template from the environment. The function renders the template with the name parameter from the request. The function returns a response with the rendered template. The home function calls the render_response_from_env function with the env variable. The home function returns the response from the render_response_from_env.", "BP": ["Session Security", "Input Sanitization", "Error Handling", "Logging and Monitoring", "CSRF Protection"], "code": "import logging\\r\\nfrom flask import Flask, request, make_response, session, escape\\r\\nfrom jinja2 import Environment, FileSystemLoader, select_autoescape\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key_here'\\r\\n\\r\\n# Enable CSRF protection globally for the app\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Configure Jinja2 environment\\r\\nenv = Environment(\\r\\n    loader=FileSystemLoader('templates'),\\r\\n    autoescape=select_autoescape(['html', 'xml'])\\r\\n)\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\ndef render_response_from_env(environment):\\r\\n    try:\\r\\n        # Get the name parameter from the user request, sanitize input\\r\\n        name = escape(request.args.get('name', ''))\\r\\n        \\r\\n        # Ensure the session is secure\\r\\n        if 'user_id' not in session:\\r\\n            raise PermissionError(\"User not authenticated.\")\\r\\n        \\r\\n        # Get the template from the environment\\r\\n        template = environment.get_template('greeting_template.html')\\r\\n        \\r\\n        # Render the template with the name parameter from the request\\r\\n        rendered_template = template.render(name=name)\\r\\n        \\r\\n        # Return a response with the rendered template\\r\\n        return make_response(rendered_template)\\r\\n    except Exception as e:\\r\\n        # Log the error\\r\\n        logging.error(f\"Error rendering response: {e}\")\\r\\n        # Return an error response\\r\\n        return make_response(\"An error occurred while processing your request.\", 500)\\r\\n\\r\\n@app.route('/')\\r\\ndef home():\\r\\n    # Call the render_response_from_env function with the env variable\\r\\n    response = render_response_from_env(env)\\r\\n    # Return the response from the render_response_from_env\\r\\n    return response\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL. The function hello() is called when a user visits the URL /hello/<username>. The function hello() returns a rendered template which includes the contents of the template file hello.html as well as the value of the username variable. The username variable is passed to the template hello.html which displays the value of the variable.", "BP": ["Input validation", "Input Sanitization", "Error Handling", "Decorator Function", "Secure URL Handling"], "code": "from flask import Flask, render_template, request, abort\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef secure_url(func):\\r\\n    def wrapper(*args, **kwargs):\\r\\n        username = kwargs.get('username', '')\\r\\n        # Input validation and sanitization\\r\\n        if not re.match(\"^[a-zA-Z0-9_-]*$\", username):\\r\\n            abort(400, description=\"Invalid username.\")\\r\\n        return func(*args, **kwargs)\\r\\n    wrapper.__name__ = func.__name__\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/hello/<username>')\\r\\n@secure_url\\r\\ndef hello(username):\\r\\n    try:\\r\\n        # Assuming hello.html exists and is set up to display the username variable\\r\\n        return render_template('hello.html', username=username)\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        abort(500, description=\"Internal Server Error\")\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The first line imports the web application class. An instance of this class will be our WSGI application. The second line creates the application object. The third line is a decorator. It tells the application which URL should call the associated function. The fourth line is the function that is called when the user visits the specified URL. The fifth line returns the message to the user. The sixth line runs the application.", "BP": ["XSS Prevention", "Secure Host and Port", "Disable Debug Mode", "Secure Dependencies", "Input Validation", "Secure Headers"], "code": "# Step 1: Import the necessary class for the web application\\r\\nfrom flask import Flask, request, escape\\r\\n\\r\\n# Step 2: Create an instance of the class. This instance will act as the WSGI application.\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Step 3: Use a decorator to tell the application which URL should call the associated function.\\r\\n@app.route('/')\\r\\ndef hello_world():\\r\\n    # Step 4: This is the function that gets called when the user visits the specified URL.\\r\\n    \\r\\n    # Perform input validation and escape to prevent XSS\\r\\n    name = request.args.get(\"name\", \"World\")\\r\\n    safe_name = escape(name)\\r\\n    \\r\\n    # Step 5: Return the message to the user, ensuring any user input is safely escaped.\\r\\n    return f'Hello, {safe_name}!'\\r\\n\\r\\n# Step 6: Run the application with secure settings.\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='127.0.0.1', port=8080, debug=False)", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: A decorator creates a mapping between the URL given as an argument and the function that follows it. The function hello() returns a string with the text Hello followed by the value of the variable username. The variable username is passed as an argument to the function hello(). The escape() function converts special characters to HTML-safe sequences. The function hello() is called when a user navigates to the URL /hello/username\".", "BP": ["Input Validation", "Input Sanitization", "Secure URL Routing", "Separation of Concerns", "Error Handling"], "code": "from flask import Flask, escape, request\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef url_map(url):\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            return func(*args, **kwargs)\\r\\n        app.add_url_rule(url, view_func=wrapper)\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n@url_map('/hello/<username>')\\r\\ndef hello(username):\\r\\n    # Input Validation\\r\\n    if not username.isalnum():\\r\\n        return \"Invalid username.\", 400\\r\\n    \\r\\n    # Input Sanitization\\r\\n    safe_username = escape(username)\\r\\n    \\r\\n    # Secure URL Routing, Separation of Concerns, and Error Handling are inherently handled by Flask\\r\\n    return f\"Hello, {safe_username}!\"\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    app.run( )", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The user enters their email address into the unsubscribe form on the website. The email address is passed to the unsubscribe function.The unsubscribe function connects to the database and checks if the email address is in the database.If the email address is in the database it is removed.If the email address is not in the database the user is told that they are not in the database.", "BP": ["Input Validation", "Data Sanitization", "Error Handling", "Principle of Least Privilege"], "code": "import re\\r\\nimport sqlite3\\r\\n\\r\\ndef is_valid_email(email):\\r\\n    # Simple regex for validating an email address\\r\\n    regex = r'^\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\\r\\n    return re.match(regex, email)\\r\\n\\r\\ndef sanitize_email(email):\\r\\n    # Basic sanitization to prevent SQL injection\\r\\n    # This is a simple example, in real applications, use parameterized queries\\r\\n    return re.sub(r'[^a-zA-Z0-9@._+-]', '', email)\\r\\n\\r\\ndef unsubscribe(email):\\r\\n    # Input validation\\r\\n    if not is_valid_email(email):\\r\\n        return \"Invalid email address.\"\\r\\n    \\r\\n    # Data sanitization\\r\\n    email = sanitize_email(email)\\r\\n    \\r\\n    try:\\r\\n        # Connect to the database\\r\\n        # Ensure the database path and connection method follow the principle of least privilege\\r\\n        conn = sqlite3.connect('path/to/your/database.db')\\r\\n        cursor = conn.cursor()\\r\\n        \\r\\n        # Check if the email is in the database\\r\\n        cursor.execute(\"SELECT * FROM subscribers WHERE email = ?\", (email,))\\r\\n        if cursor.fetchone():\\r\\n            # Email found, remove it\\r\\n            cursor.execute(\"DELETE FROM subscribers WHERE email = ?\", (email,))\\r\\n            conn.commit()\\r\\n            return \"You have been successfully unsubscribed.\"\\r\\n        else:\\r\\n            # Email not found\\r\\n            return \"Your email address is not in our database.\"\\r\\n    except sqlite3.Error as error:\\r\\n        return \"An error occurred: \" + str(error)\\r\\n    finally:\\r\\n        if conn:\\r\\n            conn.close()\\r\\n\\r\\n# Example usage\\r\\nemail = input(\"Enter your email to unsubscribe: \")\\r\\nprint(unsubscribe(email))", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: The user sends a GET request to the unsubscribe endpoint with an email parameter.The code checks if the email is in the database. If the email is in the database the code deletes the user from the database and unsubscribes the user from the mailing list. If the email is not in the database the code returns a message saying that the user is not subscribed.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns", "Database Session Management"], "code": "from flask import Flask, request, jsonify\\r\\nfrom sqlalchemy import create_engine, Column, String, exc\\r\\nfrom sqlalchemy.orm import sessionmaker, declarative_base\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Database setup\\r\\nDATABASE_URI = 'sqlite:///users.db'\\r\\nBase = declarative_base()\\r\\n\\r\\nclass User(Base):\\r\\n    __tablename__ = 'users'\\r\\n    email = Column(String, primary_key=True)\\r\\n\\r\\nengine = create_engine(DATABASE_URI)\\r\\nBase.metadata.create_all(engine)\\r\\nSession = sessionmaker(bind=engine)\\r\\n\\r\\n# Input validation function\\r\\ndef is_valid_email(email):\\r\\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\\r\\n    return re.match(pattern, email) is not None\\r\\n\\r\\n@app.route('/unsubscribe', methods=['GET'])\\r\\ndef unsubscribe_user():\\r\\n    email = request.args.get('email')\\r\\n    if not email or not is_valid_email(email):\\r\\n        return jsonify({\"error\": \"Invalid email format.\"}), 400\\r\\n\\r\\n    session = Session()\\r\\n    try:\\r\\n        user = session.query(User).filter_by(email=email).first()\\r\\n        if user:\\r\\n            session.delete(user)\\r\\n            session.commit()\\r\\n            # Here you would also call the function to unsubscribe the user from the mailing list\\r\\n            return jsonify({\"message\": f\"User {email} unsubscribed successfully.\"}), 200\\r\\n        else:\\r\\n            return jsonify({\"message\": \"User not subscribed.\"}), 404\\r\\n    except exc.SQLAlchemyError as e:\\r\\n        session.rollback()\\r\\n        return jsonify({\"error\": \"Database error occurred.\"}), 500\\r\\n    finally:\\r\\n        session.close()\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: Check if the email exists in the database. If it doesn't it returns 0. If it does it calls a php script that unsubscribes the email. If the php script returns 0 it returns 1. If not it returns 0.", "BP": ["Input Sanitization", "Parameterized Queries", "Secure HTTP Requests", "Secure URL Construction"], "code": "import re\\r\\nimport requests\\r\\nimport sqlite3\\r\\n\\r\\ndef is_valid_email(email):\\r\\n    # Simple regex for validating an email address\\r\\n    return re.match(r\"[^@]+@[^@]+\\.[^@]+\", email)\\r\\n\\r\\ndef sanitize_email(email):\\r\\n    # Basic sanitization\\r\\n    return re.sub(r\"[^a-zA-Z0-9@.]\", \"\", email)\\r\\n\\r\\ndef check_and_unsubscribe_email(email):\\r\\n    if not is_valid_email(email):\\r\\n        return \"Invalid email format\", 0\\r\\n    \\r\\n    email = sanitize_email(email)\\r\\n    \\r\\n    # Connect to the database securely\\r\\n    conn = sqlite3.connect('your_database.db')\\r\\n    cursor = conn.cursor()\\r\\n    \\r\\n    # Use a parameterized query to prevent SQL injection\\r\\n    cursor.execute(\"SELECT * FROM email_list WHERE email = ?\", (email,))\\r\\n    result = cursor.fetchone()\\r\\n    \\r\\n    if not result:\\r\\n        return \"Email does not exist in the database\", 0\\r\\n    \\r\\n    # Secure URL construction for calling the PHP script\\r\\n    php_script_url = \"https://yourdomain.com/unsubscribe.php\"\\r\\n    params = {'email': email}\\r\\n    \\r\\n    # Make a secure HTTP request\\r\\n    response = requests.get(php_script_url, params=params, verify=True)\\r\\n    \\r\\n    if response.text == '0':\\r\\n        return \"Unsubscribed successfully\", 1\\r\\n    else:\\r\\n        return \"Failed to unsubscribe\", 0", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: The buy_stock function is called when the user clicks on the buy button.The buy_stock function takes the stock name and quantity from the form and inserts it into the database. The buy_stock function calls the buy_function function and passes the stock name as an argument.The buy_function function takes the stock name as an argument.", "BP": ["Input Validation", "Parameterized Queries", "Least Privilege", "Error Handling", "Secure Database Connection", "Secure Communication", "Input Sanitization"], "code": "import sqlite3\\r\\nfrom sqlite3 import Error\\r\\n\\r\\ndef create_connection(db_file):\\r\\n    \"\"\"Create a secure database connection to the SQLite database specified by db_file\"\"\"\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(db_file)\\r\\n        return conn\\r\\n    except Error as e:\\r\\n        print(f\"Error connecting to database: {e}\")\\r\\n    return conn\\r\\n\\r\\ndef buy_function(stock_name):\\r\\n    \"\"\"A placeholder function that could involve more complex operations with the stock name\"\"\"\\r\\n    print(f\"Processing purchase for {stock_name}\")\\r\\n\\r\\ndef buy_stock(stock_name, quantity, db_file):\\r\\n    \"\"\"Inserts stock purchase into the database after input validation and sanitization\"\"\"\\r\\n    # Input Validation\\r\\n    if not stock_name.isalpha() or not isinstance(quantity, int) or quantity <= 0:\\r\\n        print(\"Invalid input. Stock name should be alphabetic and quantity should be a positive integer.\")\\r\\n        return\\r\\n\\r\\n    # Input Sanitization\\r\\n    stock_name = stock_name.strip().upper()  # Example of basic sanitization\\r\\n\\r\\n    # Secure Database Connection\\r\\n    conn = create_connection(db_file)\\r\\n    if conn is not None:\\r\\n        try:\\r\\n            # Parameterized Queries & Least Privilege\\r\\n            with conn:\\r\\n                conn.execute(\"PRAGMA foreign_keys = ON\")  # Enforce foreign key constraints\\r\\n                sql = ''' INSERT INTO stocks(stock_name, quantity)\\r\\n                          VALUES(?,?) '''\\r\\n                cur = conn.cursor()\\r\\n                cur.execute(sql, (stock_name, quantity))\\r\\n                conn.commit()\\r\\n                print(f\"Stock {stock_name} with quantity {quantity} added to the database.\")\\r\\n                \\r\\n                # Call buy_function after successful insertion\\r\\n                buy_function(stock_name)\\r\\n        except Error as e:\\r\\n            print(f\"An error occurred: {e}\")\\r\\n        finally:\\r\\n            conn.close()\\r\\n    else:\\r\\n        print(\"Failed to create database connection.\")\\r\\n\\r\\n# Example usage\\r\\ndb_file = \"path/to/database.db\"\\r\\nbuy_stock(\"AAPL\", 10, db_file)", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: The user enters the stock name and quantity in the form.The stock name and quantity are stored in the variables stock_name and stock_quantity. The username is stored in the variable username.The buy order is inserted into the database.The user is redirected to the profile page.", "BP": ["Input Validation", "Input Sanitization", "Authentication", "Authorization", "Database Security", "Error Handling", "HTTPS Implementation", "CSRF Protection"], "code": "from flask import Flask, request, redirect, url_for, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, IntegerField, validators\\r\\nfrom flask_login import LoginManager, current_user, login_required\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///stocks.db'\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\ndb = SQLAlchemy(app)\\r\\nlogin_manager = LoginManager(app)\\r\\n\\r\\n# Database model\\r\\nclass StockOrder(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), nullable=False)\\r\\n    stock_name = db.Column(db.String(80), nullable=False)\\r\\n    stock_quantity = db.Column(db.Integer, nullable=False)\\r\\n\\r\\n# Form for stock order\\r\\nclass StockOrderForm(FlaskForm):\\r\\n    stock_name = StringField('Stock Name', [validators.Length(min=1, max=80)])\\r\\n    stock_quantity = IntegerField('Quantity', [validators.NumberRange(min=1)])\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    # Implement user loader\\r\\n    pass\\r\\n\\r\\n@app.route('/buy_stock', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef buy_stock():\\r\\n    form = StockOrderForm()\\r\\n    if form.validate_on_submit():\\r\\n        # Input validation and sanitization is handled by WTForms\\r\\n        stock_name = form.stock_name.data\\r\\n        stock_quantity = form.stock_quantity.data\\r\\n        username = current_user.username  # Assuming current_user is authenticated and loaded\\r\\n        \\r\\n        # Insert buy order into the database\\r\\n        try:\\r\\n            order = StockOrder(username=username, stock_name=stock_name, stock_quantity=stock_quantity)\\r\\n            db.session.add(order)\\r\\n            db.session.commit()\\r\\n            flash('Stock order placed successfully!')\\r\\n        except Exception as e:\\r\\n            db.session.rollback()\\r\\n            flash('Error placing stock order.')\\r\\n        \\r\\n        return redirect(url_for('profile'))\\r\\n    \\r\\n    return render_template('buy_stock.html', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # This runs the app over HTTPS. For production, use a proper SSL certificate.", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: The user enters the stock name and quantity in the form. The form is submitted to the buy_order route. The buy_order route takes the stock name and quantity and inserts it into the database. The user is redirected to the stock_view page. The code is a very simple example of how to insert data into a database.", "BP": ["Input Validation", "Parameterized Queries", "Secure Session Management", "Authentication and Authorization", "Secure Templates", "Secure Secret Key", "CSRF Protection", "Error Handling", "Password Hashing"], "code": "from flask import Flask, request, redirect, render_template, session, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, IntegerField, SubmitField\\r\\nfrom wtforms.validators import DataRequired\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Secret Key\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///stocks.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize CSRF protection\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Initialize the database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Database model for stocks\\r\\nclass Stock(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    name = db.Column(db.String(80), nullable=False)\\r\\n    quantity = db.Column(db.Integer, nullable=False)\\r\\n\\r\\n# Form for stock entry\\r\\nclass StockForm(FlaskForm):\\r\\n    stock_name = StringField('Stock Name', validators=[DataRequired()])\\r\\n    quantity = IntegerField('Quantity', validators=[DataRequired()])\\r\\n    submit = SubmitField('Submit')\\r\\n\\r\\n@app.route('/buy_order', methods=['GET', 'POST'])\\r\\ndef buy_order():\\r\\n    form = StockForm()\\r\\n    if form.validate_on_submit():\\r\\n        # Input Validation\\r\\n        stock_name = form.stock_name.data\\r\\n        quantity = form.quantity.data\\r\\n\\r\\n        # Insert into database with Parameterized Queries\\r\\n        new_stock = Stock(name=stock_name, quantity=quantity)\\r\\n        db.session.add(new_stock)\\r\\n        db.session.commit()\\r\\n\\r\\n        # Redirect to stock_view page\\r\\n        return redirect('/stock_view')\\r\\n    return render_template('buy_order.html', form=form)\\r\\n\\r\\n@app.route('/stock_view')\\r\\ndef stock_view():\\r\\n    # Authentication and Authorization checks should be implemented here\\r\\n    # For simplicity, this example assumes the user is already authenticated and authorized\\r\\n\\r\\n    stocks = Stock.query.all()\\r\\n    return render_template('stock_view.html', stocks=stocks)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run( )", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: Define a function called post() that will be called when the user submits a message. It gets the username and message from the request. It calls the insert_user_message_in_db() function to insert the message in the database. It redirects the user to the main page. Now add the code to display the messages.", "BP": ["Input Validation", "Input Sanitization", "Secure Database Interaction", "URL Redirection", "HTML Rendering"], "code": "from flask import Flask, request, redirect, render_template_string\\r\\nimport html\\r\\nimport sqlite3\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef insert_user_message_in_db(username, message):\\r\\n    # Secure Database Interaction\\r\\n    # Use parameterized queries to avoid SQL Injection\\r\\n    connection = sqlite3.connect('database.db')\\r\\n    cursor = connection.cursor()\\r\\n    cursor.execute(\"INSERT INTO messages (username, message) VALUES (?, ?)\", (username, message))\\r\\n    connection.commit()\\r\\n    connection.close()\\r\\n\\r\\n@app.route('/post', methods=['POST'])\\r\\ndef post():\\r\\n    # Input Validation and Sanitization\\r\\n    username = request.form.get('username', '')\\r\\n    message = request.form.get('message', '')\\r\\n    \\r\\n    # Basic sanitization\\r\\n    username = html.escape(username.strip())\\r\\n    message = html.escape(message.strip())\\r\\n    \\r\\n    # Further validation can be added here based on requirements\\r\\n    \\r\\n    # Insert the sanitized and validated input into the database\\r\\n    insert_user_message_in_db(username, message)\\r\\n    \\r\\n    # URL Redirection to the main page\\r\\n    return redirect('/')\\r\\n\\r\\n@app.route('/')\\r\\ndef main_page():\\r\\n    # Secure Database Interaction\\r\\n    connection = sqlite3.connect('database.db')\\r\\n    cursor = connection.cursor()\\r\\n    cursor.execute(\"SELECT username, message FROM messages\")\\r\\n    messages = cursor.fetchall()\\r\\n    connection.close()\\r\\n    \\r\\n    # HTML Rendering with escaping to prevent XSS\\r\\n    # Note: For better security and separation of concerns, use a template engine like Jinja2\\r\\n    html_content = '<h1>Messages</h1>'\\r\\n    for username, message in messages:\\r\\n        html_content += f'<p><b>{html.escape(username)}:</b> {html.escape(message)}</p>'\\r\\n    \\r\\n    return render_template_string(html_content)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: Create a new route called /post. It gets the username and message from the request. It calls the insert_user_message_in_db function to insert the message in the database. It redirects the user to the / route. Now add the code to display the messages.", "BP": ["Input Sanitization", "Parameterized Queries", "Secure Database Connection", "Error Handling", "Separation of Concerns", "Secure Redirection", "Secure Session Key"], "code": "from flask import Flask, request, redirect, render_template, session\\r\\nimport psycopg2\\r\\nimport psycopg2.extras\\r\\nfrom psycopg2 import sql\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure session key\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Database connection parameters\\r\\nDB_HOST = \"your_host\"\\r\\nDB_NAME = \"your_dbname\"\\r\\nDB_USER = \"your_user\"\\r\\nDB_PASS = \"your_password\"\\r\\n\\r\\n# Secure database connection function\\r\\ndef get_db_connection():\\r\\n    conn = psycopg2.connect(\\r\\n        dbname=DB_NAME,\\r\\n        user=DB_USER,\\r\\n        password=DB_PASS,\\r\\n        host=DB_HOST,\\r\\n        cursor_factory=psycopg2.extras.DictCursor\\r\\n    )\\r\\n    return conn\\r\\n\\r\\n# Function to insert user message into the database\\r\\ndef insert_user_message_in_db(username, message):\\r\\n    try:\\r\\n        conn = get_db_connection()\\r\\n        cur = conn.cursor()\\r\\n        # Parameterized query to prevent SQL injection\\r\\n        cur.execute(\\r\\n            \"INSERT INTO messages (username, message) VALUES (%s, %s)\",\\r\\n            (username, message)\\r\\n        )\\r\\n        conn.commit()\\r\\n        cur.close()\\r\\n        conn.close()\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\n@app.route('/post', methods=['POST'])\\r\\ndef post_message():\\r\\n    username = request.form.get('username', '')\\r\\n    message = request.form.get('message', '')\\r\\n\\r\\n    # Input sanitization\\r\\n    username = sanitize_input(username)\\r\\n    message = sanitize_input(message)\\r\\n\\r\\n    # Insert the sanitized input into the database\\r\\n    insert_user_message_in_db(username, message)\\r\\n\\r\\n    # Secure redirection\\r\\n    return redirect('/', code=302)\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    try:\\r\\n        conn = get_db_connection()\\r\\n        cur = conn.cursor()\\r\\n        cur.execute(\"SELECT username, message FROM messages ORDER BY id DESC\")\\r\\n        messages = cur.fetchall()\\r\\n        cur.close()\\r\\n        conn.close()\\r\\n        return render_template('index.html', messages=messages)\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return \"An error occurred while fetching messages.\"\\r\\n\\r\\n# Function to sanitize input\\r\\ndef sanitize_input(input_string):\\r\\n    # Implement input sanitization logic here\\r\\n    # This is a placeholder for actual sanitization logic\\r\\n    sanitized_string = input_string.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\\r\\n    return sanitized_string\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: Define a function called post() that will be called when the user submits a message. It gets the username and message from the request. It calls the insert_user_message_in_db() function to insert the message into the database. It redirects the user back to the main page. Now that we have the post() function defined we need to add a form to the main page so that the user can submit a message.", "BP": ["Input Validation", "Output Encoding", "Secure Database Access", "Secure Redirects", "CSRF Protection", "Rate Limiting", "Secure Session Management", "Form Design"], "code": "from flask import Flask, request, redirect, session, render_template, url_for, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nimport html\\r\\nimport secure\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'\\r\\n\\r\\n# Configure rate limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# CSRF protection\\r\\napp.config['WTF_CSRF_SECRET_KEY'] = 'your_csrf_secret_key'\\r\\napp.config['WTF_CSRF_TIME_LIMIT'] = None\\r\\n\\r\\nclass MessageForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\\r\\n    message = StringField('Message', validators=[DataRequired(), Length(min=1, max=140)])\\r\\n    submit = SubmitField('Submit')\\r\\n\\r\\ndef insert_user_message_in_db(username, message):\\r\\n    # Secure database access\\r\\n    # This is a placeholder function. Implement the database insertion securely.\\r\\n    pass\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef post():\\r\\n    form = MessageForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = html.escape(form.username.data)\\r\\n        message = html.escape(form.message.data)\\r\\n        # Secure session management\\r\\n        if 'user' not in session:\\r\\n            flash('Session expired or invalid. Please log in again.', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n        insert_user_message_in_db(username, message)\\r\\n        # Secure redirects\\r\\n        return redirect(secure.url_for('main_page'))\\r\\n    return render_template('index.html', form=form)\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    # Implement login functionality here\\r\\n    # Ensure secure session management\\r\\n    pass\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-89"}
