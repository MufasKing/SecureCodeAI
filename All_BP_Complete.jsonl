{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP": ["Input Validation", "Secure Output", "Error handling", "Command Line Input"], "code": "import sys\\r\\nimport re\\r\\n \\r\\ndef validate_input(value):\\r\\n    # Define a regular expression pattern to match valid numeric input\\r\\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\\r\\n    # Check if the input matches the pattern\\r\\n    if re.match(pattern, value):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n \\r\\ndef secure_output(result):\\r\\n    # Sanitize the output to prevent Code Injection and Cross-Site Scripting (XSS) attacks\\r\\n    sanitized_result = str(result).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\\r\\n    print(sanitized_result)\\r\\n \\r\\ndef main():\\r\\n    try:\\r\\n        # Get the input value from the command line arguments\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: Please provide a value as a command line argument.\")\\r\\n            sys.exit(1)\\r\\n        input_value = sys.argv[1]\\r\\n        # Validate the input\\r\\n        if not validate_input(input_value):\\r\\n            print(\"Error: Invalid input. Please provide a valid numeric value.\")\\r\\n            sys.exit(1)\\r\\n        # Convert the input to a float\\r\\n        value = float(input_value)\\r\\n        # Add 1000 to the value\\r\\n        result = value + 1000\\r\\n        # Output the result securely\\r\\n        secure_output(result)\\r\\n    except ValueError:\\r\\n        print(\"Error: Invalid input. Please provide a valid numeric value.\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {str(e)}\")\\r\\n \\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": ["Input Validation", "Error Handling", "Avoiding Unsafe Functions", "Secure Execution"], "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef main():\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Error: Please provide one argument (a number) as a command line argument.\")\\r\\n        return\\r\\n\\r\\n    input_value = sys.argv[1]\\r\\n\\r\\n    # Input Validation\\r\\n    if not input_value.isdigit():\\r\\n        print(\"Error: Input must be a valid integer.\")\\r\\n        return\\r\\n\\r\\n    # Secure Execution\\r\\n    try:\\r\\n        value = int(input_value)\\r\\n        offset = 1000\\r\\n        result = value + offset\\r\\n        print(f\"Result: {result}\")\\r\\n    except ValueError:\\r\\n        print(\"Error: An unexpected error occurred during execution.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns", "Secure Coding Practices", "Principle of Least Privilege", "Explict Exit"], "code": "import sys\\r\\nimport argparse\\r\\n\\r\\ndef add_1000(value):\\r\\n    try:\\r\\n        value = int(value)\\r\\n    except ValueError:\\r\\n        print(\"Error: Input must be an integer.\")\\r\\n        return 1\\r\\n\\r\\n    result = value + 1000\\r\\n    print(f\"The result is: {result}\")\\r\\n    return 0\\r\\n\\r\\ndef main():\\r\\n    parser = argparse.ArgumentParser(description=\"Add 1000 to a given value.\")\\r\\n    parser.add_argument(\"value\", type=str, help=\"The value to add 1000 to.\")\\r\\n\\r\\n    args = parser.parse_args()\\r\\n\\r\\n    return add_1000(args.value)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    exit_code = main()\\r\\n    sys.exit(exit_code)", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": ["Import Secure modules", "Use decimal module", "perform Input Validation", "Error Handling", "Data Protection", "Logging and Auditing"], "code": "import os\\r\\nimport secrets\\r\\nimport decimal\\r\\nimport logging\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(user_input, allowed_chars):\\r\\n    if all(char in allowed_chars for char in user_input):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\n# Error Handling\\r\\ndef error_handler(error_message):\\r\\n    logging.error(error_message)\\r\\n    # You can also raise an exception or take other appropriate actions\\r\\n\\r\\n# Data Protection\\r\\ndef encrypt_data(data, key):\\r\\n    # Implement a secure encryption algorithm, e.g., AES\\r\\n    # Return the encrypted data\\r\\n    pass\\r\\n\\r\\ndef decrypt_data(encrypted_data, key):\\r\\n    # Implement the decryption algorithm\\r\\n    # Return the decrypted data\\r\\n    pass\\r\\n\\r\\n# Logging and Auditing\\r\\nlogging.basicConfig(level=logging.INFO, filename='app.log', format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Generate secure random numbers\\r\\ndef generate_random_number(num_bytes):\\r\\n    return secrets.token_bytes(num_bytes)\\r\\n\\r\\n# Perform calculations with high precision\\r\\ndecimal_context = decimal.Context(prec=100)  # Set the desired precision\\r\\n\\r\\n# Usage examples\\r\\nuser_input = input(\"Enter a value: \")\\r\\nallowed_chars = set(\"0123456789\")\\r\\n\\r\\nif validate_input(user_input, allowed_chars):\\r\\n    try:\\r\\n        # Perform operations with the user input\\r\\n        value = decimal.Decimal(user_input, context=decimal_context)\\r\\n        result = value ** 2\\r\\n        print(f\"Result: {result}\")\\r\\n    except decimal.InvalidOperation as e:\\r\\n        error_handler(f\"Invalid operation: {e}\")\\r\\nelse:\\r\\n    error_handler(\"Invalid input characters\")\\r\\n\\r\\n# Generate a secure random number\\r\\nrandom_bytes = generate_random_number(32)\\r\\nprint(f\"Random bytes: {random_bytes}\")\\r\\n\\r\\n# Data protection example\\r\\nsensitive_data = \"This is sensitive information\"\\r\\nencryption_key = os.urandom(32)  # Generate a secure encryption key\\r\\n\\r\\nencrypted_data = encrypt_data(sensitive_data, encryption_key)\\r\\ndecrypted_data = decrypt_data(encrypted_data, encryption_key)\\r\\n\\r\\nprint(f\"Original data: {sensitive_data}\")\\r\\nprint(f\"Decrypted data: {decrypted_data}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124. ", "BP": ["Cryptographically Secure Random Number Generation", "Handling Integer Overflow", "Type-Safe String Formatting", "Handling Large Integer Additions"], "code": "import secrets\\r\\nimport sys\\r\\n\\r\\n# Cryptographically Secure Random Number Generation\\r\\ndef generate_random_int(min_value, max_value):\\r\\n    range_start = max(min_value, 0)\\r\\n    range_end = max_value + 1\\r\\n    return secrets.randbelow(range_end - range_start) + range_start\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = generate_random_int(1001, sys.maxsize)\\r\\nb = generate_random_int(1001, sys.maxsize)\\r\\nc = generate_random_int(1001, sys.maxsize)\\r\\n\\r\\n# Type-Safe String Formatting\\r\\nprint(\"a : {a}\".format(a=a))\\r\\nprint(\"b : {b}\".format(b=b))\\r\\nprint(\"c : {c}\".format(c=c))\\r\\n\\r\\n# Handling Integer Overflow\\r\\nsum1 = a + b + c\\r\\nprint(\"sum: {sum}\".format(sum=sum1))\\r\\n\\r\\n# Handling Large Integer Additions\\r\\nsum2 = (a * (2 ** 64) + b) * (2 ** 64) + c\\r\\nprint(\"sum2: {sum}\".format(sum=sum2))", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": ["secrets module", "absolute difference", "f-string"], "code": "import secrets\\r\\n\\r\\n# Generate a random integer between 10 and 1000 (inclusive)\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Generate another random integer between 10 and 1000 (inclusive)\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference between the two integers\\r\\ndiff = abs(num1 - num2)\\r\\n\\r\\n# Print the results using an f-string\\r\\nprint(f\"The first random number is {num1}, the second random number is {num2}, and the absolute difference between them is {diff}.\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": ["Secrets module", "Separation of Concerns", "Input Validation", "String module"], "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef generate_random_sales():\\r\\n    \"\"\"\\r\\n    Generates a random sales figure between 0 and 100,000.\\r\\n    \"\"\"\\r\\n    return secrets.randbelow(100001)\\r\\n\\r\\ndef validate_month(month_str):\\r\\n    \"\"\"\\r\\n    Validates the input month string.\\r\\n    Returns the month number if valid, otherwise raises a ValueError.\\r\\n    \"\"\"\\r\\n    valid_months = {month.lower(): index + 1 for index, month in enumerate(string.capwords(', '.join([m[:3] for m in ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'])).split(', '))}\\r\\n\\r\\n    if month_str.lower() not in valid_months:\\r\\n        raise ValueError(f\"Invalid month '{month_str}'. Please enter a valid month (e.g., Jan, February).\")\\r\\n\\r\\n    return valid_months[month_str.lower()]\\r\\n\\r\\ndef get_monthly_sales(month):\\r\\n    \"\"\"\\r\\n    Generates and returns the monthly sales for a given month.\\r\\n    \"\"\"\\r\\n    return generate_random_sales()\\r\\n\\r\\ndef print_quarterly_sales(quarterly_sales):\\r\\n    \"\"\"\\r\\n    Prints the quarterly sales figures.\\r\\n    \"\"\"\\r\\n    for quarter, sales in enumerate(quarterly_sales, start=1):\\r\\n        print(f\"Quarter {quarter} sales: {sales}\")\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to get monthly sales and print quarterly sales.\\r\\n    \"\"\"\\r\\n    quarterly_sales = [0, 0, 0, 0]\\r\\n\\r\\n    for _ in range(12):\\r\\n        try:\\r\\n            month_number = validate_month(input(\"Enter a month (e.g., Jan, February): \"))\\r\\n        except ValueError as e:\\r\\n            print(e)\\r\\n            continue\\r\\n\\r\\n        quarter_index = (month_number - 1) // 3\\r\\n        quarterly_sales[quarter_index] += get_monthly_sales(month_number)\\r\\n\\r\\n    print_quarterly_sales(quarterly_sales)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": ["secrets module", "hashlib module", "Modularity and Reusability", "secure execution"], "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\n# Define a function to securely generate random sales values\\r\\ndef get_monthly_sales(month):\\r\\n    # Generate a secure random token\\r\\n    token = secrets.token_hex(16)\\r\\n    \\r\\n    # Hash the token using SHA-256\\r\\n    hashed_token = hashlib.sha256(token.encode()).hexdigest()\\r\\n    \\r\\n    # Use the hashed token to generate a random sales value\\r\\n    sales_value = int(hashed_token, 16) % 100000  # Assuming sales values are 5-digit numbers\\r\\n    \\r\\n    print(f\"Month {month + 1} sales: {sales_value}\")\\r\\n    return sales_value\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    # Initialize the total sales to 0\\r\\n    total_sales = 0\\r\\n    \\r\\n    # Iterate over the first quarter (3 months)\\r\\n    for month in range(3):\\r\\n        # Get the monthly sales securely\\r\\n        monthly_sales = get_monthly_sales(month)\\r\\n        \\r\\n        # Add the monthly sales to the total\\r\\n        total_sales += monthly_sales\\r\\n    \\r\\n    print(f\"\\nTotal sales for the first quarter: {total_sales}\")\\r\\n\\r\\n# Call the main function\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": ["Secrets Module", "f-string", "Secure Execution", "Input Validation"], "code": "import secrets\\r\\nimport re\\r\\n\\r\\ndef main():\\r\\n    # Validate user input for sales\\r\\n    def validate_sales(sales_input):\\r\\n        if not re.match(r'^[0-9]+(\\.[0-9]+)?$', sales_input):\\r\\n            raise ValueError(\"Invalid input. Please enter a valid number.\")\\r\\n        return float(sales_input)\\r\\n\\r\\n    # Generate a secure random token\\r\\n    token = secrets.token_urlsafe(16)\\r\\n\\r\\n    # Initialize total sales\\r\\n    total_sales = 0.0\\r\\n\\r\\n    # Get sales for each month with input validation\\r\\n    try:\\r\\n        jan_sales = validate_sales(input(f\"Enter sales for January ({token}): \"))\\r\\n        feb_sales = validate_sales(input(f\"Enter sales for February ({token}): \"))\\r\\n        mar_sales = validate_sales(input(f\"Enter sales for March ({token}): \"))\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return\\r\\n\\r\\n    # Calculate total sales\\r\\n    total_sales = jan_sales + feb_sales + mar_sales\\r\\n\\r\\n    # Print total sales\\r\\n    print(f\"Total sales: {total_sales:.2f}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page.", "BP": ["Password Hashing", "Secure Secret Key", "Session Management", "Input Validation", "Error Handling and Logging", "Secure Redirect", "Security Headers", "Template Rendering", "HTTPS", "CSRF Protection", "Rate Limiting", "Regular Security Audits"], "code": "import os\\r\\nimport bcrypt\\r\\nfrom flask import Flask, render_template, request, redirect, session, abort, make_response\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Set a secure secret key for session management\\r\\napp.secret_key = os.environ.get('SECRET_KEY', 'your_secure_secret_key_here')\\r\\n\\r\\n# Enable CSRF protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        '\\'unsafe-inline\\'',\\r\\n        'stackpath.bootstrapcdn.com',\\r\\n        'code.jquery.com'\\r\\n    ]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Fake database for demonstration purposes\\r\\nusers = {\\r\\n    'admin': generate_password_hash('password123', method='bcrypt')\\r\\n}\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit('5/minute')\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter both username and password.')\\r\\n\\r\\n        # Check if user exists and password is correct\\r\\n        if username in users:\\r\\n            if check_password_hash(users[username], password):\\r\\n                session['user'] = username\\r\\n                return redirect('/dashboard')\\r\\n            else:\\r\\n                app.logger.warning(f'Failed login attempt for user {username}')\\r\\n                return render_template('login.html', error='Invalid username or password.')\\r\\n        else:\\r\\n            app.logger.warning(f'Failed login attempt for non-existent user {username}')\\r\\n            return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Dashboard route\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user' not in session:\\r\\n        abort(403)\\r\\n\\r\\n    return render_template('dashboard.html', user=session['user'])\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(403)\\r\\ndef forbidden(error):\\r\\n    return render_template('error.html', error='Forbidden'), 403\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef not_found(error):\\r\\n    return render_template('error.html', error='Page not found'), 404\\r\\n\\r\\n# Secure headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Secure Jinja template rendering\\r\\n@app.context_processor\\r\\ndef override_url_for():\\r\\n    return dict(url_for=dated_url_for)\\r\\n\\r\\ndef dated_url_for(endpoint, **values):\\r\\n    if endpoint == 'static':\\r\\n        filename = values.get('filename', None)\\r\\n        if filename:\\r\\n            file_path = os.path.join(app.root_path, endpoint, filename)\\r\\n            values['q'] = int(os.stat(file_path).st_mtime)\\r\\n    return url_for(endpoint, **values)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the app securely on HTTPS\\r\\n    app.run(ssl_context='adhoc', debug=False)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": ["Password Hashing", "Import SQLAlchemy", "Session Management", "Input Validation", "HTTPS", "CSRF Protection"], "code": "from flask import Flask, render_template, request, redirect, url_for, session\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1)  # HTTPS support\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(20), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(60), nullable=False)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return f\"User('{self.username}')\"\\r\\n\\r\\n@app.before_request\\r\\ndef session_management():\\r\\n    session.permanent = True\\r\\n    app.permanent_session_lifetime = timedelta(minutes=30)  # Set session timeout\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        if not validate_input(username, password):\\r\\n            return render_template('login.html', error='Invalid input')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid credentials')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' in session:\\r\\n        return render_template('home.html')\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\ndef validate_input(username, password):\\r\\n    username_regex = r'^[\\w]{4,20}$'\\r\\n    password_regex = r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])[\\w@#$%^&+=]{8,}$'\\r\\n\\r\\n    if not re.match(username_regex, username):\\r\\n        return False\\r\\n    if not re.match(password_regex, password):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n        # Create sample user\\r\\n        password_hash = bcrypt.generate_password_hash('Password123@').decode('utf-8')\\r\\n        user = User(username='admin', password=password_hash)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": ["Password Hashing", "Password Verification", "Session Management", "Secret Key", "Input Validation", "Error Handling", "Logout Functionality"], "code": "import os\\r\\nimport bcrypt\\r\\nfrom flask import Flask, render_template, request, redirect, session, url_for, flash\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure secret key\\r\\n\\r\\n# Database simulation (replace with your actual database implementation)\\r\\nusers = {\\r\\n    \"admin\": {\\r\\n        \"password_hash\": b'$2b$12$9WdMbgMySXNl2eSfrohWAOZpQHLhp8zYqkx7gtOYoEQ.C8ECq7BxW',  # hashed password: \"password123\"\\r\\n        \"is_active\": True\\r\\n    }\\r\\n}\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Please enter both username and password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Check if the user exists in the database\\r\\n        user = users.get(username)\\r\\n        if not user or not user['is_active']:\\r\\n            flash('Invalid username or password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Verify the password\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), user['password_hash']):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            flash('Invalid username or password', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'username' not in session:\\r\\n        flash('You are not logged in', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    username = session['username']\\r\\n    return render_template('home.html', username=username)\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    flash('You have been logged out', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": ["Password Hashing", "Import SQLAlchemy", "Error Handling", "Session Management", "Input Validation", "Principle of Least Privilege", "Secure Configuration", "HTTPS", "CSRF Protection", "Content Security Policy"], "code": "import os\\r\\nfrom flask import Flask, render_template, redirect, request, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure Flask app\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'super_secret_key')\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///app.db')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Initialize Talisman for security headers\\r\\ncsp = {\\r\\n    'default-src': ['\\'self\\'']\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Routes\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Validate input\\r\\n        if not username or not password:\\r\\n            return redirect('/cant_login')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/success')\\r\\n        else:\\r\\n            return redirect('/cant_login')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/success')\\r\\ndef success():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/')\\r\\n    return 'Success! You are logged in.'\\r\\n\\r\\n@app.route('/cant_login')\\r\\ndef cant_login():\\r\\n    return 'Invalid username or password. Please try again.'\\r\\n\\r\\n@app.route('/internal_server_error')\\r\\ndef internal_server_error():\\r\\n    return 'Internal Server Error'\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    app.logger.error(str(e))\\r\\n    return redirect('/internal_server_error')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Create database\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n\\r\\n    # Run app\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Password Comparison", "Separation of Concerns", "Secure Redirect", "Error Handling", "CSRF Protection", "HTTPS", "Account Lockout Policies"], "code": "import hashlib\\r\\nimport os\\r\\nfrom flask import Flask, render_template, request, redirect, session\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom datetime import datetime, timedelta\\r\\n\\r\\n# Flask app configuration\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a random secret key for session management\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# Database of users (for demonstration purposes)\\r\\nusers = {\\r\\n    'admin': {\\r\\n        'password_hash': hashlib.sha256(b'securepassword').hexdigest(),\\r\\n        'failed_attempts': 0,\\r\\n        'lockout_time': None\\r\\n    }\\r\\n}\\r\\n\\r\\n# Maximum allowed failed login attempts\\r\\nMAX_FAILED_ATTEMPTS = 5\\r\\n\\r\\n# Account lockout duration (in minutes)\\r\\nLOCKOUT_DURATION = 30\\r\\n\\r\\n# Helper function to check if an account is locked\\r\\ndef is_account_locked(username):\\r\\n    if username in users:\\r\\n        user = users[username]\\r\\n        if user['lockout_time'] is not None:\\r\\n            if datetime.now() < user['lockout_time']:\\r\\n                return True\\r\\n    return False\\r\\n\\r\\n# Helper function to lock an account\\r\\ndef lock_account(username):\\r\\n    if username in users:\\r\\n        user = users[username]\\r\\n        user['lockout_time'] = datetime.now() + timedelta(minutes=LOCKOUT_DURATION)\\r\\n        user['failed_attempts'] = 0\\r\\n\\r\\n# Helper function to reset failed login attempts\\r\\ndef reset_failed_attempts(username):\\r\\n    if username in users:\\r\\n        users[username]['failed_attempts'] = 0\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username', '').strip()\\r\\n        password = request.form.get('password', '').strip()\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter both username and password.')\\r\\n\\r\\n        # Check if the account is locked\\r\\n        if is_account_locked(username):\\r\\n            return render_template('login.html', error='Your account is temporarily locked due to too many failed login attempts. Please try again later.')\\r\\n\\r\\n        # Retrieve user from the database\\r\\n        if username in users:\\r\\n            user = users[username]\\r\\n            password_hash = user['password_hash']\\r\\n\\r\\n            # Password comparison using a secure method\\r\\n            if hashlib.sha256(password.encode()).hexdigest() == password_hash:\\r\\n                # Reset failed login attempts\\r\\n                reset_failed_attempts(username)\\r\\n\\r\\n                # Set the session and redirect to the dashboard\\r\\n                session['username'] = username\\r\\n                return redirect('/dashboard', code=302)  # Use 302 for secure redirect\\r\\n\\r\\n            # Incorrect password\\r\\n            user['failed_attempts'] += 1\\r\\n            if user['failed_attempts'] >= MAX_FAILED_ATTEMPTS:\\r\\n                lock_account(username)\\r\\n                return render_template('login.html', error='Too many failed login attempts. Your account has been temporarily locked.')\\r\\n\\r\\n        # Invalid username\\r\\n        return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    # Render the login page for GET requests\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Dashboard route (accessible only after successful login)\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome to the dashboard, {session['username']}!\"\\r\\n    else:\\r\\n        return redirect('/login')  # Redirect to the login page if not authenticated\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=8000,  , ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Secure Redirect", "Logout Functionality", "CSRF protection", "Rate Limiting", "Secure Headers"], "code": "import os\\r\\nfrom flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a random secret key\\r\\n\\r\\n# CSRF protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, id, username, password_hash):\\r\\n        self.id = id\\r\\n        self.username = username\\r\\n        self.password_hash = password_hash\\r\\n\\r\\n# In-memory user database (replace with a proper database in production)\\r\\nusers = {\\r\\n    1: User(1, 'admin', generate_password_hash('strongpassword'))\\r\\n}\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return users.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limiting\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username', '').strip()\\r\\n        password = request.form.get('password', '')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = next((user for user in users.values() if user.username == username), None)\\r\\n        if user and check_password_hash(user.password_hash, password):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('session'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/session', methods=['GET'])\\r\\n@login_required\\r\\ndef session():\\r\\n    return render_template('session.html', username=current_user.username)\\r\\n\\r\\n@app.route('/logout', methods=['GET'])\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": ["Flask Framework", "Secure Session Management", "Input Validation", "Input Sanitization", "Secure Handling", "Separation of Concerns", "Secure Redirect"], "code": "from flask import Flask, session, redirect, request, escape\\r\\nfrom flask_session import Session\\r\\nimport os\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure random secret key\\r\\n\\r\\n# Configure secure session management\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\nSession(app)\\r\\n\\r\\n# Input validation and sanitization functions\\r\\ndef validate_username(username):\\r\\n    # Check if the username contains only alphanumeric characters and underscore\\r\\n    return bool(re.match(r'^[\\w]+$', username))\\r\\n\\r\\ndef validate_email(email):\\r\\n    # Use a regular expression to validate the email format\\r\\n    email_regex = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(email_regex, email))\\r\\n\\r\\ndef validate_ssn(ssn):\\r\\n    # Check if the SSN is a 9-digit number\\r\\n    return bool(re.match(r'^\\d{9}$', ssn))\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    # Escape any special characters in the input string\\r\\n    return escape(input_str)\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Check if the user is authenticated\\r\\n    if 'username' not in session or 'email' not in session or 'ssn' not in session:\\r\\n        return redirect('/login')  # Redirect to the login page if not authenticated\\r\\n\\r\\n    # Retrieve and validate the user data from the session\\r\\n    username = session.get('username')\\r\\n    email = session.get('email')\\r\\n    ssn = session.get('ssn')\\r\\n\\r\\n    if not validate_username(username) or not validate_email(email) or not validate_ssn(ssn):\\r\\n        return redirect('/login')  # Redirect to the login page if user data is invalid\\r\\n\\r\\n    # Sanitize the user data\\r\\n    sanitized_username = sanitize_input(username)\\r\\n    sanitized_email = sanitize_input(email)\\r\\n    sanitized_ssn = sanitize_input(ssn[-4:])  # Display only the last 4 digits of the SSN\\r\\n\\r\\n    # Render the info page with the sanitized user data\\r\\n    return f'Username: {sanitized_username}<br>Email: {sanitized_email}<br>Last 4 digits of SSN: {sanitized_ssn}'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)  # Run the Flask app in production mode (without debug)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": ["Secure Password Storage", "Sensitive Data Protection", "Secure Key Generation", "Input Validation", "Input Sanitizzation", "Secure Headers", "Disable Debug Mode", "User Authentication", "Database Management", "HTTPS", "Rate Limiting", "Logging and Monitoring"], "code": "import os\\r\\nimport bcrypt\\r\\nimport secrets\\r\\nimport logging\\r\\nfrom flask import Flask, request, render_template, redirect, url_for, make_response\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nimport sqlite3\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_urlsafe(32)  # Generate a secure secret key\\r\\n\\r\\n# Configure Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Enable security headers\\r\\ncsp = {\\r\\n    'default-src': [\"'self'\"]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# Connect to SQLite database\\r\\nconn = sqlite3.connect('users.db', check_same_thread=False)\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT PRIMARY KEY, email TEXT, password TEXT, ssn TEXT)''')\\r\\n\\r\\n# User authentication and password hashing\\r\\ndef authenticate_user(username, password):\\r\\n    c.execute(\"SELECT password FROM users WHERE username = ?\", (username,))\\r\\n    result = c.fetchone()\\r\\n    if result:\\r\\n        hashed_password = result[0]\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8')):\\r\\n            return True\\r\\n    return False\\r\\n\\r\\ndef hash_password(password):\\r\\n    salt = bcrypt.gensalt()\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed_password.decode('utf-8')\\r\\n\\r\\n# Secure route for user information\\r\\n@app.route('/info', methods=['GET'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef info():\\r\\n    # Authenticate user\\r\\n    auth = request.authorization\\r\\n    if not auth or not authenticate_user(auth.username, auth.password):\\r\\n        return make_response('Could not verify your login credentials', 401, {'WWW-Authenticate': 'Basic realm=\"Login Required\"'})\\r\\n\\r\\n    # Get user data from database\\r\\n    c.execute(\"SELECT email, ssn FROM users WHERE username = ?\", (auth.username,))\\r\\n    result = c.fetchone()\\r\\n    if result:\\r\\n        email, ssn = result\\r\\n        ssn_last4 = ssn[-4:]  # Only show last 4 digits of SSN\\r\\n        return render_template('info.html', username=auth.username, email=email, ssn_last4=ssn_last4)\\r\\n    else:\\r\\n        return \"User not found\"\\r\\n\\r\\n# Route for user registration\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n        ssn = request.form['ssn']\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not email or not password or not ssn:\\r\\n            return \"Please provide all required fields\"\\r\\n        if len(ssn) != 9 or not ssn.isdigit():\\r\\n            return \"Invalid social security number format\"\\r\\n\\r\\n        # Input sanitization\\r\\n        username = username.strip()\\r\\n        email = email.strip()\\r\\n        password = password.strip()\\r\\n        ssn = ssn.strip()\\r\\n\\r\\n        # Check if user already exists\\r\\n        c.execute(\"SELECT * FROM users WHERE username = ?\", (username,))\\r\\n        result = c.fetchone()\\r\\n        if result:\\r\\n            return \"Username already taken\"\\r\\n\\r\\n        # Hash password and store user data in database\\r\\n        hashed_password = hash_password(password)\\r\\n        c.execute(\"INSERT INTO users (username, email, password, ssn) VALUES (?, ?, ?, ?)\", (username, email, hashed_password, ssn))\\r\\n        conn.commit()\\r\\n\\r\\n        return redirect(url_for('info'))\\r\\n    return render_template('register.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Disable debug mode in production\\r\\n    app.debug = False\\r\\n\\r\\n    # Run the app securely over HTTPS\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": ["Environment Variables", "Authentication Check", "Input Escaping", "Sensitive Data Masking", "Production Mode", "Secure storage", "Input Validation"], "code": "import os\\r\\nfrom flask import Flask, session, redirect, url_for, escape, request\\r\\nfrom flask_login import LoginManager, UserMixin, login_required, current_user\\r\\nfrom dotenv import load_dotenv\\r\\nimport bcrypt\\r\\nimport re\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\nSECRET_KEY = os.getenv(\"SECRET_KEY\")\\r\\nSALT = bcrypt.gensalt()\\r\\n\\r\\n# Flask app setup\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = SECRET_KEY\\r\\n\\r\\n# Flask-Login setup\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\n\\r\\n# User model for authentication\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, username, email, ssn):\\r\\n        self.username = username\\r\\n        self.email = email\\r\\n        self.ssn = ssn\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    # Load user from your data source here\\r\\n    pass\\r\\n\\r\\n# Input validation functions\\r\\ndef validate_username(username):\\r\\n    # Implement username validation rules\\r\\n    pattern = r'^[a-zA-Z0-9_]+$'\\r\\n    return bool(re.match(pattern, username))\\r\\n\\r\\ndef validate_email(email):\\r\\n    # Implement email validation rules\\r\\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(pattern, email))\\r\\n\\r\\ndef validate_ssn(ssn):\\r\\n    # Implement SSN validation rules\\r\\n    pattern = r'^\\d{9}$'\\r\\n    return bool(re.match(pattern, ssn))\\r\\n\\r\\n# Route for /info\\r\\n@app.route('/info', methods=['GET'])\\r\\n@login_required\\r\\ndef info():\\r\\n    # Check if user is authenticated\\r\\n    if current_user.is_authenticated:\\r\\n        # Retrieve user data from session\\r\\n        username = escape(session.get('username', ''))\\r\\n        email = escape(session.get('email', ''))\\r\\n        ssn = session.get('ssn', '')\\r\\n\\r\\n        # Mask sensitive data\\r\\n        masked_ssn = '***-**-' + ssn[-4:]\\r\\n\\r\\n        # Return user information as a string\\r\\n        info_str = f\"Username: {username}\\nEmail: {email}\\nSSN: {masked_ssn}\"\\r\\n        return info_str\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n# Production mode configuration\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False, host='0.0.0.0', port=5000)", "CWE": "CWE-200"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": ["Secret Key Generation", "Password Hashing", "Password Verification", "Password Complexity Requirements", "Input Validation", "Session Management", "Access Control", "Error Handling", "Secure Redirect", "HTTPS", "Security Headers", "Logging and Monitoring", "rate-limiting", "CSRF protection"], "code": "import os\\r\\nimport bcrypt\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_urlsafe(32)  # Generate secure secret key\\r\\n\\r\\n# Password complexity requirements\\r\\nPASSWORD_MIN_LENGTH = 8\\r\\nPASSWORD_MAX_LENGTH = 64\\r\\nPASSWORD_COMPLEXITY_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$'\\r\\n\\r\\n# Rate limiting\\r\\nfrom flask_limiter import Limiter\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr, default_limits=[\"10 per minute\"])\\r\\n\\r\\n# CSRF protection\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Configure security headers\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Authenticated users\\r\\nusers = {\\r\\n    'admin': bcrypt.hashpw('securePassword123!'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n}\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please provide both username and password.')\\r\\n\\r\\n        if len(password) < PASSWORD_MIN_LENGTH or len(password) > PASSWORD_MAX_LENGTH:\\r\\n            return render_template('login.html', error='Password must be between 8 and 64 characters long.')\\r\\n\\r\\n        import re\\r\\n        if not re.match(PASSWORD_COMPLEXITY_REGEX, password):\\r\\n            return render_template('login.html', error='Password must contain at least one uppercase letter, one lowercase letter, one digit, and one special character.')\\r\\n\\r\\n        # Password verification\\r\\n        if username in users and bcrypt.checkpw(password.encode('utf-8'), users[username].encode('utf-8')):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('secret.html')\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=8000, debug=False, ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": ["secrets key", "user roles", "User Data Management", "Login and Logout Functionality", "Authentication and Authorization Decorators", "Route Handling", "Secure Session Management", "Role-Based Access Control (RBAC)", "Separation of Concerns", "Error Handling", "password hashing", "HTTPS", "CSRF protection", "Input Validation"], "code": "import secrets\\r\\nimport hashlib\\r\\nimport functools\\r\\nfrom flask import Flask, session, redirect, url_for, request, render_template, abort, g\\r\\nfrom flask_wtf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)  # Generate a secure secret key\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# In-memory user data for demonstration purposes\\r\\nusers = {\\r\\n    'admin': {\\r\\n        'password': hashlib.sha256('admin_password'.encode()).hexdigest(),\\r\\n        'role': 'admin'\\r\\n    },\\r\\n    'user': {\\r\\n        'password': hashlib.sha256('user_password'.encode()).hexdigest(),\\r\\n        'role': 'user'\\r\\n    }\\r\\n}\\r\\n\\r\\n# Decorator to check if the user is logged in\\r\\ndef login_required(view):\\r\\n    @functools.wraps(view)\\r\\n    def wrapped_view(**kwargs):\\r\\n        if 'user' not in session:\\r\\n            return redirect(url_for('login'))\\r\\n        return view(**kwargs)\\r\\n    return wrapped_view\\r\\n\\r\\n# Decorator to check if the user is an admin\\r\\ndef admin_required(view):\\r\\n    @functools.wraps(view)\\r\\n    def wrapped_view(**kwargs):\\r\\n        if 'user' not in session or users[session['user']]['role'] != 'admin':\\r\\n            abort(403)  # Forbidden\\r\\n        return view(**kwargs)\\r\\n    return wrapped_view\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        if username in users and users[username]['password'] == hashlib.sha256(password.encode()).hexdigest():\\r\\n            session['user'] = username\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid username or password')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# User page route\\r\\n@app.route('/user')\\r\\n@login_required\\r\\ndef user_page():\\r\\n    return render_template('user.html')\\r\\n\\r\\n# Admin page route\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\n@admin_required\\r\\ndef admin_page():\\r\\n    return render_template('admin.html')\\r\\n\\r\\n# Index route\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    if 'user' in session:\\r\\n        if users[session['user']]['role'] == 'admin':\\r\\n            return redirect(url_for('admin_page'))\\r\\n        else:\\r\\n            return redirect(url_for('user_page'))\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc',  )  # Enable HTTPS for secure communication", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return. ", "BP": ["Password hashing", "Session management", "CSRF protection", "Input validation", "Separation of concerns", "HTTPS", "rate-limiting"], "code": "from flask import Flask, render_template, request, redirect, session, url_for, abort\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport re\\r\\nimport bcrypt\\r\\nimport sqlite3\\r\\nimport time\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Replace with a secure random string\\r\\n\\r\\n# Rate limiting variables\\r\\nlast_request_time = {}\\r\\nMAX_REQUESTS_PER_MINUTE = 10\\r\\n\\r\\n# CSRF protection\\r\\nimport secrets\\r\\ncsrf_token = secrets.token_urlsafe(32)\\r\\n\\r\\n# Database connection\\r\\nconn = sqlite3.connect('users.db')\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT PRIMARY KEY, password TEXT, role TEXT)''')\\r\\nconn.commit()\\r\\n\\r\\n# Utility functions\\r\\ndef is_valid_password(password):\\r\\n    # Password validation rules (e.g., minimum length, required characters)\\r\\n    return len(password) >= 8 and re.search(r'\\d', password) and re.search(r'[a-z]', password) and re.search(r'[A-Z]', password)\\r\\n\\r\\ndef rate_limit(ip_address):\\r\\n    current_time = time.time()\\r\\n    if ip_address in last_request_time:\\r\\n        last_time = last_request_time[ip_address]\\r\\n        elapsed_time = current_time - last_time\\r\\n        if elapsed_time < 60:\\r\\n            remaining_time = 60 - elapsed_time\\r\\n            abort(429, f\"Too many requests. Please try again in {remaining_time:.0f} seconds.\")\\r\\n    last_request_time[ip_address] = current_time\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    rate_limit(request.remote_addr)\\r\\n    return render_template('login.html', csrf_token=csrf_token)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\ndef do_login():\\r\\n    rate_limit(request.remote_addr)\\r\\n    if request.form.get('csrf_token') != csrf_token:\\r\\n        abort(403)  # Reject the request if CSRF token is invalid\\r\\n\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        return 'Please enter both username and password.'\\r\\n    if not is_valid_password(password):\\r\\n        return 'Password does not meet the requirements.'\\r\\n\\r\\n    c.execute(\"SELECT * FROM users WHERE username=?\", (username,))\\r\\n    user = c.fetchone()\\r\\n\\r\\n    if user:\\r\\n        hashed_password = user[1]\\r\\n        if check_password_hash(hashed_password, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            return 'Invalid username or password.'\\r\\n    else:\\r\\n        return 'Invalid username or password.'\\r\\n\\r\\n@app.route('/user_page')\\r\\ndef user_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return f\"Welcome, {session['username']}!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": ["Password Hashing", "Session Management", "Access Control", "Input Validation", "Secure Redirection", "Separation of Concerns", "HTTPS", "CSRF protection", "rate limiting", "Secure Cryptographic Functions", "Error handling", "Logging and Monitoring", "Security Headers", "Secure Secret Management"], "code": "import os\\r\\nimport hashlib\\r\\nimport hmac\\r\\nimport time\\r\\nfrom functools import wraps\\r\\nfrom flask import Flask, request, session, redirect, url_for, render_template, make_response\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables from .env file\\r\\nload_dotenv()\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.environ.get('SECRET_KEY', 'default_secret_key')\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Configure rate limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Define user database (replace with a proper database implementation)\\r\\nusers = {\\r\\n    'admin': generate_password_hash('admin_password')\\r\\n}\\r\\n\\r\\n# Decorator for authentication and authorization\\r\\ndef requires_auth(role='user'):\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            if session.get('user') is None:\\r\\n                return redirect(url_for('login'))\\r\\n            if role == 'admin' and session.get('user') != 'admin':\\r\\n                return \"Access denied\", 403\\r\\n            return func(*args, **kwargs)\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n# CSRF protection\\r\\ndef csrf_protect(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        if request.method == 'POST':\\r\\n            token = session.pop('_csrf_token', None)\\r\\n            if not token or token != request.form.get('_csrf_token'):\\r\\n                return \"Invalid CSRF token\", 403\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    session.clear()\\r\\n    session['_csrf_token'] = hmac.new(\\r\\n        key=app.secret_key.encode('utf-8'),\\r\\n        msg=os.urandom(32),\\r\\n        digestmod=hashlib.sha256\\r\\n    ).hexdigest()\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@csrf_protect\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef do_login():\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        return \"Invalid input\", 400\\r\\n\\r\\n    if username in users:\\r\\n        if check_password_hash(users[username], password):\\r\\n            session['user'] = username\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            return \"Invalid username or password\", 401\\r\\n    else:\\r\\n        return \"Invalid username or password\", 401\\r\\n\\r\\n@app.route('/', methods=['GET'])\\r\\n@requires_auth()\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/user', methods=['GET'])\\r\\n@requires_auth()\\r\\ndef user_page():\\r\\n    return render_template('user.html')\\r\\n\\r\\n@app.route('/admin', methods=['GET'])\\r\\n@requires_auth(role='admin')\\r\\ndef admin_page():\\r\\n    return render_template('admin.html')\\r\\n\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    app.logger.error(f'Internal Server Error: {str(e)}')\\r\\n    return render_template('500.html'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email.", "BP": ["Password Hashing", "Input Validation", "Session Management", "Separation of Concerns", "Secure Redirects", "HTTPS", "User Account Management", "Rate Limiting", "Brute-Force Protection", "Security Headers", "Security Logging", "Secure Redirects", "User Account Management", "Security Logging", "Security Headers", "CSRF Protection", "Input Sanitization"], "code": "import bcrypt\\r\\nimport re\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(32)  # Generate a secure secret key\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)  # Set secure proxy headers\\r\\n\\r\\n# Password Hashing\\r\\ndef hash_password(password):\\r\\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n\\r\\ndef verify_password(password, hashed_password):\\r\\n    return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))\\r\\n\\r\\n# Input Validation\\r\\ndef validate_email(email):\\r\\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(pattern, email))\\r\\n\\r\\n# Rate Limiting and Brute-Force Protection\\r\\nATTEMPTS_ALLOWED = 5\\r\\nUSER_ATTEMPTS = {}\\r\\n\\r\\n# User Account Management\\r\\nUSERS = {\\r\\n    'user@example.com': {\\r\\n        'password': hash_password('password'),\\r\\n        'email': 'user@example.com'\\r\\n    }\\r\\n}\\r\\n\\r\\n# CSRF Protection\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return 'CSRF Protection Failed', 403\\r\\n\\r\\n# Security Headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Referrer-Policy'] = 'no-referrer'\\r\\n    return response\\r\\n\\r\\n# Security Logging\\r\\nimport logging\\r\\nlogging.basicConfig(filename='security.log', level=logging.INFO)\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    if 'user' in session:\\r\\n        return render_template('dashboard.html')\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not validate_email(email):\\r\\n            logging.warning(f'Invalid email: {email}')\\r\\n            return 'Invalid email', 400\\r\\n\\r\\n        user = USERS.get(email)\\r\\n        if not user or not verify_password(password, user['password']):\\r\\n            logging.warning(f'Failed login attempt for {email}')\\r\\n            ip_address = request.remote_addr\\r\\n            attempts = USER_ATTEMPTS.get(ip_address, 0)\\r\\n            attempts += 1\\r\\n            USER_ATTEMPTS[ip_address] = attempts\\r\\n            if attempts >= ATTEMPTS_ALLOWED:\\r\\n                logging.warning(f'Brute-force attempt detected from {ip_address}')\\r\\n                return 'Too many failed login attempts', 429\\r\\n\\r\\n            return 'Invalid email or password', 401\\r\\n\\r\\n        session['user'] = email\\r\\n        logging.info(f'User {email} logged in')\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\ndef change_email():\\r\\n    if 'user' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = session['user']\\r\\n        new_email = request.form['new_email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not validate_email(new_email):\\r\\n            logging.warning(f'Invalid new email: {new_email}')\\r\\n            return 'Invalid new email', 400\\r\\n\\r\\n        if new_email == old_email:\\r\\n            logging.warning(f'New email cannot be the same as old email for user {old_email}')\\r\\n            return 'New email cannot be the same as old email', 400\\r\\n\\r\\n        user = USERS.get(old_email)\\r\\n        if not user or not verify_password(password, user['password']):\\r\\n            logging.warning(f'Failed change email attempt for user {old_email}')\\r\\n            return 'Invalid password', 401\\r\\n\\r\\n        USERS[new_email] = user\\r\\n        del USERS[old_email]\\r\\n        USERS[new_email]['email'] = new_email\\r\\n        session['user'] = new_email\\r\\n\\r\\n        logging.info(f'User {old_email} changed email to {new_email}')\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    return render_template('change_email.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    if 'user' in session:\\r\\n        email = session['user']\\r\\n        session.pop('user', None)\\r\\n        logging.info(f'User {email} logged out')\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n@app.before_request\\r\\ndef generate_csrf_token():\\r\\n    if request.method == \"POST\":\\r\\n        session['_csrf_token'] = secrets.token_urlsafe(32)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": ["Form Validation", "Error Handling and Logging", "CSRF Protection", "Secure Headers", "Password Hashing", "Secure Secret Key", "Input Validation", "Password Verification", "User Authentication", "Rate Limiting"], "code": "import os\\r\\nimport logging\\r\\nfrom datetime import datetime, timedelta\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for, flash\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport bcrypt\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(32)  # Secure secret key\\r\\n\\r\\n# CSRF Protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\nTalisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"100 per minute\", \"1 per second\"],\\r\\n)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# User data (replace with a database in a real application)\\r\\nusers = {\\r\\n    'user@example.com': {\\r\\n        'password_hash': generate_password_hash('password123'),\\r\\n    },\\r\\n}\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form.get('email')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not email or not password:\\r\\n            flash('Please provide both email and password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # User authentication\\r\\n        if email not in users or not check_password_hash(users[email]['password_hash'], password):\\r\\n            flash('Invalid email or password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        session['email'] = email\\r\\n        return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef change_email():\\r\\n    if 'email' not in session:\\r\\n        flash('You must be logged in to access this page', 'error')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = session['email']\\r\\n        new_email = request.form.get('new_email')\\r\\n        confirm_password = request.form.get('confirm_password')\\r\\n\\r\\n        # Input validation\\r\\n        if not new_email or not confirm_password:\\r\\n            flash('Please provide both new email and confirm password', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        # Password verification\\r\\n        if not check_password_hash(users[old_email]['password_hash'], confirm_password):\\r\\n            flash('Incorrect confirm password', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        # Update email\\r\\n        if new_email in users:\\r\\n            flash('Email already exists', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        users[new_email] = users.pop(old_email)\\r\\n        session['email'] = new_email\\r\\n        flash('Email changed successfully', 'success')\\r\\n        return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('change_email.html', email=session['email'])\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": ["Password Hashing", "Password Verification", "Authentication", "Email Change", "Input Validation", "No Hard-coded Credentials", "Session Management", "CSRF Protection", "Rate Limiting"], "code": "from flask import Flask, render_template, redirect, url_for, flash, request\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nimport os\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Generate a random secret key\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Initialize Flask-Bcrypt\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\n# Initialize Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, username, email, password):\\r\\n        self.username = username\\r\\n        self.email = email\\r\\n        self.password = bcrypt.generate_password_hash(password).decode('utf-8')\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return bcrypt.check_password_hash(self.password, password)\\r\\n\\r\\n    def change_email(self, new_email):\\r\\n        self.email = new_email\\r\\n\\r\\n# Sample user data\\r\\nusers = {\\r\\n    'john': User('john', 'john@example.com', 'password123')\\r\\n}\\r\\n\\r\\n# Login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Log In')\\r\\n\\r\\n# Change email form\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return users.get(user_id)\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = users.get(form.username.data)\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            flash('Logged in successfully.', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef change_email():\\r\\n    form = ChangeEmailForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = load_user(current_user.get_id())\\r\\n        if user.email == form.old_email.data and user.check_password(form.password.data):\\r\\n            user.change_email(form.new_email.data)\\r\\n            flash('Email changed successfully.', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid old email or password.', 'danger')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": ["Input Validation", "Error Handling", "Stack-based allocation", "Explicit buffer size", "Exception handling", "Secure function usage"], "code": "import sys\\r\\nimport ctypes\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(buffer_size):\\r\\n    try:\\r\\n        buffer_size = int(buffer_size)\\r\\n    except ValueError:\\r\\n        print(\"Invalid input: buffer_size must be an integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    if buffer_size <= 0:\\r\\n        print(\"Invalid input: buffer_size must be a positive integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    return buffer_size\\r\\n\\r\\n# Secure Buffer Allocation and Overwrite\\r\\ndef allocate_buffer(buffer_size):\\r\\n    try:\\r\\n        # Stack-based allocation using ctypes\\r\\n        buffer = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n        # Overwrite buffer with 'A'\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n\\r\\n        return buffer\\r\\n\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating buffer: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Error Handling\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <buffer_size>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Input Validation\\r\\n    buffer_size = validate_input(sys.argv[1])\\r\\n\\r\\n    # Secure Buffer Allocation and Overwrite\\r\\n    try:\\r\\n        buffer = allocate_buffer(buffer_size)\\r\\n        print(f\"Buffer of size {buffer_size} allocated and overwritten with 'A':\")\\r\\n        print(buffer.raw)\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        sys.exit(1)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate. The program allocates a buffer of the specified size. The program prints the contents of the buffer. The program exits.", "BP": ["Input Validation", "Reasonable Maximum Buffer Size", "Exception Handling", "Secure Data Types"], "code": "import sys\\r\\nimport os\\r\\n\\r\\n# Define a reasonable maximum buffer size\\r\\nMAX_BUFFER_SIZE = 1024 * 1024  # 1 MB\\r\\n\\r\\n# Input validation\\r\\ntry:\\r\\n    buffer_size = int(sys.argv[1])\\r\\nexcept (IndexError, ValueError):\\r\\n    print(\"Error: Please provide a valid integer buffer size as a command-line argument.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Check for reasonable buffer size\\r\\nif buffer_size <= 0 or buffer_size > MAX_BUFFER_SIZE:\\r\\n    print(f\"Error: Buffer size must be between 1 and {MAX_BUFFER_SIZE} bytes.\")\\r\\n    sys.exit(1)\\r\\n\\r\\ntry:\\r\\n    # Allocate the buffer securely\\r\\n    buffer = bytearray(buffer_size)\\r\\n\\r\\n    # Print the buffer contents\\r\\n    print(f\"Buffer contents: {buffer}\")\\r\\n\\r\\nexcept MemoryError:\\r\\n    print(\"Error: Not enough memory to allocate the buffer.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Exit cleanly\\r\\nsys.exit(0)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code allocates a buffer of size buffer_size. Then it frees the buffer in a loop.", "BP": ["Input Validation", "Secure Random Number Generation", "Memory Allocation and Deallocation", "Error Handling", "Memory Zeroing", "Secure Handling of Sensitive Data"], "code": "import os\\r\\nimport secrets\\r\\nimport ctypes\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(buffer_size):\\r\\n    if not isinstance(buffer_size, int):\\r\\n        raise ValueError(\"buffer_size must be an integer\")\\r\\n    if buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be positive\")\\r\\n\\r\\n# Secure Random Number Generation\\r\\ndef get_random_bytes(num_bytes):\\r\\n    return secrets.token_bytes(num_bytes)\\r\\n\\r\\n# Memory Allocation and Deallocation\\r\\ndef allocate_buffer(buffer_size):\\r\\n    try:\\r\\n        # Allocate buffer using ctypes\\r\\n        buffer = ctypes.create_string_buffer(buffer_size)\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        # Error Handling\\r\\n        print(f\"Error allocating buffer: {e}\")\\r\\n        return None\\r\\n    return buffer\\r\\n\\r\\ndef deallocate_buffer(buffer):\\r\\n    if buffer:\\r\\n        # Memory Zeroing\\r\\n        ctypes.memset(buffer, 0, ctypes.sizeof(buffer))\\r\\n        # Free the buffer\\r\\n        ctypes.free(buffer)\\r\\n\\r\\n# Secure Handling of Sensitive Data\\r\\ndef handle_sensitive_data(buffer, buffer_size):\\r\\n    # Perform operations on the sensitive data\\r\\n    # ...\\r\\n\\r\\n    # Zero out the buffer after use\\r\\n    deallocate_buffer(buffer)\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    # Input Validation\\r\\n    buffer_size = int(input(\"Enter buffer size: \"))\\r\\n    validate_input(buffer_size)\\r\\n\\r\\n    # Secure Random Number Generation\\r\\n    random_bytes = get_random_bytes(buffer_size)\\r\\n\\r\\n    # Memory Allocation\\r\\n    buffer = allocate_buffer(buffer_size)\\r\\n    if buffer:\\r\\n        # Copy random bytes to the buffer\\r\\n        ctypes.memmove(buffer, random_bytes, buffer_size)\\r\\n\\r\\n        # Handle sensitive data\\r\\n        handle_sensitive_data(buffer, buffer_size)\\r\\n\\r\\n    # Memory Deallocation\\r\\n    deallocate_buffer(buffer)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 the buffer is empty. The number of bytes read and the checksum are saved to a file.", "BP": ["Input Validation", "Secure Hashing", "Exception Handling", "File management", "Secure String Formatting"], "code": "import hashlib\\r\\nimport os\\r\\n\\r\\ndef read_and_checksum_file(file_path):\\r\\n    try:\\r\\n        # Open the file in read-binary mode\\r\\n        with open(file_path, 'rb') as file:\\r\\n            # Read the contents of the file into a buffer\\r\\n            buffer = file.read()\\r\\n\\r\\n        # Calculate the checksum of the buffer using a secure hashing algorithm (SHA-256)\\r\\n        checksum = hashlib.sha256(buffer).hexdigest()\\r\\n\\r\\n        # Get the number of bytes read\\r\\n        num_bytes = len(buffer)\\r\\n\\r\\n        # Save the results to a file\\r\\n        save_results(file_path, num_bytes, checksum)\\r\\n\\r\\n        return num_bytes, checksum\\r\\n    except (IOError, OSError) as e:\\r\\n        # Handle file-related exceptions\\r\\n        print(f\"Error: {e.strerror}\")\\r\\n        return 0, \"Error\"\\r\\n\\r\\ndef save_results(file_path, num_bytes, checksum):\\r\\n    # Construct the output file path\\r\\n    output_file = os.path.join(os.path.dirname(file_path), \"results.txt\")\\r\\n\\r\\n    try:\\r\\n        # Open the output file in write mode\\r\\n        with open(output_file, 'w') as file:\\r\\n            # Write the results to the file using secure string formatting\\r\\n            file.write(\"File: {}\\nBytes Read: {}\\nChecksum: {}\\n\".format(os.path.basename(file_path), num_bytes, checksum))\\r\\n    except (IOError, OSError) as e:\\r\\n        # Handle file-related exceptions\\r\\n        print(f\"Error: {e.strerror}\")\\r\\n\\r\\n# Example usage\\r\\ninput_file = \"/path/to/your/file.txt\"\\r\\nnum_bytes, checksum = read_and_checksum_file(input_file)\\r\\n\\r\\nif num_bytes == 0:\\r\\n    print(\"Buffer is empty.\")\\r\\nelse:\\r\\n    print(f\"Number of bytes read: {num_bytes}\")\\r\\n    print(f\"Checksum: {checksum}\")", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 then the buffer is empty. The number of bytes read and the checksum are saved to another file.", "BP": ["Input Validation", "Error Handling", "File Handling", "Cryptographic Security"], "code": "import os\\r\\nimport hashlib\\r\\nfrom typing import Union\\r\\n\\r\\ndef calculate_checksum(data: bytes) -> str:\\r\\n    \"\"\"\\r\\n    Calculate the SHA-256 checksum of the provided data.\\r\\n    \"\"\"\\r\\n    sha256 = hashlib.sha256()\\r\\n    sha256.update(data)\\r\\n    return sha256.hexdigest()\\r\\n\\r\\ndef read_file(file_path: str) -> Union[bytes, None]:\\r\\n    \"\"\"\\r\\n    Read the contents of a file into a bytes buffer.\\r\\n    Perform input validation and error handling.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Check if the file exists\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise ValueError(f\"File not found: {file_path}\")\\r\\n\\r\\n        # Open the file in binary mode\\r\\n        with open(file_path, 'rb') as file:\\r\\n            data = file.read()\\r\\n        return data\\r\\n    except (ValueError, OSError) as e:\\r\\n        print(f\"Error reading file: {e}\")\\r\\n        return None\\r\\n\\r\\ndef write_file(file_path: str, content: bytes) -> bool:\\r\\n    \"\"\"\\r\\n    Write the provided content to a file.\\r\\n    Perform error handling and prevent path traversal.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Check for path traversal\\r\\n        if os.path.isabs(file_path) or '../' in file_path or '..\\\\' in file_path:\\r\\n            raise ValueError(\"Path traversal detected\")\\r\\n\\r\\n        # Create the directory if it doesn't exist\\r\\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\\r\\n\\r\\n        # Open the file in binary mode for writing\\r\\n        with open(file_path, 'wb') as file:\\r\\n            file.write(content)\\r\\n        return True\\r\\n    except (ValueError, OSError) as e:\\r\\n        print(f\"Error writing file: {e}\")\\r\\n        return False\\r\\n\\r\\ndef main():\\r\\n    # Input validation for file paths\\r\\n    input_file_path = input(\"Enter the path to the input file: \").strip()\\r\\n    output_file_path = input(\"Enter the path to the output file: \").strip()\\r\\n\\r\\n    # Read the input file\\r\\n    buffer = read_file(input_file_path)\\r\\n    if buffer is None:\\r\\n        return\\r\\n\\r\\n    # Calculate the checksum\\r\\n    checksum = calculate_checksum(buffer)\\r\\n\\r\\n    # Prepare the output data\\r\\n    output_data = f\"Number of bytes read: {len(buffer)}\\nChecksum: {checksum}\"\\r\\n\\r\\n    # Check if the buffer is empty\\r\\n    if checksum == \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\":  # SHA-256 checksum for an empty string\\r\\n        print(\"Buffer is empty\")\\r\\n    else:\\r\\n        print(\"Buffer is not empty\")\\r\\n\\r\\n    # Write the output file\\r\\n    if write_file(output_file_path, output_data.encode()):\\r\\n        print(f\"Output written to {output_file_path}\")\\r\\n    else:\\r\\n        print(\"Failed to write the output file\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The upload_pdf() function is called when the user uploads a pdf file. The pdf file is saved in the uploads folder. The filepath of the pdf file is saved in the mysql database. The filepath is then used to download the pdf file.", "BP": ["Input Validation", "File Handling", "Error Handling", "Principle of Least Privilege", "Access Control", "Parameterized Queries"], "code": "import os\\r\\nimport re\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import errorcode\\r\\n\\r\\n# Define allowed file extensions and maximum file size\\r\\nALLOWED_EXTENSIONS = ['pdf']\\r\\nMAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB\\r\\n\\r\\n# Define a regex pattern for validating file names\\r\\nFILE_NAME_PATTERN = r'^[\\w\\-\\. ]+$'\\r\\n\\r\\n# Database connection details\\r\\nDB_HOST = 'your_db_host'\\r\\nDB_USER = 'your_db_user'\\r\\nDB_PASSWORD = 'your_db_password'\\r\\nDB_NAME = 'your_db_name'\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef secure_filename(filename):\\r\\n    if not re.match(FILE_NAME_PATTERN, filename):\\r\\n        raise ValueError('Invalid filename')\\r\\n    return filename\\r\\n\\r\\ndef upload_pdf(file):\\r\\n    # Check if the file is present\\r\\n    if 'file' not in file or file['file'].filename == '':\\r\\n        return {'error': 'No file uploaded'}, 400\\r\\n\\r\\n    # Check if the file is allowed\\r\\n    if not allowed_file(file['file'].filename):\\r\\n        return {'error': 'File type not allowed'}, 400\\r\\n\\r\\n    # Check if the file size is within the limit\\r\\n    if file['file'].content_length > MAX_FILE_SIZE:\\r\\n        return {'error': 'File size exceeds the limit'}, 400\\r\\n\\r\\n    filename = secure_filename(file['file'].filename)\\r\\n    uploads_dir = os.path.join(os.getcwd(), 'uploads')\\r\\n    os.makedirs(uploads_dir, exist_ok=True)\\r\\n    filepath = os.path.join(uploads_dir, filename)\\r\\n\\r\\n    # Save the file to the uploads folder\\r\\n    file['file'].save(filepath)\\r\\n\\r\\n    try:\\r\\n        # Connect to the MySQL database\\r\\n        cnx = mysql.connector.connect(user=DB_USER, password=DB_PASSWORD,\\r\\n                                      host=DB_HOST, database=DB_NAME)\\r\\n        cursor = cnx.cursor()\\r\\n\\r\\n        # Parameterized query to prevent SQL injection\\r\\n        insert_query = \"INSERT INTO pdf_files (filepath) VALUES (%s)\"\\r\\n        cursor.execute(insert_query, (filepath,))\\r\\n        cnx.commit()\\r\\n\\r\\n        return {'message': 'File uploaded successfully'}, 200\\r\\n    except mysql.connector.Error as err:\\r\\n        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:\\r\\n            return {'error': 'Database access denied'}, 500\\r\\n        else:\\r\\n            return {'error': str(err)}, 500\\r\\n    finally:\\r\\n        if 'cursor' in locals():\\r\\n            cursor.close()\\r\\n        if 'cnx' in locals():\\r\\n            cnx.close()\\r\\n\\r\\n# Example usage\\r\\npdf_file = {'file': open('example.pdf', 'rb')}\\r\\nresponse, status_code = upload_pdf(pdf_file)\\r\\nprint(response)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a form in an html page that allows the user to upload a pdf file. There is a web server that is running on the user's localhost. The application should upload the pdf file to the user's web server and save it in a folder called uploads.", "BP": ["Allowed File Extensions", "Secure Filename Generation", "File Existence and Emptiness Checks", "Allowed File Type Check", "Folder-based Storage", "Error Handling"], "code": "import os\\r\\nfrom flask import Flask, request, redirect, url_for, render_template\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Set the allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'pdf'}\\r\\n\\r\\n# Set the upload folder path\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\n\\r\\n# Create the upload folder if it doesn't exist\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"Check if the file extension is allowed\"\"\"\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the file was uploaded\\r\\n        if 'file' not in request.files:\\r\\n            return render_template('upload.html', error='No file uploaded.')\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # Check if the file is empty\\r\\n        if file.filename == '':\\r\\n            return render_template('upload.html', error='No file selected.')\\r\\n\\r\\n        # Check if the file extension is allowed\\r\\n        if not allowed_file(file.filename):\\r\\n            return render_template('upload.html', error='File type not allowed.')\\r\\n\\r\\n        # Generate a secure filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Check if the file already exists in the upload folder\\r\\n        file_path = os.path.join(UPLOAD_FOLDER, filename)\\r\\n        if os.path.exists(file_path):\\r\\n            return render_template('upload.html', error='File already exists.')\\r\\n\\r\\n        try:\\r\\n            # Save the file to the upload folder\\r\\n            file.save(file_path)\\r\\n            return render_template('upload.html', success=f'File {filename} uploaded successfully.')\\r\\n        except Exception as e:\\r\\n            # Handle any exceptions that occurred during file saving\\r\\n            return render_template('upload.html', error=f'An error occurred: {str(e)}')\\r\\n\\r\\n    return render_template('upload.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a web app that accepts a pdf file and saves it in a folder called uploads.", "BP": ["User Authentication", "File Access Control", "File Deletion", "Logging and Monitoring", "Input Validation", "Secure Configuration", "Allowed File Extensions", "Proxy Fix", "Secure Filename", "File Path Construction", "Error Handling", "CSRF Protection", "Secure Headers"], "code": "import os\\r\\nimport logging\\r\\nimport hashlib\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask import Flask, request, redirect, render_template, session\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure secret key\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# Set up allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'pdf'}\\r\\n\\r\\n# Configure secure headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Check if the file extension is allowed\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# User authentication function (replace with your authentication logic)\\r\\ndef authenticate_user(username, password):\\r\\n    # Check if the user exists and the password is correct\\r\\n    # Return True if the user is authenticated, False otherwise\\r\\n    pass\\r\\n\\r\\n# File access control\\r\\ndef has_access(user, file_path):\\r\\n    # Check if the user has access to the file\\r\\n    # Return True if the user has access, False otherwise\\r\\n    pass\\r\\n\\r\\n# File deletion function\\r\\ndef delete_file(file_path):\\r\\n    try:\\r\\n        os.remove(file_path)\\r\\n        logging.info(f'File {file_path} deleted successfully')\\r\\n    except Exception as e:\\r\\n        logging.error(f'Error deleting file {file_path}: {e}')\\r\\n\\r\\n# Proxy fix (if running behind a proxy)\\r\\n@app.before_request\\r\\ndef proxy_fix():\\r\\n    if request.headers.getlist(\"X-Forwarded-For\"):\\r\\n        request.remote_addr = request.headers.getlist(\"X-Forwarded-For\")[0]\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if 'user_id' not in session:\\r\\n        # Redirect to login page if the user is not authenticated\\r\\n        return redirect('/login')\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        # Check if the POST request has a file\\r\\n        if 'file' not in request.files:\\r\\n            logging.error('No file received')\\r\\n            return render_template('error.html', error='No file received'), 400\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # Check if the file has a valid filename\\r\\n        if file.filename == '':\\r\\n            logging.error('No file selected')\\r\\n            return render_template('error.html', error='No file selected'), 400\\r\\n\\r\\n        # Check if the file extension is allowed\\r\\n        if not allowed_file(file.filename):\\r\\n            logging.error(f'File extension not allowed: {file.filename}')\\r\\n            return render_template('error.html', error='File extension not allowed'), 400\\r\\n\\r\\n        # Generate a secure filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Construct the file path securely\\r\\n        upload_folder = os.path.join(app.root_path, 'uploads')\\r\\n        os.makedirs(upload_folder, exist_ok=True)\\r\\n        file_path = os.path.join(upload_folder, filename)\\r\\n\\r\\n        # Check if the user has access to the upload folder\\r\\n        if not has_access(session['user_id'], upload_folder):\\r\\n            logging.error('User does not have access to the upload folder')\\r\\n            return render_template('error.html', error='Access denied'), 403\\r\\n\\r\\n        try:\\r\\n            # Save the file securely\\r\\n            file.save(file_path)\\r\\n            logging.info(f'File {file_path} uploaded successfully')\\r\\n        except Exception as e:\\r\\n            logging.error(f'Error uploading file: {e}')\\r\\n            return render_template('error.html', error='Error uploading file'), 500\\r\\n\\r\\n        # Log the file upload event\\r\\n        logging.info(f'User {session[\"user_id\"]} uploaded file {file_path}')\\r\\n\\r\\n        return render_template('success.html', message='File uploaded successfully')\\r\\n\\r\\n    return render_template('upload.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        # Validate user input\\r\\n        if not username or not password:\\r\\n            logging.error('Invalid username or password')\\r\\n            return render_template('error.html', error='Invalid username or password'), 400\\r\\n\\r\\n        # Authenticate the user\\r\\n        if authenticate_user(username, password):\\r\\n            session['user_id'] = hashlib.sha256(username.encode()).hexdigest()\\r\\n            return redirect('/upload')\\r\\n        else:\\r\\n            logging.error('Invalid username or password')\\r\\n            return render_template('error.html', error='Invalid username or password'), 401\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    logging.error(f'An error occurred: {e}')\\r\\n    return render_template('error.html', error='An error occurred'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple script that accepts an image file and stores it in a MySQL database.", "BP": ["Input Validation", "Parameterized Queries", "Error Handling", "Secure File Access"], "code": "import os\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import errorcode\\r\\n\\r\\n# Database configuration\\r\\nDB_HOST = \"your_db_host\"\\r\\nDB_USER = \"your_db_user\"\\r\\nDB_PASSWORD = \"your_db_password\"\\r\\nDB_NAME = \"your_db_name\"\\r\\n\\r\\n# Allowed file extensions and maximum file size\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5 MB\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"\\r\\n    Checks if the uploaded file has an allowed extension.\\r\\n    \"\"\"\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef store_image_in_db(file):\\r\\n    \"\"\"\\r\\n    Stores the image file in the MySQL database.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Connect to the MySQL database\\r\\n        cnx = mysql.connector.connect(host=DB_HOST, user=DB_USER, password=DB_PASSWORD, database=DB_NAME)\\r\\n        cursor = cnx.cursor()\\r\\n\\r\\n        # Read the file contents\\r\\n        file_data = file.read()\\r\\n\\r\\n        # Insert the image data into the database using a parameterized query\\r\\n        insert_query = \"INSERT INTO images (image_data) VALUES (%s)\"\\r\\n        cursor.execute(insert_query, (file_data,))\\r\\n        cnx.commit()\\r\\n\\r\\n        print(\"Image stored successfully in the database.\")\\r\\n\\r\\n    except mysql.connector.Error as err:\\r\\n        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:\\r\\n            print(\"Something is wrong with your user name or password\")\\r\\n        elif err.errno == errorcode.ER_BAD_DB_ERROR:\\r\\n            print(\"Database does not exist\")\\r\\n        else:\\r\\n            print(err)\\r\\n    finally:\\r\\n        if 'cnx' in locals():\\r\\n            cnx.close()\\r\\n\\r\\ndef main():\\r\\n    # Get the uploaded file from the request\\r\\n    uploaded_file = request.files['image_file']\\r\\n\\r\\n    # Validate the uploaded file\\r\\n    if uploaded_file and allowed_file(uploaded_file.filename):\\r\\n        file_size = len(uploaded_file.read())\\r\\n        uploaded_file.seek(0)  # Reset the file pointer\\r\\n\\r\\n        if file_size <= MAX_FILE_SIZE:\\r\\n            store_image_in_db(uploaded_file)\\r\\n        else:\\r\\n            print(\"File size exceeds the maximum allowed size.\")\\r\\n    else:\\r\\n        print(\"Invalid file or file extension.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and converted to base64. The image name and base64 string are inserted into the database.", "BP": ["Secure Database Connection", "Secure Table Creation", "Secure Salt Generation", "Secure Hashing", "Prepared Statements for SQL Queries", "Secure File Handling", "Error Handling and Logging"], "code": "import os\\r\\nimport base64\\r\\nimport hashlib\\r\\nimport sqlite3\\r\\nfrom sqlite3 import Error\\r\\n\\r\\n# Database connection parameters\\r\\nDB_FILE = \"database.db\"\\r\\n\\r\\n# Salt for hashing\\r\\nSALT = os.urandom(16)\\r\\n\\r\\n# Create a secure connection to the database\\r\\ndef create_connection():\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(DB_FILE)\\r\\n        return conn\\r\\n    except Error as e:\\r\\n        print(f\"Error creating database connection: {e}\")\\r\\n        return None\\r\\n\\r\\n# Create a secure table for storing images\\r\\ndef create_table(conn):\\r\\n    try:\\r\\n        cursor = conn.cursor()\\r\\n        sql = \"\"\"\\r\\n            CREATE TABLE IF NOT EXISTS images (\\r\\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\\r\\n                name TEXT NOT NULL,\\r\\n                data BLOB NOT NULL\\r\\n            )\\r\\n        \"\"\"\\r\\n        cursor.execute(sql)\\r\\n        conn.commit()\\r\\n    except Error as e:\\r\\n        print(f\"Error creating table: {e}\")\\r\\n\\r\\n# Secure file handling and base64 encoding\\r\\ndef upload_image(file):\\r\\n    try:\\r\\n        # Read the file securely\\r\\n        with open(file, \"rb\") as f:\\r\\n            file_data = f.read()\\r\\n\\r\\n        # Convert the image to base64\\r\\n        base64_data = base64.b64encode(file_data)\\r\\n\\r\\n        # Get the file name securely\\r\\n        file_name = os.path.basename(file)\\r\\n\\r\\n        # Secure hashing of the file name\\r\\n        hash_name = hashlib.sha256(file_name.encode() + SALT).hexdigest()\\r\\n\\r\\n        # Insert the image into the database\\r\\n        conn = create_connection()\\r\\n        if conn:\\r\\n            insert_image(conn, hash_name, base64_data)\\r\\n            conn.close()\\r\\n    except Exception as e:\\r\\n        print(f\"Error uploading image: {e}\")\\r\\n        # Logging the error securely\\r\\n        log_error(e)\\r\\n\\r\\n# Secure SQL queries with prepared statements\\r\\ndef insert_image(conn, name, data):\\r\\n    sql = \"\"\"\\r\\n        INSERT INTO images (name, data)\\r\\n        VALUES (?, ?)\\r\\n    \"\"\"\\r\\n    try:\\r\\n        cursor = conn.cursor()\\r\\n        cursor.execute(sql, (name, data))\\r\\n        conn.commit()\\r\\n    except Error as e:\\r\\n        print(f\"Error inserting image: {e}\")\\r\\n        # Logging the error securely\\r\\n        log_error(e)\\r\\n\\r\\n# Secure error logging\\r\\ndef log_error(error):\\r\\n    log_file = \"error.log\"\\r\\n    try:\\r\\n        with open(log_file, \"a\") as f:\\r\\n            f.write(f\"{error}\\n\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error logging error: {e}\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    image_path = \"example.jpg\"\\r\\n    upload_image(image_path)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and encoded using base64. The encoded image is written to a file.", "BP": ["Allowed File Extensions", "Secure Filename", "Random Filename Generation", "Separate Upload and Encoded Directories", "Secure File Handling"], "code": "import os\\r\\nimport base64\\r\\nimport secrets\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\n# Define allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Define the upload directory\\r\\nUPLOAD_DIR = 'uploads'\\r\\n# Define the encoded directory\\r\\nENCODED_DIR = 'encoded'\\r\\n\\r\\n# Create the upload and encoded directories if they don't exist\\r\\nos.makedirs(UPLOAD_DIR, exist_ok=True)\\r\\nos.makedirs(ENCODED_DIR, exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"\\r\\n    Check if the file extension is allowed.\\r\\n    \"\"\"\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef upload_image(file):\\r\\n    \"\"\"\\r\\n    Upload an image file, encode it using base64, and save the encoded file.\\r\\n    \"\"\"\\r\\n    # Check if the file is allowed\\r\\n    if file and allowed_file(file.filename):\\r\\n        # Generate a random filename\\r\\n        random_filename = f\"{secrets.token_hex(16)}.{file.filename.rsplit('.', 1)[1].lower()}\"\\r\\n\\r\\n        # Save the original file to the upload directory\\r\\n        upload_path = os.path.join(UPLOAD_DIR, random_filename)\\r\\n        file.save(upload_path)\\r\\n\\r\\n        # Read the uploaded file\\r\\n        with open(upload_path, 'rb') as f:\\r\\n            file_data = f.read()\\r\\n\\r\\n        # Encode the file data using base64\\r\\n        encoded_data = base64.b64encode(file_data)\\r\\n\\r\\n        # Save the encoded file to the encoded directory\\r\\n        encoded_filename = f\"{secrets.token_hex(16)}.txt\"\\r\\n        encoded_path = os.path.join(ENCODED_DIR, encoded_filename)\\r\\n        with open(encoded_path, 'wb') as f:\\r\\n            f.write(encoded_data)\\r\\n\\r\\n        # Remove the original uploaded file\\r\\n        os.remove(upload_path)\\r\\n\\r\\n        return encoded_filename\\r\\n    else:\\r\\n        return None", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory. The file_is_safe_type function is a stub that always returns true.The upload_file function is the function that handles the file upload.", "BP": ["Allowed File Extensions", "File Type Validation", "Secure Filename", "Maximum File Size", "CSRF Protection", "Secure Headers", "Error Handling"], "code": "from flask import Flask, request, redirect, send_from_directory\\r\\nimport os\\r\\nimport magic\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Generate a secure CSRF token\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = request.headers.get('X-CSRF-Token')\\r\\n        if not token or token != request.cookies.get('CSRF_TOKEN'):\\r\\n            return \"CSRF Token is missing or invalid\", 403\\r\\n\\r\\n# Set secure headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\ndef file_is_safe_type(file):\\r\\n    # Use the python-magic library to check the file type\\r\\n    file_type = magic.from_buffer(file.read(1024), mime=True)\\r\\n    file.seek(0)  # Reset the file pointer\\r\\n    return file_type in ['text/plain', 'application/pdf', 'image/png', 'image/jpeg', 'image/gif']\\r\\n\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        return \"No file uploaded\", 400\\r\\n\\r\\n    file = request.files['file']\\r\\n\\r\\n    if file.filename == '':\\r\\n        return \"No file selected\", 400\\r\\n\\r\\n    # Check if the file extension is allowed\\r\\n    file_ext = os.path.splitext(file.filename)[1][1:].lower()\\r\\n    if file_ext not in ALLOWED_EXTENSIONS:\\r\\n        return \"File extension not allowed\", 400\\r\\n\\r\\n    # Check if the file type is safe\\r\\n    if not file_is_safe_type(file):\\r\\n        return \"File type not allowed\", 400\\r\\n\\r\\n    # Secure the filename\\r\\n    filename = secure_filename(file.filename)\\r\\n\\r\\n    # Save the file\\r\\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n    file.save(file_path)\\r\\n\\r\\n    return redirect('/uploads/' + filename)\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\\r\\n    app.secret_key = os.urandom(24)  # Generate a random secret key\\r\\n    app.run(debug=False, host='0.0.0.0')", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to upload files to the server.", "BP": ["File Size Limit", "Allowed File Extensions", "File Extension Checking", "Filename Sanitization", "Error Handling", "Input Validation", "Secure File Storage", "Rate-limiting", "Logging and Monitoring"], "code": "import os\\r\\nimport re\\r\\nfrom pathlib import Path\\r\\nfrom flask import Flask, request, redirect, url_for, render_template\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom ratelimit import limits, sleep_and_retry\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_prefix=1)\\r\\n\\r\\n# Set the maximum file size (e.g., 10MB)\\r\\nMAX_FILE_SIZE = 10 * 1024 * 1024\\r\\n\\r\\n# Set the allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Set the upload directory\\r\\nUPLOAD_DIRECTORY = Path('uploads')\\r\\nUPLOAD_DIRECTORY.mkdir(exist_ok=True)\\r\\n\\r\\n# Rate-limiting configuration\\r\\nRATELIMIT_STORAGE_URL = 'redis://localhost:6379'\\r\\nRATELIMIT_STRATEGY = 'moving-window'\\r\\nRATELIMIT_WINDOW = 60  # 1 minute\\r\\nRATELIMIT_LIMIT = 10  # Maximum of 10 uploads per minute\\r\\n\\r\\n# Logging configuration\\r\\nimport logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# File extension pattern for validation\\r\\nEXTENSION_PATTERN = r'^.*\\.(txt|pdf|png|jpg|jpeg|gif)$'\\r\\n\\r\\n# Filename sanitization pattern\\r\\nFILENAME_PATTERN = r'^[\\w\\-\\. ]+$'\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@sleep_and_retry\\r\\n@limits(calls=RATELIMIT_LIMIT, period=RATELIMIT_WINDOW, storage_url=RATELIMIT_STORAGE_URL, strategy=RATELIMIT_STRATEGY)\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the file was properly uploaded\\r\\n        if 'file' not in request.files:\\r\\n            logging.error('No file part')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # If the user did not select a file, redirect to the same page\\r\\n        if file.filename == '':\\r\\n            logging.error('No file selected')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        # Validate file extension\\r\\n        if not re.match(EXTENSION_PATTERN, file.filename, re.IGNORECASE):\\r\\n            logging.error(f'Invalid file extension: {file.filename}')\\r\\n            return 'Invalid file extension', 400\\r\\n\\r\\n        # Sanitize the filename\\r\\n        if not re.match(FILENAME_PATTERN, file.filename):\\r\\n            logging.error(f'Invalid filename: {file.filename}')\\r\\n            return 'Invalid filename', 400\\r\\n\\r\\n        # Check file size\\r\\n        if file.content_length > MAX_FILE_SIZE:\\r\\n            logging.error(f'File too large: {file.filename} ({file.content_length} bytes)')\\r\\n            return 'File too large', 413\\r\\n\\r\\n        # Save the file securely\\r\\n        filename = secure_filename(file.filename)\\r\\n        file_path = UPLOAD_DIRECTORY / filename\\r\\n        file.save(file_path)\\r\\n        logging.info(f'File saved: {file_path}')\\r\\n\\r\\n        return f'File uploaded successfully: {filename}'\\r\\n\\r\\n    return render_template('upload.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The file_is_safe_type function is a function that checks if the file is safe to upload. The upload_file function is the function that handles the upload of the file. The p.save(os.path.join('uploads' filename)) line saves the file to the uploads folder. The uploads folder is created in the same directory as the source file.", "BP": ["Allowed File Extensions", "File Extension Validation", "File Size Validation", "Malicious Content Detection", "Secure Filename Generation", "File Pointer Reset"], "code": "import os\\r\\nimport magic\\r\\nimport re\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\n# Maximum file size allowed (in bytes)\\r\\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5 MB\\r\\n\\r\\n# Allowed file extensions\\r\\nALLOWED_EXTENSIONS = ['pdf', 'doc', 'docx', 'txt', 'jpg', 'jpeg', 'png', 'gif']\\r\\n\\r\\n# Regular expression pattern for detecting malicious content\\r\\nMALICIOUS_PATTERN = r'<\\s*script'\\r\\n\\r\\n# Upload directory\\r\\nUPLOAD_DIR = 'uploads'\\r\\n\\r\\ndef file_is_safe_type(file):\\r\\n    \"\"\"\\r\\n    Checks if the file is safe for upload based on file extension, size, and content.\\r\\n    \"\"\"\\r\\n    # Check file extension\\r\\n    file_ext = os.path.splitext(file.filename)[1][1:].lower()\\r\\n    if file_ext not in ALLOWED_EXTENSIONS:\\r\\n        return False\\r\\n\\r\\n    # Check file size\\r\\n    if file.content_length > MAX_FILE_SIZE:\\r\\n        return False\\r\\n\\r\\n    # Check for malicious content\\r\\n    file.seek(0)  # Reset file pointer\\r\\n    file_content = file.read()\\r\\n    if re.search(MALICIOUS_PATTERN, file_content.decode('utf-8', 'ignore')):\\r\\n        return False\\r\\n\\r\\n    return True\\r\\n\\r\\ndef upload_file(file):\\r\\n    \"\"\"\\r\\n    Uploads the file securely to the uploads directory.\\r\\n    \"\"\"\\r\\n    if file_is_safe_type(file):\\r\\n        # Generate a secure filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Create the uploads directory if it doesn't exist\\r\\n        os.makedirs(UPLOAD_DIR, exist_ok=True)\\r\\n\\r\\n        # Save the file to the uploads directory\\r\\n        file_path = os.path.join(UPLOAD_DIR, filename)\\r\\n        file.seek(0)  # Reset file pointer\\r\\n        file.save(file_path)\\r\\n\\r\\n        return True\\r\\n    else:\\r\\n        return False", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of that block. The -> operator is used to access members of a struct through a pointer.", "BP": ["Memory Allocation", "Memory Deallocation", "Struct Representation", "Proper Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a struct to represent a person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"name\", ctypes.c_char_p),\\r\\n        (\"age\", ctypes.c_int),\\r\\n        (\"height\", ctypes.c_float)\\r\\n    ]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a Person struct\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    \\r\\n    # Initialize the struct members\\r\\n    person_ptr.contents.name = ctypes.c_char_p(b\"John Doe\")\\r\\n    person_ptr.contents.age = 30\\r\\n    person_ptr.contents.height = 1.75\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate memory for the Person struct\\r\\n    ctypes.pointer(person_ptr.contents.name).value = None\\r\\n    ctypes.pointer(Person.from_address(ctypes.addressof(person_ptr.contents))).contents = None\\r\\n\\r\\n# Example usage\\r\\nperson = allocate_person()\\r\\nprint(f\"Name: {person.contents.name.decode()}\")  # Name: John Doe\\r\\nprint(f\"Age: {person.contents.age}\")  # Age: 30\\r\\nprint(f\"Height: {person.contents.height}\")  # Height: 1.75\\r\\n\\r\\ndeallocate_person(person)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The cast (person *) is not necessary but it is good practice to include it. The -> operator is used to access the fields of a struct through a pointer. The code allocates a new person and sets the status field to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "Data Handling", "Error Handling", "Import ctypes"], "code": "import os\\r\\nimport ctypes\\r\\n\\r\\n# Define a Person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\n# Securely allocate memory for a Person object\\r\\ndef allocate_person():\\r\\n    try:\\r\\n        # Allocate memory for a Person object\\r\\n        person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n        # Initialize fields\\r\\n        person_ptr.contents.name = ctypes.create_string_buffer(b\"John Doe\")\\r\\n        person_ptr.contents.age = 30\\r\\n        person_ptr.contents.status = 0\\r\\n\\r\\n        return person_ptr\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error allocating memory: {e}\")\\r\\n        return None\\r\\n\\r\\n# Securely deallocate memory for a Person object\\r\\ndef deallocate_person(person_ptr):\\r\\n    if person_ptr:\\r\\n        try:\\r\\n            # Securely clear the allocated memory\\r\\n            ctypes.memset(person_ptr, 0, ctypes.sizeof(Person))\\r\\n\\r\\n            # Deallocate the memory\\r\\n            ctypes.pointer(person_ptr)[0] = None\\r\\n        except (ValueError, MemoryError) as e:\\r\\n            print(f\"Error deallocating memory: {e}\")\\r\\n\\r\\n# Securely handle Person data\\r\\ndef handle_person_data(person_ptr):\\r\\n    if person_ptr:\\r\\n        try:\\r\\n            name = person_ptr.contents.name.decode()\\r\\n            age = person_ptr.contents.age\\r\\n            status = person_ptr.contents.status\\r\\n\\r\\n            # Handle the data securely\\r\\n            print(f\"Name: {name}, Age: {age}, Status: {status}\")\\r\\n        except (ValueError, UnicodeDecodeError) as e:\\r\\n            print(f\"Error handling data: {e}\")\\r\\n\\r\\n# Example usage\\r\\nperson_ptr = allocate_person()\\r\\nhandle_person_data(person_ptr)\\r\\ndeallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when the struct is pointed to by a pointer. The code allocates a new person and sets the status to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "String Handling", "Error Handling", "Import ctypes"], "code": "import ctypes\\r\\nimport secrets\\r\\nimport os\\r\\nfrom typing import Optional\\r\\n\\r\\n# Define a Person struct using ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"name\", ctypes.c_char_p),\\r\\n        (\"age\", ctypes.c_int),\\r\\n        (\"status\", ctypes.c_int)\\r\\n    ]\\r\\n\\r\\ndef allocate_person() -> Optional[Person]:\\r\\n    try:\\r\\n        # Allocate memory for a Person struct\\r\\n        person_ptr = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), ctypes.POINTER(Person))\\r\\n        if person_ptr:\\r\\n            # Securely initialize the status to 0\\r\\n            person_ptr.contents.status = 0\\r\\n            return person_ptr.contents\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating memory: {e}\")\\r\\n    return None\\r\\n\\r\\ndef deallocate_person(person: Person) -> None:\\r\\n    try:\\r\\n        # Securely zero out the memory before freeing it\\r\\n        ctypes.memset(ctypes.byref(person), 0, ctypes.sizeof(person))\\r\\n        # Free the memory allocated for the name string\\r\\n        ctypes.free(person.name)\\r\\n    except Exception as e:\\r\\n        print(f\"Error deallocating memory: {e}\")\\r\\n\\r\\ndef set_name(person: Person, name: str) -> None:\\r\\n    try:\\r\\n        # Securely allocate memory for the name string\\r\\n        person.name = ctypes.create_string_buffer(name.encode('utf-8'))\\r\\n    except Exception as e:\\r\\n        print(f\"Error setting name: {e}\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate memory for a Person\\r\\n    person = allocate_person()\\r\\n    if person:\\r\\n        # Set the name securely\\r\\n        set_name(person, secrets.token_hex(8))\\r\\n        print(f\"Name: {person.name.decode('utf-8')}, Age: {person.age}, Status: {person.status}\")\\r\\n        # Deallocate memory for the Person\\r\\n        deallocate_person(person)\\r\\n    else:\\r\\n        print(\"Failed to allocate memory for Person\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct through a pointer.The code allocates a new person and sets its status to 0.", "BP": ["Memory Allocation", "Memory Cleanup", "Field Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a structure to represent the person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\n# Securely allocate memory for a new person\\r\\nperson_ptr = ctypes.POINTER(Person)()\\r\\nperson = person_ptr.contents\\r\\n\\r\\n# Securely initialize the person's status\\r\\nperson.status = 0\\r\\n\\r\\n# Free the allocated memory when no longer needed\\r\\nctypes.free(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code creates a new person and sets the status to 0 and the name to \\\"John\\\".", "BP": ["Memory Allocation", "Secure Data Handling", "Input Validation", "Import ctypes"], "code": "import ctypes\\r\\nimport re\\r\\n\\r\\n# Define a person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int),\\r\\n                (\"name\", ctypes.c_char_p)]\\r\\n\\r\\n# Memory allocation function\\r\\ndef allocate_memory(size):\\r\\n    try:\\r\\n        buffer = ctypes.create_string_buffer(size)\\r\\n        return buffer\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating memory: {e}\")\\r\\n        return None\\r\\n\\r\\n# Secure data handling and input validation\\r\\ndef create_person(name):\\r\\n    # Input validation using regular expression\\r\\n    if not re.match(r\"^[a-zA-Z]+$\", name):\\r\\n        print(\"Invalid name. Only alphabetic characters are allowed.\")\\r\\n        return None\\r\\n\\r\\n    # Memory allocation\\r\\n    name_buffer = allocate_memory(len(name) + 1)\\r\\n    if name_buffer is None:\\r\\n        return None\\r\\n\\r\\n    # Create a new person\\r\\n    person = Person()\\r\\n    person.status = 0\\r\\n    person.name = ctypes.cast(name_buffer, ctypes.POINTER(ctypes.c_char))\\r\\n    ctypes.memmove(person.name, name.encode(), len(name))\\r\\n\\r\\n    return person\\r\\n\\r\\n# Example usage\\r\\nname_input = input(\"Enter a name: \")\\r\\nperson = create_person(name_input)\\r\\nif person:\\r\\n    print(f\"Status: {person.status}\")\\r\\n    print(f\"Name: {person.name.value.decode()}\")\\r\\nelse:\\r\\n    print(\"Error creating person.\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code allocates a new person and sets the status to 0.", "BP": ["Dynamic Memory Allocation", "Memory Deallocation", "String Handling", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define the Person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"name\", ctypes.c_char_p),\\r\\n        (\"age\", ctypes.c_int),\\r\\n        (\"status\", ctypes.c_int)\\r\\n    ]\\r\\n\\r\\ndef create_person(name, age):\\r\\n    # Allocate memory for the Person structure\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n    # Set the name field\\r\\n    person_ptr.contents.name = ctypes.c_char_p(name.encode('utf-8'))\\r\\n\\r\\n    # Set the age field\\r\\n    person_ptr.contents.age = age\\r\\n\\r\\n    # Set the status field to 0\\r\\n    person_ptr.contents.status = 0\\r\\n\\r\\n    return person_ptr\\r\\n\\r\\n# Usage\\r\\njohn_ptr = create_person(\"John\", 30)\\r\\nprint(f\"Name: {john_ptr.contents.name.decode('utf-8')}\")\\r\\nprint(f\"Age: {john_ptr.contents.age}\")\\r\\nprint(f\"Status: {john_ptr.contents.status}\")\\r\\n\\r\\n# Free the allocated memory\\r\\nctypes.pointer(ctypes.c_char_p(john_ptr.contents.name))()\\r\\nctypes.pointer(john_ptr)()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a large buffer and copy in 100 characters from stdin. Allocate a second large buffer and copy in 100 characters from stdin. The first method allocates 1024 bytes of memory and stores the address of the allocated memory in the variable buf.  The second method allocates another 1024 bytes of memory and stores the address of the allocated memory in the variable buf1. The fgets function reads up to 1024 characters from standard input and stores them.", "BP": ["Memory Allocation", "Input Validation", "Error Handling", "Memory Cleanup", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Define constants\\r\\nMAX_INPUT_LENGTH = 100\\r\\nBUFFER_SIZE = 1024\\r\\n\\r\\n# Define helper functions\\r\\ndef secure_allocate(size):\\r\\n    try:\\r\\n        return ctypes.create_string_buffer(size)\\r\\n    except (MemoryError, ValueError) as e:\\r\\n        print(f\"Error allocating memory: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\ndef secure_input(prompt, buf, max_len):\\r\\n    try:\\r\\n        user_input = input(prompt)\\r\\n        if len(user_input) > max_len:\\r\\n            print(f\"Input length exceeded {max_len} characters. Input truncated.\", file=sys.stderr)\\r\\n            user_input = user_input[:max_len]\\r\\n        buf.value = user_input.encode()\\r\\n    except Exception as e:\\r\\n        print(f\"Error reading input: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\n# Allocate memory buffers\\r\\nbuf = secure_allocate(BUFFER_SIZE)\\r\\nbuf1 = secure_allocate(BUFFER_SIZE)\\r\\n\\r\\nif buf and buf1:\\r\\n    # Read input from stdin\\r\\n    secure_input(\"Enter up to 100 characters: \", buf, MAX_INPUT_LENGTH)\\r\\n    secure_input(\"Enter up to 100 characters: \", buf1, MAX_INPUT_LENGTH)\\r\\n\\r\\n    # Process input (example: print to stdout)\\r\\n    print(f\"First input: {buf.value.decode()}\")\\r\\n    print(f\"Second input: {buf1.value.decode()}\")\\r\\n\\r\\n    # Free allocated memory\\r\\n    ctypes.memset(ctypes.addressof(buf), 0, BUFFER_SIZE)\\r\\n    ctypes.memset(ctypes.addressof(buf1), 0, BUFFER_SIZE)\\r\\nelse:\\r\\n    print(\"Error: Memory allocation failed.\", file=sys.stderr)\\r\\n    sys.exit(1)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: The scan function reads in a string from the standard input. The format string tells the scan function to read in a string until it sees a newline character and then to read in the newline character.  The newline character is not stored in the buffer.The scanf function returns the number of characters read in.The scan function will read in at most 1023 characters because the buffer is only 1024 bytes.", "BP": ["Secure Input Handling", "Prompt Flushing", "Error Handling", "String Decoding", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Define the maximum buffer size\\r\\nMAX_BUFFER_SIZE = 1024\\r\\n\\r\\n# Flush the input buffer\\r\\ndef flush_input():\\r\\n    try:\\r\\n        import msvcrt\\r\\n        while msvcrt.kbhit():\\r\\n            msvcrt.getch()\\r\\n    except ImportError:\\r\\n        import sys\\r\\n        import termios\\r\\n        termios.tcflush(sys.stdin, termios.TCIOFLUSH)\\r\\n\\r\\n# Secure string input function\\r\\ndef secure_input(prompt):\\r\\n    # Flush the input buffer before prompting\\r\\n    flush_input()\\r\\n\\r\\n    # Print the prompt\\r\\n    sys.stdout.write(prompt)\\r\\n    sys.stdout.flush()\\r\\n\\r\\n    # Read the input securely\\r\\n    input_bytes = ctypes.create_string_buffer(MAX_BUFFER_SIZE)\\r\\n    bytes_read = ctypes.c_int()\\r\\n    success = ctypes.windll.msvcrt.scanf(\"%1023s\", input_bytes)\\r\\n\\r\\n    # Handle errors\\r\\n    if success == 0:\\r\\n        print(\"Error: Invalid input\")\\r\\n        return None\\r\\n    elif success == ctypes.c_int(-1).value:\\r\\n        ctypes.windll.msvcrt.scanf(\"%*c\")  # Consume the newline character\\r\\n        print(\"Error: Input too long\")\\r\\n        return None\\r\\n\\r\\n    # Decode the input bytes to a string\\r\\n    input_str = input_bytes.value.decode('utf-8', 'ignore')\\r\\n\\r\\n    return input_str\\r\\n\\r\\n# Example usage\\r\\nuser_input = secure_input(\"Enter a string: \")\\r\\nif user_input:\\r\\n    print(f\"You entered: {user_input}\")\\r\\nelse:\\r\\n    print(\"Invalid input\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a buffer of 1024 bytes. fgets reads 10 characters from standard input and stores them in buf.", "BP": ["Memory Allocation", "Input Handling", "Error Handling", "and Exception Handling", "Data Encoding", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Memory allocation (1024 bytes)\\r\\nbuf_size = 1024\\r\\nbuf = ctypes.create_string_buffer(buf_size)\\r\\n\\r\\ntry:\\r\\n    # Input handling\\r\\n    chars_read = sys.stdin.read(10)  # Read up to 10 characters from standard input\\r\\n    if not chars_read:\\r\\n        print(\"No input provided\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Error handling and exception handling\\r\\n    if len(chars_read) > buf_size - 1:\\r\\n        print(\"Input exceeds buffer size\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Copy input to buffer\\r\\n    buf.value = chars_read.encode()\\r\\n\\r\\n    # Print the input\\r\\n    print(f\"Input: {buf.value.decode()}\")\\r\\n\\r\\nexcept Exception as e:\\r\\n    print(f\"An error occurred: {str(e)}\")\\r\\n    sys.exit(1)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: It creates a web app. It creates a route called /api. It gets the payload parameter from the URL.  It loads the payload into a dictionary. It returns the name value from the dictionary.", "BP": ["Input Validation", "Error Handling", "Secure Data Handling", "Appropriate HTTP Status Codes", "JSON Responses"], "code": "from flask import Flask, jsonify, request\\r\\nimport json\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/api', methods=['GET'])\\r\\ndef api():\\r\\n    try:\\r\\n        # Get the payload parameter from the URL\\r\\n        payload = request.args.get('payload')\\r\\n\\r\\n        # Input Validation: Check if payload is provided\\r\\n        if not payload:\\r\\n            raise BadRequest('Missing payload parameter')\\r\\n\\r\\n        # Secure Data Handling: Load the payload into a dictionary\\r\\n        try:\\r\\n            data = json.loads(payload)\\r\\n        except ValueError:\\r\\n            raise BadRequest('Invalid JSON payload')\\r\\n\\r\\n        # Check if the 'name' key exists in the dictionary\\r\\n        if 'name' not in data:\\r\\n            return jsonify({'error': 'Missing name key in payload'}), 400\\r\\n\\r\\n        # Return the 'name' value as a JSON response\\r\\n        return jsonify({'name': data['name']}), 200\\r\\n\\r\\n    except BadRequest as e:\\r\\n        # Return an appropriate HTTP status code and error message for bad requests\\r\\n        return jsonify({'error': str(e)}), 400\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle unexpected exceptions and return an appropriate HTTP status code\\r\\n        return jsonify({'error': 'Internal Server Error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: Import a web application class from the web application module. Create an instance of the web application class. Use the route() decorator to tell the application what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function and returns the message we want to display in the user's browser.", "BP": ["CSRF Protection", "Disable Caching for Sensitive Data", "Prevent XSS", "Secure Execution", "HTTPS", "Input Validation", "Input Sanitization"], "code": "from flask import Flask, render_template, request\\r\\nimport html\\r\\n\\r\\n# Import a web application class from the web application module\\r\\napp = Flask(__name__)\\r\\n\\r\\n# CSRF Protection\\r\\napp.secret_key = 'your_secret_key'\\r\\n\\r\\n# Disable Caching for Sensitive Data\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Cache-Control'] = 'no-store, no-cache'\\r\\n    return response\\r\\n\\r\\n# Secure Execution\\r\\n@app.before_request\\r\\ndef secure_headers():\\r\\n    if request.url.startswith('http://'):\\r\\n        url = request.url.replace('http://', 'https://', 1)\\r\\n        return redirect(url, code=301)\\r\\n\\r\\n# Input Validation and Sanitization\\r\\ndef sanitize_input(data):\\r\\n    return html.escape(data)\\r\\n\\r\\n# Route with CSRF Protection\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef home():\\r\\n    if request.method == 'POST':\\r\\n        # Input Validation and Sanitization\\r\\n        username = sanitize_input(request.form['username'])\\r\\n        password = sanitize_input(request.form['password'])\\r\\n        \\r\\n        # Further processing/validation\\r\\n        # ...\\r\\n        \\r\\n        return render_template('success.html')\\r\\n    \\r\\n    return render_template('index.html')\\r\\n\\r\\n# Prevent XSS\\r\\n@app.template_filter('escape')\\r\\ndef escape_content(text):\\r\\n    return html.escape(text)\\r\\n\\r\\n# Create an instance of the web application class\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc', debug=False)", "CWE": "CWE-502"}
{"text": "Generate python code for the following: The code is a simple web application that listens on port 5000.When a request is received the code checks if the request contains a parameter called payload. If not it returns an error message.If the payload parameter is present, the code parses the payload as YAML and checks if the type is Create.  If it is it returns an error message.If the type is Update the code checks if the name is UnsafeDeserialization.", "BP": ["Input Validation", "YAML Deserialization", "Access Control", "Error Handling", "Secure Configuration", "HTTPS"], "code": "import yaml\\r\\nfrom flask import Flask, request\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Define allowed YAML types\\r\\nALLOWED_TYPES = ['Update']\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Initialize Talisman for security headers\\r\\ncsp = {\\r\\n    'default-src': \"'self'\",\\r\\n    'script-src': \"'self'\",\\r\\n    'style-src': \"'self'\"\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n@app.route('/', methods=['POST'])\\r\\ndef process_payload():\\r\\n    # Check if the request is secure (HTTPS)\\r\\n    if not request.is_secure:\\r\\n        return 'Error: Insecure connection', 400\\r\\n\\r\\n    # Check if payload parameter is present\\r\\n    payload = request.form.get('payload')\\r\\n    if not payload:\\r\\n        return 'Error: No payload provided', 400\\r\\n\\r\\n    try:\\r\\n        # Parse YAML payload\\r\\n        data = yaml.safe_load(payload)\\r\\n\\r\\n        # Validate YAML type\\r\\n        if data.get('type') not in ALLOWED_TYPES:\\r\\n            return f\"Error: Invalid type '{data.get('type')}'. Allowed types: {', '.join(ALLOWED_TYPES)}\", 400\\r\\n\\r\\n        # Access Control: Check if 'name' is 'UnsafeDeserialization'\\r\\n        if data.get('type') == 'Update' and data.get('name') == 'UnsafeDeserialization':\\r\\n            return 'Error: Unsafe deserialization detected', 400\\r\\n\\r\\n        # Process the payload\\r\\n        # ... Your code here ...\\r\\n\\r\\n        return 'Success', 200\\r\\n\\r\\n    except (yaml.YAMLError, ValueError) as e:\\r\\n        # Error handling for YAML parsing errors\\r\\n        return f'Error: {e}', 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Use secure server with HTTPS\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when the URL /api/temperature_for_location is requested. The function gets the latitude longitude and date from the payload. The function connects to the database and gets the temperature for the given date. The function returns the temperature.The code is a simple example of how to use the database. The database is called Sensor.", "BP": ["Environment Variables", "Flask Configuration", "Database Setup", "Input Validation", "Database Querying", "Error Handling", "Session Management", "Secure Configuration"], "code": "import os\\r\\nfrom datetime import datetime\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.exc import SQLAlchemyError\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Flask configuration\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Database setup\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Database model\\r\\nclass Temperature(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    latitude = db.Column(db.Float, nullable=False)\\r\\n    longitude = db.Column(db.Float, nullable=False)\\r\\n    date = db.Column(db.Date, nullable=False)\\r\\n    temperature = db.Column(db.Float, nullable=False)\\r\\n\\r\\n# Input validation\\r\\ndef validate_input(latitude, longitude, date_str):\\r\\n    try:\\r\\n        latitude = float(latitude)\\r\\n        longitude = float(longitude)\\r\\n        date = datetime.strptime(date_str, '%Y-%m-%d').date()\\r\\n    except (ValueError, TypeError):\\r\\n        return False\\r\\n    return -90 <= latitude <= 90 and -180 <= longitude <= 180\\r\\n\\r\\n# Database querying\\r\\ndef get_temperature(latitude, longitude, date):\\r\\n    try:\\r\\n        temperature = Temperature.query.filter_by(\\r\\n            latitude=latitude, longitude=longitude, date=date).first()\\r\\n        return temperature.temperature if temperature else None\\r\\n    except SQLAlchemyError as e:\\r\\n        app.logger.error(f'Database error: {str(e)}')\\r\\n        return None\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    app.logger.error(str(e))\\r\\n    return jsonify({'error': 'An error occurred'}), 500\\r\\n\\r\\n# Session management\\r\\n@app.before_request\\r\\ndef session_management():\\r\\n    session.permanent = True\\r\\n    app.permanent_session_lifetime = datetime.timedelta(minutes=30)\\r\\n    session.modified = True\\r\\n\\r\\n# Secure configuration\\r\\nif __name__ == '__main__':\\r\\n    app.secret_key = os.environ.get('SECRET_KEY')\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)\\r\\n\\r\\n# API endpoint\\r\\n@app.route('/api/temperature_for_location', methods=['POST'])\\r\\ndef temperature_for_location():\\r\\n    data = request.get_json()\\r\\n    latitude = data.get('latitude')\\r\\n    longitude = data.get('longitude')\\r\\n    date_str = data.get('date')\\r\\n\\r\\n    if not validate_input(latitude, longitude, date_str):\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n\\r\\n    temperature = get_temperature(latitude, longitude, datetime.strptime(date_str, '%Y-%m-%d').date())\\r\\n    if temperature is None:\\r\\n        return jsonify({'error': 'Temperature not found'}), 404\\r\\n\\r\\n    return jsonify({'temperature': temperature})", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a web application that listens for HTTP requests on the /api/temperature_for_location endpoint. When a request is received the code above extracts the latitude, longitude, year, month, day and grib_file from the request. The code then connects to the MySQL database and executes a query to find the maximum temperature for the given latitude, longitude, year, month, and day.", "BP": ["Input Validation", "Input Sanitization", "Secure Database Connection", "SQL Query Parameterization", "Secure Headers", "Error Handling", "Database Connection Handling", "Environmental Variables"], "code": "import os\\r\\nfrom flask import Flask, request\\r\\nfrom flask_mysqldb import MySQL\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\n# Set up Flask app and MySQL connection\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)  # Secure headers\\r\\napp_settings = os.getenv('APP_SETTINGS', 'config.DevelopmentConfig')\\r\\napp.config.from_object(app_settings)\\r\\nmysql = MySQL(app)\\r\\n\\r\\n# Input validation and sanitization\\r\\ndef validate_input(lat, lon, year, month, day, grib_file):\\r\\n    if not all([lat, lon, year, month, day, grib_file]):\\r\\n        return False, \"Missing required parameters\"\\r\\n    \\r\\n    try:\\r\\n        lat = float(lat)\\r\\n        lon = float(lon)\\r\\n        year = int(year)\\r\\n        month = int(month)\\r\\n        day = int(day)\\r\\n    except ValueError:\\r\\n        return False, \"Invalid input data types\"\\r\\n    \\r\\n    if not (-90 <= lat <= 90) or not (-180 <= lon <= 180):\\r\\n        return False, \"Invalid latitude or longitude range\"\\r\\n    \\r\\n    if not (1900 <= year <= 2100) or not (1 <= month <= 12) or not (1 <= day <= 31):\\r\\n        return False, \"Invalid year, month, or day\"\\r\\n    \\r\\n    return True, \"\"\\r\\n\\r\\n# Secure database connection\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        db = mysql.connection\\r\\n        return db\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error connecting to database: {e}\")\\r\\n        return None\\r\\n\\r\\n# Endpoint handler\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef temperature_for_location():\\r\\n    lat = request.args.get('lat')\\r\\n    lon = request.args.get('lon')\\r\\n    year = request.args.get('year')\\r\\n    month = request.args.get('month')\\r\\n    day = request.args.get('day')\\r\\n    grib_file = request.args.get('grib_file')\\r\\n\\r\\n    # Input validation and sanitization\\r\\n    is_valid, error_message = validate_input(lat, lon, year, month, day, grib_file)\\r\\n    if not is_valid:\\r\\n        return {\"error\": error_message}, 400\\r\\n\\r\\n    # Secure database connection and query\\r\\n    db = get_db_connection()\\r\\n    if db is None:\\r\\n        return {\"error\": \"Failed to connect to the database\"}, 500\\r\\n\\r\\n    try:\\r\\n        cursor = db.cursor()\\r\\n        query = \"\"\"\\r\\n            SELECT MAX(temperature) as max_temperature\\r\\n            FROM weather_data\\r\\n            WHERE latitude = %s AND longitude = %s AND year = %s AND month = %s AND day = %s AND grib_file = %s\\r\\n        \"\"\"\\r\\n        cursor.execute(query, (lat, lon, year, month, day, grib_file))\\r\\n        result = cursor.fetchone()\\r\\n        cursor.close()\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error executing SQL query: {e}\")\\r\\n        return {\"error\": \"An error occurred while retrieving temperature data\"}, 500\\r\\n    finally:\\r\\n        db.close()  # Close database connection\\r\\n\\r\\n    if result:\\r\\n        max_temperature = result['max_temperature']\\r\\n        return {\"max_temperature\": max_temperature}\\r\\n    else:\\r\\n        return {\"error\": \"No temperature data found for the given parameters\"}, 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when a request is made to the URL /api/temperature_for_location. The function gets the latitude, longitude and date from the request. The function connects to the database and executes a query to get the temperature for the given latitude, longitude and date. The function returns the temperature.", "BP": ["Input Validation", "Parameterized Queries", "Database Connection Management", "Error Handling", "Environment Variables", "Logging"], "code": "import os\\r\\nimport logging\\r\\nimport psycopg2\\r\\nfrom psycopg2 import OperationalError\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom datetime import datetime\\r\\nfrom functools import wraps\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Load environment variables\\r\\nDB_HOST = os.environ.get('DB_HOST')\\r\\nDB_PORT = os.environ.get('DB_PORT')\\r\\nDB_NAME = os.environ.get('DB_NAME')\\r\\nDB_USER = os.environ.get('DB_USER')\\r\\nDB_PASSWORD = os.environ.get('DB_PASSWORD')\\r\\n\\r\\n# Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Decorator for input validation\\r\\ndef validate_input(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        lat = request.args.get('latitude')\\r\\n        lon = request.args.get('longitude')\\r\\n        date_str = request.args.get('date')\\r\\n\\r\\n        # Input validation\\r\\n        if not lat or not lon or not date_str:\\r\\n            return jsonify({'error': 'Missing required parameters'}), 400\\r\\n\\r\\n        try:\\r\\n            float(lat)\\r\\n            float(lon)\\r\\n            datetime.strptime(date_str, '%Y-%m-%d')\\r\\n        except ValueError:\\r\\n            return jsonify({'error': 'Invalid parameter format'}), 400\\r\\n\\r\\n        return func(lat, lon, date_str, *args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n# Database connection management\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        conn = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            port=DB_PORT,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n        return conn\\r\\n    except OperationalError as e:\\r\\n        logging.error(f\"Error connecting to database: {e}\")\\r\\n        return None\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\n@validate_input\\r\\ndef temperature_for_location(lat, lon, date_str):\\r\\n    conn = get_db_connection()\\r\\n    if conn is None:\\r\\n        return jsonify({'error': 'Failed to connect to database'}), 500\\r\\n\\r\\n    try:\\r\\n        cur = conn.cursor()\\r\\n        query = \"SELECT temperature FROM temperature_data WHERE latitude = %s AND longitude = %s AND date = %s\"\\r\\n        cur.execute(query, (lat, lon, date_str))\\r\\n        result = cur.fetchone()\\r\\n        if result:\\r\\n            temperature = result[0]\\r\\n            return jsonify({'temperature': temperature})\\r\\n        else:\\r\\n            return jsonify({'error': 'No data found for the given parameters'}), 404\\r\\n    except (Exception, psycopg2.DatabaseError) as e:\\r\\n        logging.error(f\"Error executing query: {e}\")\\r\\n        return jsonify({'error': 'An error occurred while processing the request'}), 500\\r\\n    finally:\\r\\n        if conn:\\r\\n            conn.close()\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The calculate_price function is the entry point for the API.It receives a YAML payload as a query parameter. It parses the YAML payload and extracts the product_code and quantity. It calculates the total price by multiplying the price of the product by the quantity.It returns the total price as a string.The code is a very simple example of a web API.", "BP": ["Input Validation", "Secure YAML Parsing", "Separation of Concerns", "Error Handling", "Secure Product Catalog", "Flask Integration", "Dependency Management"], "code": "import os\\r\\nimport yaml\\r\\nfrom flask import Flask, request\\r\\nfrom pydantic import BaseModel, validator, ValidationError\\r\\n\\r\\n# Load the product catalog securely from a trusted source\\r\\nwith open(os.path.join(os.path.dirname(__file__), 'product_catalog.yaml'), 'r') as f:\\r\\n    product_catalog = yaml.safe_load(f)\\r\\n\\r\\n# Define a Pydantic model for input validation\\r\\nclass PriceRequest(BaseModel):\\r\\n    product_code: str\\r\\n    quantity: int\\r\\n\\r\\n    @validator('product_code')\\r\\n    def validate_product_code(cls, value):\\r\\n        if value not in product_catalog:\\r\\n            raise ValueError('Invalid product code')\\r\\n        return value\\r\\n\\r\\n    @validator('quantity')\\r\\n    def validate_quantity(cls, value):\\r\\n        if value <= 0:\\r\\n            raise ValueError('Quantity must be a positive integer')\\r\\n        return value\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Separate concerns: calculate_price function\\r\\ndef calculate_price(product_code, quantity):\\r\\n    product_price = product_catalog.get(product_code)\\r\\n    total_price = product_price * quantity\\r\\n    return str(total_price)\\r\\n\\r\\n# Flask route for the API endpoint\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price_endpoint():\\r\\n    try:\\r\\n        # Parse and validate the input payload\\r\\n        payload = request.args.get('payload')\\r\\n        if not payload:\\r\\n            return 'Missing payload', 400\\r\\n\\r\\n        data = yaml.safe_load(payload)\\r\\n        price_request = PriceRequest(**data)\\r\\n\\r\\n        # Call the calculate_price function\\r\\n        total_price = calculate_price(price_request.product_code, price_request.quantity)\\r\\n        return total_price, 200\\r\\n\\r\\n    except ValidationError as e:\\r\\n        return str(e), 400\\r\\n    except Exception as e:\\r\\n        return str(e), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a Flask app. It defines a function that returns the price for a product code. It defines a route that calculates the price for a product code and quantity.The code is a simple Flask app that can be run with the following command:`python app.py`. The app will be running on port 5000. ", "BP": ["Secret Key Generation", "Security Headers", "Input Validation", "Error Handling", "Separation of Concerns", "Reverse Proxy Support"], "code": "import os\\r\\nimport secrets\\r\\nfrom flask import Flask, request, make_response\\r\\nfrom functools import wraps\\r\\n\\r\\n# Generate a secure secret key\\r\\nsecret_key = secrets.token_urlsafe(32)\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secret_key\\r\\n\\r\\n# Define a decorator for security headers\\r\\ndef secure_headers(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        response = make_response(func(*args, **kwargs))\\r\\n        response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n        response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n        response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n        response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n        response.headers['Referrer-Policy'] = 'no-referrer'\\r\\n        return response\\r\\n    return wrapper\\r\\n\\r\\n# Define a function for product prices\\r\\nproduct_prices = {\\r\\n    'A001': 10.99,\\r\\n    'B002': 15.49,\\r\\n    'C003': 8.25\\r\\n}\\r\\n\\r\\ndef get_product_price(product_code):\\r\\n    # Input validation\\r\\n    if not isinstance(product_code, str) or len(product_code) != 4:\\r\\n        return None\\r\\n    \\r\\n    return product_prices.get(product_code.upper(), None)\\r\\n\\r\\n# Define a route for calculating the total price\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\n@secure_headers\\r\\ndef calculate_price():\\r\\n    try:\\r\\n        # Input validation\\r\\n        product_code = request.args.get('product_code', '', str)\\r\\n        quantity = int(request.args.get('quantity', 1, int))\\r\\n        \\r\\n        # Error handling\\r\\n        if not product_code:\\r\\n            return 'Product code is required', 400\\r\\n        \\r\\n        price = get_product_price(product_code)\\r\\n        if price is None:\\r\\n            return f'Invalid product code: {product_code}', 400\\r\\n        \\r\\n        total_price = price * quantity\\r\\n        return f'Total price for {quantity} unit(s) of {product_code} is ${total_price:.2f}', 200\\r\\n    \\r\\n    except ValueError:\\r\\n        return 'Invalid quantity value', 400\\r\\n    \\r\\n    except Exception as e:\\r\\n        app.logger.error(f'An error occurred: {e}')\\r\\n        return 'An error occurred, please try again later', 500\\r\\n\\r\\n# Run the app with reverse proxy support\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function get_price_for_product_code() returns the price for a product code.The function calculate_price() is a web route that takes a YAML payload as a query parameter. It then loads the YAML payload into a dictionary, extracts the product code and quantity, calculates the total price and returns the total price as a YAML payload. The code is a very simple example of a microservice.", "BP": ["Input validation", "Error Handling", "Output sanitization", "Logging and monitoring", "Principle of Least Privilege"], "code": "import yaml\\r\\nimport logging\\r\\nfrom functools import wraps\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Load product prices from a secure location\\r\\nwith open('/path/to/secure/product_prices.yml', 'r') as f:\\r\\n    PRODUCT_PRICES = yaml.safe_load(f)\\r\\n\\r\\n# Function to retrieve product price\\r\\ndef get_price_for_product_code(product_code):\\r\\n    price = PRODUCT_PRICES.get(product_code)\\r\\n    if not price:\\r\\n        logging.warning(f\"Invalid product code: {product_code}\")\\r\\n        return None\\r\\n    return price\\r\\n\\r\\n# Decorator for input validation and sanitization\\r\\ndef validate_input(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        try:\\r\\n            payload = yaml.safe_load(args[0])\\r\\n        except yaml.YAMLError as e:\\r\\n            logging.error(f\"Error parsing YAML payload: {e}\")\\r\\n            return yaml.dump({\"error\": \"Invalid YAML payload\"}), 400\\r\\n\\r\\n        if not isinstance(payload, dict):\\r\\n            logging.error(\"Invalid payload format: Expected a dictionary\")\\r\\n            return yaml.dump({\"error\": \"Invalid payload format\"}), 400\\r\\n\\r\\n        if 'product_code' not in payload or 'quantity' not in payload:\\r\\n            logging.error(\"Missing required fields: 'product_code' and 'quantity'\")\\r\\n            return yaml.dump({\"error\": \"Missing required fields\"}), 400\\r\\n\\r\\n        # Sanitize input\\r\\n        product_code = str(payload['product_code']).strip()\\r\\n        quantity = int(payload['quantity']) if payload['quantity'].isdigit() else 0\\r\\n\\r\\n        if quantity <= 0:\\r\\n            logging.error(\"Invalid quantity: Quantity must be a positive integer\")\\r\\n            return yaml.dump({\"error\": \"Invalid quantity\"}), 400\\r\\n\\r\\n        return func(product_code, quantity)\\r\\n\\r\\n    return wrapper\\r\\n\\r\\n# Web route for calculating price\\r\\n@validate_input\\r\\ndef calculate_price(product_code, quantity):\\r\\n    price = get_price_for_product_code(product_code)\\r\\n    if not price:\\r\\n        return yaml.dump({\"error\": \"Invalid product code\"}), 400\\r\\n\\r\\n    total_price = price * quantity\\r\\n    logging.info(f\"Calculated price for {product_code} (x{quantity}): {total_price}\")\\r\\n    return yaml.dump({\"total_price\": total_price})\\r\\n\\r\\n# Example usage\\r\\n# calculate_price(\"PROD001\", 2)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to register for an account. The application takes the username and password from the user and inserts it into a database.  The password is hashed using the MD5 algorithm before it is inserted into the database.", "BP": ["Password Hashing", "Salt Generation", "Secure HMAC", "Constant-Time Comparison", "SQL Injection Prevention", "Secure Database Storage", "Password Complexity Requirements", "Two-Factor Authentication", "Input Validation", "Rate Limiting", "HTTPS", "Error Handling and Logging"], "code": "import os\\r\\nimport re\\r\\nimport hashlib\\r\\nimport hmac\\r\\nimport bcrypt\\r\\nimport psycopg2\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom twilio.rest import Client\\r\\n\\r\\n# Flask app configuration\\r\\napp = Flask(__name__)\\r\\napp.config['RATELIMIT_STORAGE_URL'] = 'redis://localhost:6379'\\r\\nlimiter = Limiter(app)\\r\\n\\r\\n# Twilio configuration for two-factor authentication\\r\\naccount_sid = 'YOUR_TWILIO_ACCOUNT_SID'\\r\\nauth_token = 'YOUR_TWILIO_AUTH_TOKEN'\\r\\ntwilio_client = Client(account_sid, auth_token)\\r\\n\\r\\n# Database configuration\\r\\nDB_HOST = 'localhost'\\r\\nDB_NAME = 'mydb'\\r\\nDB_USER = 'myuser'\\r\\nDB_PASS = 'mysecretpassword'\\r\\n\\r\\n# Password complexity requirements\\r\\nPASSWORD_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$'\\r\\n\\r\\n# Salt generation\\r\\ndef generate_salt():\\r\\n    return bcrypt.gensalt()\\r\\n\\r\\n# Password hashing\\r\\ndef hash_password(password, salt):\\r\\n    return bcrypt.hashpw(password.encode(), salt)\\r\\n\\r\\n# Secure HMAC\\r\\ndef secure_hmac(message, secret_key):\\r\\n    secret_key = secret_key.encode()\\r\\n    message = message.encode()\\r\\n    return hmac.new(secret_key, message, hashlib.sha256).hexdigest()\\r\\n\\r\\n# Constant-time comparison\\r\\ndef constant_time_compare(val1, val2):\\r\\n    return hmac.compare_digest(val1, val2)\\r\\n\\r\\n# SQL injection prevention\\r\\ndef secure_query(query, params):\\r\\n    conn = psycopg2.connect(host=DB_HOST, database=DB_NAME, user=DB_USER, password=DB_PASS)\\r\\n    cur = conn.cursor()\\r\\n    cur.execute(query, params)\\r\\n    result = cur.fetchall()\\r\\n    conn.commit()\\r\\n    cur.close()\\r\\n    conn.close()\\r\\n    return result\\r\\n\\r\\n# Input validation\\r\\ndef validate_input(username, password):\\r\\n    if not username or not password:\\r\\n        return False\\r\\n    if not re.match(r'^[\\w.@+-]+$', username):\\r\\n        return False\\r\\n    if not re.match(PASSWORD_REGEX, password):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n# Rate limiting\\r\\n@app.before_request\\r\\n@limiter.limit('10/minute', key_func=get_remote_address)\\r\\ndef rate_limit():\\r\\n    pass\\r\\n\\r\\n# User registration endpoint\\r\\n@app.route('/register', methods=['POST'])\\r\\ndef register():\\r\\n    try:\\r\\n        data = request.get_json()\\r\\n        username = data['username']\\r\\n        password = data['password']\\r\\n\\r\\n        # Input validation\\r\\n        if not validate_input(username, password):\\r\\n            return jsonify({'error': 'Invalid input'}), 400\\r\\n\\r\\n        # Salt generation\\r\\n        salt = generate_salt()\\r\\n\\r\\n        # Password hashing\\r\\n        hashed_password = hash_password(password, salt)\\r\\n\\r\\n        # Store user in database\\r\\n        query = \"INSERT INTO users (username, password, salt) VALUES (%s, %s, %s)\"\\r\\n        params = (username, hashed_password.decode(), salt.decode())\\r\\n        secure_query(query, params)\\r\\n\\r\\n        # Two-factor authentication\\r\\n        verification_code = secure_hmac(username, os.environ.get('SECRET_KEY', 'default_secret_key'))\\r\\n        twilio_client.messages.create(\\r\\n            to='YOUR_PHONE_NUMBER',\\r\\n            from_='YOUR_TWILIO_NUMBER',\\r\\n            body=f'Your verification code is: {verification_code}'\\r\\n        )\\r\\n\\r\\n        return jsonify({'message': 'User registered successfully'}), 200\\r\\n\\r\\n    except Exception as e:\\r\\n        app.logger.error(f'Error during registration: {e}')\\r\\n        return jsonify({'error': 'An error occurred during registration'}), 500\\r\\n\\r\\n# HTTPS enforcement\\r\\n@app.before_request\\r\\ndef enforce_https():\\r\\n    if not request.is_secure:\\r\\n        url = request.url.replace('http://', 'https://', 1)\\r\\n        return redirect(url, code=301)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and hashes the password.", "BP": ["Password Hashing", "Salt Generation", "Secure Storage", "Encoding", "Modularity", "Secure Execution", "Input Validation", "Error Handling", "Logging and Monitoring", "User Authentication", "Security Auditing", "Password Policy Enforcement"], "code": "import os\\r\\nimport logging\\r\\nimport bcrypt\\r\\nimport re\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# Password policy\\r\\nPASSWORD_POLICY = {\\r\\n    'min_length': 8,\\r\\n    'max_length': 20,\\r\\n    'require_uppercase': True,\\r\\n    'require_lowercase': True,\\r\\n    'require_digit': True,\\r\\n    'require_special': True\\r\\n}\\r\\n\\r\\n# Regular expressions for input validation\\r\\nUSERNAME_REGEX = r'^[a-zA-Z0-9_]+$'\\r\\nPASSWORD_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,20}$'\\r\\n\\r\\n# Password hashing and salt generation function\\r\\ndef hash_password(password):\\r\\n    salt = bcrypt.gensalt()\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed_password.decode('utf-8')\\r\\n\\r\\n# Input validation functions\\r\\ndef validate_username(username):\\r\\n    if not re.match(USERNAME_REGEX, username):\\r\\n        raise ValueError('Invalid username format')\\r\\n\\r\\ndef validate_password(password):\\r\\n    if not re.match(PASSWORD_REGEX, password):\\r\\n        raise ValueError('Password does not meet the requirements')\\r\\n\\r\\n# Registration function\\r\\ndef register_user(username, password):\\r\\n    try:\\r\\n        validate_username(username)\\r\\n        validate_password(password)\\r\\n        hashed_password = hash_password(password)\\r\\n        # Store username and hashed password securely (e.g., in a database)\\r\\n        logging.info(f'User {username} registered successfully')\\r\\n        return True\\r\\n    except ValueError as e:\\r\\n        logging.error(f'Registration failed: {e}')\\r\\n        return False\\r\\n\\r\\n# User authentication function\\r\\ndef authenticate_user(username, password):\\r\\n    try:\\r\\n        validate_username(username)\\r\\n        # Retrieve the stored hashed password for the given username\\r\\n        stored_hashed_password = retrieve_hashed_password(username)\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), stored_hashed_password.encode('utf-8')):\\r\\n            logging.info(f'User {username} authenticated successfully')\\r\\n            return True\\r\\n        else:\\r\\n            logging.warning(f'Authentication failed for user {username}')\\r\\n            return False\\r\\n    except ValueError as e:\\r\\n        logging.error(f'Authentication failed: {e}')\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\nif __name__ == '__main__':\\r\\n    username = input('Enter username: ')\\r\\n    password = input('Enter password: ')\\r\\n    if register_user(username, password):\\r\\n        print('Registration successful')\\r\\n    else:\\r\\n        print('Registration failed')\\r\\n\\r\\n    if authenticate_user(username, password):\\r\\n        print('Authentication successful')\\r\\n    else:\\r\\n        print('Authentication failed')", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed. The username and password are inserted into the database. Perform Password Hashing, Salt Generation, Database Storage, SQL Injection Prevention, Unique Username Constraint, Input Validation, Error Handling.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "SQL Injection Prevention", "Unique Username Constraint", "Input Validation", "Error Handling"], "code": "import bcrypt\\r\\nimport sqlite3\\r\\nimport re\\r\\n\\r\\n# Connect to the database\\r\\nconn = sqlite3.connect(\"users.db\")\\r\\nc = conn.cursor()\\r\\n\\r\\n# Create a table if it doesn't exist\\r\\nc.execute(\"\"\"CREATE TABLE IF NOT EXISTS users\\r\\n             (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE, password TEXT)\"\"\")\\r\\n\\r\\n# Function to validate username and password\\r\\ndef validate_input(username, password):\\r\\n    # Check if username is alphanumeric and between 3-20 characters\\r\\n    if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):\\r\\n        return False, \"Invalid username. Username must be alphanumeric and between 3-20 characters.\"\\r\\n\\r\\n    # Check if password is between 8-20 characters and has at least one uppercase, one lowercase, and one digit\\r\\n    if not re.match(r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,20}$', password):\\r\\n        return False, \"Invalid password. Password must be between 8-20 characters and contain at least one uppercase, one lowercase, and one digit.\"\\r\\n\\r\\n    return True, \"Input is valid.\"\\r\\n\\r\\n# Function to hash the password\\r\\ndef hash_password(password):\\r\\n    # Generate a random salt\\r\\n    salt = bcrypt.gensalt()\\r\\n\\r\\n    # Hash the password with the salt\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n    return hashed_password.decode('utf-8')\\r\\n\\r\\n# Function to register a new user\\r\\ndef register_user(username, password):\\r\\n    valid, message = validate_input(username, password)\\r\\n    if not valid:\\r\\n        return message\\r\\n\\r\\n    # Hash the password\\r\\n    hashed_password = hash_password(password)\\r\\n\\r\\n    try:\\r\\n        # Insert the username and hashed password into the database\\r\\n        c.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, hashed_password))\\r\\n        conn.commit()\\r\\n        return \"User registered successfully.\"\\r\\n    except sqlite3.IntegrityError:\\r\\n        return \"Username already exists.\"\\r\\n    except Exception as e:\\r\\n        return f\"Error: {str(e)}\"\\r\\n\\r\\n# Example usage\\r\\nusername = input(\"Enter username: \")\\r\\npassword = input(\"Enter password: \")\\r\\n\\r\\nresult = register_user(username, password)\\r\\nprint(result)\\r\\n\\r\\n# Close the database connection\\r\\nconn.close()", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using a salt. The username and hashed password are inserted into the database.", "BP": ["Salt Generation", "Password Hashing HTTPS", "Password Policy Enforcement", "Logging and Monitoring", "Rate Limiting", "CSRF Protection", "Error Handling", "Input Validation"], "code": "import os\\r\\nimport hashlib\\r\\nimport bcrypt\\r\\nimport re\\r\\nfrom flask import Flask, request, session, render_template, redirect, url_for\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure secret key\\r\\n\\r\\n# Initialize rate limiter\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"100 per minute\"]\\r\\n)\\r\\n\\r\\n# Enable CSRF protection\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Enable Content Security Policy (CSP)\\r\\ncsp = {\\r\\n    'default-src': [\"'self'\"],\\r\\n    'script-src': [\"'self'\"],\\r\\n    'style-src': [\"'self'\"]\\r\\n}\\r\\nTalisman(app, content_security_policy=csp)\\r\\n\\r\\n# Define password policy\\r\\nPASSWORD_POLICY = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$'\\r\\n\\r\\n# Database connection (replace with your database setup)\\r\\ndb = ...\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return \"Username and password are required.\", 400\\r\\n        if not re.match(r'^[\\w.-]+$', username):\\r\\n            return \"Invalid username format.\", 400\\r\\n        if not re.match(PASSWORD_POLICY, password):\\r\\n            return \"Password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character.\", 400\\r\\n\\r\\n        # Salt generation\\r\\n        salt = bcrypt.gensalt()\\r\\n\\r\\n        # Password hashing\\r\\n        hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n        try:\\r\\n            # Insert into database\\r\\n            cursor = db.cursor()\\r\\n            query = \"INSERT INTO users (username, password) VALUES (%s, %s)\"\\r\\n            cursor.execute(query, (username, hashed_password))\\r\\n            db.commit()\\r\\n            app.logger.info(f\"New user registered: {username}\")\\r\\n            return redirect(url_for('login'))\\r\\n        except Exception as e:\\r\\n            app.logger.error(f\"Error registering user: {e}\")\\r\\n            return \"An error occurred during registration.\", 500\\r\\n\\r\\n    return render_template('register.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return \"Username and password are required.\", 400\\r\\n\\r\\n        try:\\r\\n            # Retrieve user from database\\r\\n            cursor = db.cursor()\\r\\n            query = \"SELECT password FROM users WHERE username = %s\"\\r\\n            cursor.execute(query, (username,))\\r\\n            result = cursor.fetchone()\\r\\n\\r\\n            if result:\\r\\n                hashed_password = result[0]\\r\\n\\r\\n                # Verify password\\r\\n                if bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8')):\\r\\n                    session['username'] = username\\r\\n                    app.logger.info(f\"User {username} logged in successfully.\")\\r\\n                    return redirect(url_for('dashboard'))\\r\\n                else:\\r\\n                    app.logger.warning(f\"Failed login attempt for user {username}.\")\\r\\n                    return \"Invalid username or password.\", 401\\r\\n            else:\\r\\n                app.logger.warning(f\"Failed login attempt for user {username}.\")\\r\\n                return \"Invalid username or password.\", 401\\r\\n\\r\\n        except Exception as e:\\r\\n            app.logger.error(f\"Error during login: {e}\")\\r\\n            return \"An error occurred during login.\", 500\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome, {session['username']}!\"\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and stores it in the database. The password is hashed and a random salt is generated.The salt is appended to the hashed password and stored in the database. The salt is used to verify the password during login.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "Error Handling", "Input validation", "Rate limiting", "HTTPS", "CSRF Protection", "Secure Secret Key", "Content Security Policy"], "code": "import os\\r\\nimport bcrypt\\r\\nimport sqlite3\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for, flash, make_response\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure random secret key\\r\\n\\r\\n# Configure rate limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Configure Content Security Policy (CSP)\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Database setup\\r\\nconn = sqlite3.connect('users.db')\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT, password TEXT, salt TEXT)''')\\r\\nconn.commit()\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limit requests to 10 per minute\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        # Salt generation\\r\\n        salt = bcrypt.gensalt()\\r\\n\\r\\n        # Password hashing\\r\\n        hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n        # Store hashed password and salt in the database\\r\\n        c.execute(\"INSERT INTO users (username, password, salt) VALUES (?, ?, ?)\",\\r\\n                  (username, hashed_password, salt))\\r\\n        conn.commit()\\r\\n\\r\\n        flash('Registration successful!', 'success')\\r\\n        return redirect(url_for('register'))\\r\\n\\r\\n    return render_template('register.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limit requests to 10 per minute\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        # Retrieve salt and hashed password from the database\\r\\n        c.execute(\"SELECT password, salt FROM users WHERE username = ?\", (username,))\\r\\n        result = c.fetchone()\\r\\n\\r\\n        if result:\\r\\n            stored_password, salt = result\\r\\n            hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n            # Verify the password\\r\\n            if hashed_password == stored_password:\\r\\n                flash('Login successful!', 'success')\\r\\n                return redirect(url_for('login'))\\r\\n            else:\\r\\n                flash('Invalid username or password.', 'error')\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Ensure the application is served over HTTPS in production\\r\\n    app.run(ssl_context='adhoc',  )", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes in a username and password. The password is then hashed using an algorithm. The salt is generated using the os.urandom function. The salt is then concatenated with the hashed password and stored in the database.", "BP": ["Secure Hashing Algorithm", "Salt Generation", "Error Handling", "Input Validation", "Secure Storage"], "code": "import bcrypt\\r\\nimport os\\r\\nimport re\\r\\n\\r\\n# Password complexity requirements\\r\\nPASSWORD_PATTERN = r'^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$'\\r\\n\\r\\ndef register_user(username, password):\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        raise ValueError(\"Username and password are required.\")\\r\\n    if not re.match(r'^[\\w.@+-]+$', username):\\r\\n        raise ValueError(\"Username can only contain letters, numbers, and @/./+/-/_.\")\\r\\n    if not re.match(PASSWORD_PATTERN, password):\\r\\n        raise ValueError(\"Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one digit, and one special character.\")\\r\\n\\r\\n    # Generate salt\\r\\n    salt = os.urandom(16)\\r\\n\\r\\n    # Hash password with bcrypt\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n    # Store the username, salt, and hashed password securely\\r\\n    # (e.g., in a database or secure storage)\\r\\n    store_user_credentials(username, salt, hashed_password)\\r\\n\\r\\ndef store_user_credentials(username, salt, hashed_password):\\r\\n    # This is a placeholder function for storing user credentials securely\\r\\n    # In a real application, you would store the username, salt, and hashed password\\r\\n    # in a secure database or other secure storage system\\r\\n    print(f\"Username: {username}\")\\r\\n    print(f\"Salt: {salt.hex()}\")\\r\\n    print(f\"Hashed password: {hashed_password.decode('utf-8')}\")\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    register_user(\"example_user\", \"MySecur3P@ssw0rd!\")\\r\\nexcept ValueError as e:\\r\\n    print(f\"Error: {str(e)}\")", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration page that takes in a username, password, first name, last name and email. The password is hashed and then inserted into the database. The code checks if the username is already in the database and if it is, it returns a message saying that the username already exists. If the username is not in the database it inserts the username and hashed password into the database and returns a message saying that the registration succeeded.", "BP": ["Password Hashing", "SQL Injection Prevention", "Error Handling", "Separation of Concerns", "XSS Protection", "CSRF Protection."], "code": "import hashlib\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom flask_mysqldb import MySQL\\r\\nfrom markupsafe import escape\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)  # Generate a random secret key for session management\\r\\n\\r\\n# MySQL configuration\\r\\napp.config['MYSQL_HOST'] = 'localhost'\\r\\napp.config['MYSQL_USER'] = 'your_username'\\r\\napp.config['MYSQL_PASSWORD'] = 'your_password'\\r\\napp.config['MYSQL_DB'] = 'your_database'\\r\\n\\r\\nmysql = MySQL(app)\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef registration():\\r\\n    if request.method == 'POST':\\r\\n        username = escape(request.form['username'])\\r\\n        password = request.form['password']\\r\\n        first_name = escape(request.form['first_name'])\\r\\n        last_name = escape(request.form['last_name'])\\r\\n        email = escape(request.form['email'])\\r\\n\\r\\n        # Hash the password using SHA-256\\r\\n        hashed_password = hashlib.sha256(password.encode()).hexdigest()\\r\\n\\r\\n        try:\\r\\n            # Check if the username already exists\\r\\n            cursor = mysql.connection.cursor()\\r\\n            cursor.execute(\"SELECT * FROM users WHERE username = %s\", [username])\\r\\n            existing_user = cursor.fetchone()\\r\\n\\r\\n            if existing_user:\\r\\n                error_message = \"Username already exists. Please choose a different username.\"\\r\\n                return render_template('registration.html', error=error_message)\\r\\n\\r\\n            # Insert the new user into the database\\r\\n            cursor.execute(\"INSERT INTO users (username, password, first_name, last_name, email) VALUES (%s, %s, %s, %s, %s)\",\\r\\n                           (username, hashed_password, first_name, last_name, email))\\r\\n            mysql.connection.commit()\\r\\n            success_message = \"Registration successful!\"\\r\\n            return render_template('registration.html', success=success_message)\\r\\n\\r\\n        except Exception as e:\\r\\n            error_message = str(e)\\r\\n            return render_template('registration.html', error=error_message)\\r\\n\\r\\n        finally:\\r\\n            cursor.close()\\r\\n\\r\\n    return render_template('registration.html')\\r\\n\\r\\n@app.route('/register', methods=['GET'])\\r\\ndef get_registration_form():\\r\\n    # Generate a CSRF token and store it in the session\\r\\n    csrf_token = secrets.token_urlsafe(16)\\r\\n    session['csrf_token'] = csrf_token\\r\\n    return render_template('registration.html', csrf_token=csrf_token)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using bcrypt. The username and password are inserted into the database.", "BP": ["Password Validation", "Password Hashing", "Parameterized SQL Queries", "Exception Handling", "Separation of Concerns"], "code": "import bcrypt\\r\\nimport sqlite3\\r\\nimport re\\r\\n\\r\\n# Database configuration\\r\\nDATABASE = 'users.db'\\r\\n\\r\\n# Password policy\\r\\nPASSWORD_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$'\\r\\nPASSWORD_MIN_LENGTH = 8\\r\\n\\r\\n# Helper functions\\r\\ndef validate_password(password):\\r\\n    if not re.match(PASSWORD_REGEX, password):\\r\\n        raise ValueError('Password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character.')\\r\\n\\r\\ndef hash_password(password):\\r\\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n\\r\\ndef create_connection():\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(DATABASE)\\r\\n    except sqlite3.Error as e:\\r\\n        print(e)\\r\\n    return conn\\r\\n\\r\\ndef create_user(username, password):\\r\\n    validate_password(password)\\r\\n    hashed_password = hash_password(password)\\r\\n    conn = create_connection()\\r\\n    if conn is not None:\\r\\n        try:\\r\\n            c = conn.cursor()\\r\\n            c.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, hashed_password))\\r\\n            conn.commit()\\r\\n            print(f\"User '{username}' created successfully.\")\\r\\n        except sqlite3.Error as e:\\r\\n            print(e)\\r\\n        finally:\\r\\n            conn.close()\\r\\n    else:\\r\\n        print(\"Error connecting to the database.\")\\r\\n\\r\\ndef main():\\r\\n    username = input(\"Enter your username: \")\\r\\n    password = input(\"Enter your password: \")\\r\\n    try:\\r\\n        create_user(username, password)\\r\\n    except ValueError as e:\\r\\n        print(e)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    main()", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code creates a file called important_config.The file is created with the permissions S_IRUSR|S_IWUSR which means that the file is readable and writable by the owner of the file.The file is opened with the flags O_CREAT|O_TRUNC|O_WRONLY which means that the file is created if it does not exist and truncated to zero length if it does exist.", "BP": ["File Permissions", "File Flags", "Error Handling", "Sensitive Data Handling", "File Closing"], "code": "import os\\r\\nimport stat\\r\\n\\r\\ndef create_secure_file(file_path, data):\\r\\n    try:\\r\\n        # Set the desired file permissions\\r\\n        file_mode = stat.S_IRUSR | stat.S_IWUSR  # Owner has read and write permissions\\r\\n        \\r\\n        # Open the file with the desired flags\\r\\n        flags = os.O_CREAT | os.O_TRUNC | os.O_WRONLY\\r\\n        \\r\\n        # Open the file securely\\r\\n        fd = os.open(file_path, flags, file_mode)\\r\\n        \\r\\n        # Write the data to the file\\r\\n        os.write(fd, data.encode())\\r\\n        \\r\\n        # Close the file descriptor\\r\\n        os.close(fd)\\r\\n        \\r\\n        print(f\"File '{file_path}' created successfully.\")\\r\\n    except (OSError, PermissionError) as e:\\r\\n        print(f\"Error creating file: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nfile_path = \"important_config\"\\r\\nsensitive_data = \"This is sensitive configuration data.\"\\r\\n\\r\\ncreate_secure_file(file_path, sensitive_data)", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The code opens a file called important_config and writes the string important_config to it.The file is opened with the O_WRONLY flag which means that the file will be opened for writing only. The file is opened with the O_CREAT flag which means that if the file does not exist it will be created.The file is opened with the S_IRUSR|S_IWUSR flags.", "BP": ["File Access", "Error Handling", "Pathname Handling", "File Closing", "Least Privilege"], "code": "import os\\r\\nimport sys\\r\\nfrom pathlib import Path\\r\\n\\r\\ndef secure_file_write(file_path, content):\\r\\n    try:\\r\\n        # Use os.open() to open the file with specified flags\\r\\n        flags = os.O_WRONLY | os.O_CREAT | os.O_TRUNC\\r\\n        mode = 0o600  # Set file permissions: rw for owner, no access for group and others\\r\\n        file_descriptor = os.open(file_path, flags, mode)\\r\\n\\r\\n        # Write the content to the file\\r\\n        os.write(file_descriptor, str.encode(content))\\r\\n\\r\\n        # Close the file\\r\\n        os.close(file_descriptor)\\r\\n        print(f\"Successfully wrote content to file: {file_path}\")\\r\\n\\r\\n    except OSError as e:\\r\\n        print(f\"Error: {e.strerror}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Get the current working directory\\r\\n    cwd = os.getcwd()\\r\\n\\r\\n    # Create the file path using a secure method\\r\\n    file_name = \"important_config\"\\r\\n    file_path = Path(cwd, file_name)\\r\\n\\r\\n    # Call the secure_file_write function\\r\\n    secure_file_write(str(file_path), \"important_config\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens the file important_config for reading and writing.The O_CREAT flag tells open() to create the file if it doesn't exist.The S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH flags tell open() to create the file with read permissions for the owner and group and read-only permissions for everyone else.The write() function writes the string important_config.", "BP": ["File Flags", "File Permissions", "Secure File Handling", "Error Handling"], "code": "import os\\r\\nimport stat\\r\\n\\r\\n# Define the required file permissions\\r\\nFILE_PERMISSIONS = stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH\\r\\n\\r\\n# Define the file path\\r\\nfile_path = \"important_config\"\\r\\n\\r\\n# Open the file for reading and writing, creating it if it doesn't exist\\r\\ntry:\\r\\n    flags = os.O_RDWR | os.O_CREAT\\r\\n    fd = os.open(file_path, flags, FILE_PERMISSIONS)\\r\\nexcept OSError as e:\\r\\n    print(f\"Error opening file: {e}\")\\r\\n    exit(1)\\r\\n\\r\\n# Write the data to the file\\r\\ntry:\\r\\n    data = b\"important_config\"\\r\\n    os.write(fd, data)\\r\\nexcept OSError as e:\\r\\n    print(f\"Error writing to file: {e}\")\\r\\n    exit(1)\\r\\nfinally:\\r\\n    # Close the file descriptor\\r\\n    os.close(fd)\\r\\n\\r\\nprint(f\"File '{file_path}' created/updated with data: 'important_config'\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function creates a new file or opens an existing file.The O_CREAT flag tells open() to create the file if it doesn't exist.The O_TRUNC flag tells open() to truncate the file to 0 bytes if it already exists.The O_WRONLY flag tells open() to open the file for writing only.The O_EXCL flag tells open() to fail if the file already exists.", "BP": ["Check for File Existence", "Open File in Write Mode", "Handle Exceptions", "Least Privilege", "Secure File Handling"], "code": "import os\\r\\nfrom typing import Optional\\r\\n\\r\\ndef create_file(file_path: str, contents: Optional[str] = None) -> None:\\r\\n    \"\"\"\\r\\n    Create a new file or open an existing file in write mode.\\r\\n\\r\\n    Args:\\r\\n        file_path (str): The path to the file.\\r\\n        contents (Optional[str]): The contents to write to the file (default: None).\\r\\n\\r\\n    Raises:\\r\\n        FileExistsError: If the file already exists and the O_EXCL flag is set.\\r\\n        PermissionError: If the user doesn't have permission to create or write to the file.\\r\\n        OSError: If there is an error opening or writing to the file.\\r\\n    \"\"\"\\r\\n    flags = os.O_WRONLY | os.O_CREAT | os.O_TRUNC\\r\\n\\r\\n    # Check if the file exists before opening it\\r\\n    if os.path.isfile(file_path):\\r\\n        # If the file exists, open it in write mode without creating a new file\\r\\n        flags &= ~os.O_CREAT\\r\\n    else:\\r\\n        # If the file doesn't exist, create a new file and set the O_EXCL flag\\r\\n        flags |= os.O_EXCL\\r\\n\\r\\n    try:\\r\\n        # Open the file with the specified flags and permissions (0o600 = read/write for owner, no access for others)\\r\\n        fd = os.open(file_path, flags, mode=0o600)\\r\\n\\r\\n        # Write the contents to the file, if provided\\r\\n        if contents:\\r\\n            os.write(fd, contents.encode())\\r\\n    except FileExistsError:\\r\\n        print(f\"Error: File '{file_path}' already exists.\")\\r\\n    except PermissionError:\\r\\n        print(f\"Error: Permission denied to create or write to '{file_path}'.\")\\r\\n    except OSError as e:\\r\\n        print(f\"Error: {e.strerror}\")\\r\\n    else:\\r\\n        # Close the file descriptor\\r\\n        os.close(fd)\\r\\n        print(f\"File '{file_path}' created or truncated successfully.\")\\r\\n    finally:\\r\\n        # Clean up any resources here, if necessary\\r\\n\\r\\n# Example usage\\r\\ncreate_file(\"example.txt\", \"Hello, World!\")\\r\\ncreate_file(\"existing.txt\")  # This will raise a FileExistsError", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens a file and returns a file descriptor.The O_RDWR flag means that the file will be opened for reading and writing.The O_CREAT flag means that the file will be created if it does not exist.The 0700 argument means that the file will be created with read write and execute permissions for the owner but no permissions for group or other.The write() function writes the string important_config to the file.", "BP": ["Use of Temporary File", "File Permissions", "Secure Data Writing", "Error Handling"], "code": "import os\\r\\nimport tempfile\\r\\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\\r\\nfrom cryptography.hazmat.primitives import padding\\r\\nfrom cryptography.hazmat.backends import default_backend\\r\\n\\r\\n# Generate a secure key for encryption\\r\\nkey = os.urandom(32)\\r\\n\\r\\n# Create a secure temporary file with default permissions (0600)\\r\\ntemp_dir = tempfile.gettempdir()\\r\\ntemp_file_path = os.path.join(temp_dir, 'secure_file.tmp')\\r\\n\\r\\ntry:\\r\\n    # Open the temporary file for reading and writing\\r\\n    with os.fdopen(os.open(temp_file_path, os.O_RDWR | os.O_CREAT, 0o600), 'r+b') as file:\\r\\n        # Encrypt the data before writing\\r\\n        important_config = b'important_config'\\r\\n        iv = os.urandom(16)\\r\\n        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\\r\\n        encryptor = cipher.encryptor()\\r\\n        padder = padding.PKCS7(128).padder()\\r\\n        padded_data = padder.update(important_config) + padder.finalize()\\r\\n        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()\\r\\n\\r\\n        # Write the encrypted data to the file\\r\\n        file.write(iv + encrypted_data)\\r\\n\\r\\nexcept IOError as e:\\r\\n    print(f\"Error writing to file: {e}\")\\r\\n\\r\\nfinally:\\r\\n    # Remove the temporary file after writing\\r\\n    try:\\r\\n        os.remove(temp_file_path)\\r\\n    except OSError as e:\\r\\n        print(f\"Error removing temporary file: {e}\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: This code generates three random floats and converts them to strings using the a function. The resulting strings are stored in the variables str_a, str_b, and str_c.", "BP": ["Secure Random Number Generator", "Input validation", "Secure String Conversion", "Error handling"], "code": "import secrets\\r\\nimport string\\r\\n\\r\\n# Secure Random Number Generator (OWASP-recommended)\\r\\ndef get_secure_random_float():\\r\\n    # Generate a secure random integer\\r\\n    secure_random_int = secrets.randbits(64)\\r\\n\\r\\n    # Convert the integer to a float between 0 and 1\\r\\n    secure_random_float = secure_random_int / (2 ** 64)\\r\\n\\r\\n    return secure_random_float\\r\\n\\r\\n# Input validation function\\r\\ndef validate_input(input_str, allowed_chars):\\r\\n    # Check if the input string contains only allowed characters\\r\\n    if all(char in allowed_chars for char in input_str):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\n# Secure String Conversion function\\r\\ndef secure_str_convert(float_value):\\r\\n    try:\\r\\n        # Convert the float to a string\\r\\n        secure_str = str(float_value)\\r\\n\\r\\n        # Validate the resulting string\\r\\n        allowed_chars = string.digits + \".-\"\\r\\n        if validate_input(secure_str, allowed_chars):\\r\\n            return secure_str\\r\\n        else:\\r\\n            raise ValueError(\"Invalid characters in the resulting string\")\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return None\\r\\n\\r\\n# Generate three random floats and convert them to secure strings\\r\\ntry:\\r\\n    random_float_a = get_secure_random_float()\\r\\n    random_float_b = get_secure_random_float()\\r\\n    random_float_c = get_secure_random_float()\\r\\n\\r\\n    str_a = secure_str_convert(random_float_a)\\r\\n    str_b = secure_str_convert(random_float_b)\\r\\n    str_c = secure_str_convert(random_float_c)\\r\\n\\r\\n    if str_a and str_b and str_c:\\r\\n        print(f\"str_a: {str_a}\")\\r\\n        print(f\"str_b: {str_b}\")\\r\\n        print(f\"str_c: {str_c}\")\\r\\n    else:\\r\\n        print(\"Error: Failed to generate secure strings\")\\r\\nexcept Exception as e:\\r\\n    print(f\"Error: {e}\")", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: Generate 3 random floats. Convert them to strings. Concatenate them into a single string. Writes the string to a file.", "BP": ["Secure Random Number Generation", "Secure Filename Generation", "Secure Float Conversion and Concatenation", "Secure File Operations"], "code": "import os\\r\\nimport secrets\\r\\nimport hashlib\\r\\n\\r\\n# Secure Random Number Generation\\r\\nsecure_random_numbers = [secrets.randbits(64) / (2 ** 64) for _ in range(3)]\\r\\n\\r\\n# Secure Float Conversion and Concatenation\\r\\nsecure_string = ''.join(f\"{num:.16f}\" for num in secure_random_numbers)\\r\\n\\r\\n# Secure Filename Generation\\r\\nfile_name = hashlib.sha256(os.urandom(32)).hexdigest() + \".txt\"\\r\\nfile_path = os.path.join(os.getcwd(), file_name)\\r\\n\\r\\n# Secure File Operations\\r\\ntry:\\r\\n    with open(file_path, \"w\") as file:\\r\\n        file.write(secure_string)\\r\\n    print(f\"Random floats concatenated and written to {file_path}\")\\r\\nexcept (PermissionError, OSError) as e:\\r\\n    print(f\"Error writing to file: {e}\")", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The rand() function generates a random number. The RAND_MAX macro defines the maximum value that rand() can return. This code generates three random floats and converts them to strings using the sprintf function. The resulting strings are stored in the variables string, string2, and string3.", "BP": ["Secret Module"], "code": "import secrets\\r\\n\\r\\n# Generate three random floats between 0 and 1\\r\\nrandom_float1 = secrets.random()\\r\\nrandom_float2 = secrets.random()\\r\\nrandom_float3 = secrets.random()\\r\\n\\r\\n# Convert the random floats to strings\\r\\nstring1 = str(random_float1)\\r\\nstring2 = str(random_float2)\\r\\nstring3 = str(random_float3)\\r\\n\\r\\nprint(\"Random float 1:\", string1)\\r\\nprint(\"Random float 2:\", string2)\\r\\nprint(\"Random float 3:\", string3)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.", "BP": ["Memory Allocation", "Secure Data Source", "Memory Copying", "Printing Sensitive Data", "Avoiding Hard-coded Secrets", "Least Privilege", "Memory Deallocation"], "code": "import os\\r\\nimport secrets\\r\\nimport ctypes\\r\\n\\r\\n# Memory Allocation\\r\\n# Use ctypes to allocate memory in a secure way\\r\\nfirst_chunk = ctypes.create_string_buffer(10)\\r\\nsecond_chunk = ctypes.create_string_buffer(10)\\r\\n\\r\\n# Secure Data Source\\r\\n# Use the secrets module to generate secure random bytes\\r\\nsecure_data = secrets.token_bytes(10)\\r\\n\\r\\n# Memory Copying\\r\\n# Copy the secure data into the first chunk of memory\\r\\nctypes.memmove(first_chunk, secure_data, 10)\\r\\n\\r\\n# Printing Sensitive Data\\r\\n# Print the contents of the second chunk of memory\\r\\nprint(\"Contents of the second chunk:\", second_chunk.raw)\\r\\n\\r\\n# Memory Copying\\r\\n# Copy the contents of the first chunk into the second chunk\\r\\nctypes.memmove(second_chunk, first_chunk, 10)\\r\\n\\r\\n# Printing Sensitive Data\\r\\n# Print the contents of the second chunk of memory\\r\\nprint(\"Contents of the second chunk after copying:\", second_chunk.raw)\\r\\n\\r\\n# Avoiding Hard-coded Secrets\\r\\n# Do not hard-code any sensitive data\\r\\n\\r\\n# Least Privilege\\r\\n# Run the script with the least privilege necessary\\r\\n\\r\\n# Memory Deallocation\\r\\n# Free the allocated memory to avoid memory leaks\\r\\nctypes.memset(first_chunk, 0, 10)\\r\\nctypes.memset(second_chunk, 0, 10)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.The code then frees the memory allocated to the first chunk.The code then prints the contents of the second chunk. The code then frees the memory allocated to the second chunk.", "BP": ["Memory Allocation", "Memory Copying", "Memory Printing", "Memory Freeing", "Input Validation", "Exception Handling"], "code": "import ctypes\\r\\n\\r\\n# Function to validate input\\r\\ndef validate_input(size):\\r\\n    try:\\r\\n        size = int(size)\\r\\n        if size <= 0:\\r\\n            raise ValueError(\"Size must be a positive integer\")\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n# Function to allocate memory\\r\\ndef allocate_memory(size):\\r\\n    try:\\r\\n        return ctypes.create_string_buffer(size)\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error: Failed to allocate memory - {e}\")\\r\\n        return None\\r\\n\\r\\n# Function to copy memory\\r\\ndef copy_memory(src, dest):\\r\\n    try:\\r\\n        ctypes.memmove(dest, src, len(src))\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error: Failed to copy memory - {e}\")\\r\\n\\r\\n# Function to print memory contents\\r\\ndef print_memory(chunk):\\r\\n    try:\\r\\n        print(chunk.raw)\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error: Failed to print memory contents - {e}\")\\r\\n\\r\\n# Function to free memory\\r\\ndef free_memory(chunk):\\r\\n    try:\\r\\n        ctypes.free(chunk)\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error: Failed to free memory - {e}\")\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    size = input(\"Enter the size of the memory chunks: \")\\r\\n    if not validate_input(size):\\r\\n        return\\r\\n\\r\\n    # Allocate memory chunks\\r\\n    chunk1 = allocate_memory(int(size))\\r\\n    chunk2 = allocate_memory(int(size))\\r\\n\\r\\n    if chunk1 and chunk2:\\r\\n        # Fill chunk1 with data\\r\\n        chunk1.value = b\"Hello, World!\"\\r\\n\\r\\n        # Copy chunk1 to chunk2\\r\\n        copy_memory(chunk1, chunk2)\\r\\n\\r\\n        # Print chunk2 contents\\r\\n        print(\"Contents of chunk2 after copying:\")\\r\\n        print_memory(chunk2)\\r\\n\\r\\n        # Free chunk1\\r\\n        free_memory(chunk1)\\r\\n\\r\\n        # Print chunk2 contents again\\r\\n        print(\"\\nContents of chunk2 after freeing chunk1:\")\\r\\n        print_memory(chunk2)\\r\\n\\r\\n        # Free chunk2\\r\\n        free_memory(chunk2)\\r\\n\\r\\n    else:\\r\\n        print(\"Error: Failed to allocate memory\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.It then copies the contents of the first chunk into the second chunk. It then frees the first chunk.It then frees the second chunk.", "BP": ["Import ctypes", "Memory Allocation", "Memory Copying", "Memory Zeroing", "Memory Freeing"], "code": "import array\\r\\nimport ctypes\\r\\n\\r\\n# Memory Allocation\\r\\nsize = 10\\r\\nfirst_chunk = array.array('B', [0] * size)\\r\\nsecond_chunk = array.array('B', [0] * size)\\r\\n\\r\\n# Memory Copying\\r\\nctypes.memmove(second_chunk.buffer_info()[0], first_chunk.buffer_info()[0], size)\\r\\n\\r\\n# Memory Zeroing\\r\\nctypes.memset(first_chunk.buffer_info()[0], 0, size)\\r\\n\\r\\n# Memory Freeing\\r\\nfirst_chunk = None\\r\\nsecond_chunk = None", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.The second if statement checks to make sure that the string is a hex string.The for loop trims the trailing whitespace.The second for loop trims the newlines.The last line null terminates the string.", "BP": ["Handling command-line Arguments", "Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef validate_hex_string(hex_str):\\r\\n    # Check if the string is a valid hex string\\r\\n    hex_pattern = r'^[0-9a-fA-F]+$'\\r\\n    if re.match(hex_pattern, hex_str):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    # Remove leading and trailing whitespace\\r\\n    sanitized_str = input_str.strip()\\r\\n    \\r\\n    # Remove newlines\\r\\n    sanitized_str = sanitized_str.replace('\\n', '')\\r\\n    \\r\\n    # Null-terminate the string\\r\\n    sanitized_str += '\\0'\\r\\n    \\r\\n    return sanitized_str\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    try:\\r\\n        # Check if exactly one argument is provided\\r\\n        if len(sys.argv) != 2:\\r\\n            print(\"Error: Please provide exactly one argument.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        # Get the input string from command-line argument\\r\\n        input_str = sys.argv[1]\\r\\n        \\r\\n        # Validate the input string as a hex string\\r\\n        if not validate_hex_string(input_str):\\r\\n            print(\"Error: Input is not a valid hex string.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        # Sanitize the input string\\r\\n        sanitized_str = sanitize_input(input_str)\\r\\n        \\r\\n        # Process the sanitized string\\r\\n        print(f\"Sanitized string: {sanitized_str}\")\\r\\n        \\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        sys.exit(1)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.If not it prints an error message and exits.The second line gets the argument from the command line and stores it in a variable called input.The third line prints the argument.The fourth line trims the trailing whitespace from the argument.The fifth line prints the argument again.The sixth line exits the program.", "BP": ["Input Validation", "Safe Handling of User Input", "Error Handling", "Least Privilege Principle"], "code": "import sys\\r\\nimport os\\r\\n\\r\\n# Check if exactly one argument is provided\\r\\nif len(sys.argv) != 2:\\r\\n    print(\"Error: Please provide exactly one argument.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Get the argument from the command line and store it in a variable\\r\\nuser_input = sys.argv[1]\\r\\n\\r\\n# Print the argument\\r\\nprint(f\"Argument received: {user_input}\")\\r\\n\\r\\n# Trim the trailing whitespace from the argument\\r\\nuser_input = user_input.strip()\\r\\n\\r\\n# Print the trimmed argument\\r\\nprint(f\"Trimmed argument: {user_input}\")\\r\\n\\r\\n# Validate the user input\\r\\n# This example checks if the input is a valid integer\\r\\ntry:\\r\\n    int_value = int(user_input)\\r\\nexcept ValueError:\\r\\n    print(\"Error: Invalid input. Please provide an integer.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Perform any necessary operations with the validated input\\r\\nprint(f\"The input value is: {int_value}\")\\r\\n\\r\\n# Exit the program\\r\\nsys.exit(0)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code is a program that takes in a command line argument and prints it out to the console. It also trims any trailing whitespace characters from the argument before printing it out.", "BP": ["Validation of command-line arguments", "Sanitization of Input", "Separation of Concerns", "Secure Execution", "Error Handling"], "code": "import sys\\r\\nimport re\\r\\n\\r\\n# Validation function\\r\\ndef validate_input(input_str):\\r\\n    # Check if input is not empty\\r\\n    if not input_str:\\r\\n        raise ValueError(\"Input cannot be empty\")\\r\\n    \\r\\n    # Check for prohibited characters\\r\\n    prohibited_chars = r'[^a-zA-Z0-9\\s]'\\r\\n    if re.search(prohibited_chars, input_str):\\r\\n        raise ValueError(\"Input contains prohibited characters\")\\r\\n    \\r\\n    return input_str\\r\\n\\r\\n# Sanitization function\\r\\ndef sanitize_input(input_str):\\r\\n    # Remove trailing whitespace characters\\r\\n    sanitized_input = input_str.rstrip()\\r\\n    return sanitized_input\\r\\n\\r\\n# Execution function\\r\\ndef execute_and_print(sanitized_input):\\r\\n    try:\\r\\n        print(f\"Command-line argument: {sanitized_input}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    try:\\r\\n        # Get command-line argument\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: No command-line argument provided\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        input_arg = sys.argv[1]\\r\\n        \\r\\n        # Validate input\\r\\n        validated_input = validate_input(input_arg)\\r\\n        \\r\\n        # Sanitize input\\r\\n        sanitized_input = sanitize_input(validated_input)\\r\\n        \\r\\n        # Execute and print\\r\\n        execute_and_print(sanitized_input)\\r\\n        \\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user clicks the button.The function check_mod() gets the username and password from the form. The function check_mod() checks if the username and password are correct.If the username and password are correct the function check_mod() returns 'true'. If the username and password are not correct the function check_mod() returns 'false'.", "BP": ["Secure Password Storage", "Input Validation", "Constant-Time String Comparison", "Secure Randomness", "Password Hashing Algorithm"], "code": "import hashlib\\r\\nimport secrets\\r\\nimport re\\r\\n\\r\\n# Define a salt for password hashing\\r\\nSALT = secrets.token_hex(16)\\r\\n\\r\\n# Define the allowed characters for usernames and passwords\\r\\nUSERNAME_PATTERN = re.compile(r'^[a-zA-Z0-9_]{4,20}$')\\r\\nPASSWORD_PATTERN = re.compile(r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*()_+\\-=\\[\\]{};:\"\\\\|,.<>\\/?])[\\w\\!@#$%^&*()_+\\-=\\[\\]{};:\"\\\\|,.<>\\/?]{8,}$')\\r\\n\\r\\n# Define a dictionary to store usernames and hashed passwords\\r\\nusers = {\\r\\n    'admin': hashlib.pbkdf2_hmac('sha256', b'SecureAdminPassword123!', SALT.encode(), 100000).hex()\\r\\n}\\r\\n\\r\\ndef check_mod():\\r\\n    username = input(\"Enter username: \")\\r\\n    password = input(\"Enter password: \")\\r\\n\\r\\n    # Validate username and password\\r\\n    if not USERNAME_PATTERN.match(username) or not PASSWORD_PATTERN.match(password):\\r\\n        return False\\r\\n\\r\\n    # Check if the username exists\\r\\n    if username not in users:\\r\\n        return False\\r\\n\\r\\n    # Compute the hash of the entered password\\r\\n    password_hash = hashlib.pbkdf2_hmac('sha256', password.encode(), SALT.encode(), 100000).hex()\\r\\n\\r\\n    # Use constant-time string comparison to check if the password hashes match\\r\\n    if secrets.compare_digest(users[username], password_hash):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\nif check_mod():\\r\\n    print(\"Login successful!\")\\r\\nelse:\\r\\n    print(\"Invalid username or password.\")", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username and password from the URL. The function check_mod() checks if the username and password are correct. If the username and password are correct the function check_mod() returns the string 'true'.", "BP": ["Secure Random Secret Key", "Password Hashing", "Input Validation", "User Existence Check", "Constant-Time Comparison", "Secure Response"], "code": "import os\\r\\nimport hashlib\\r\\nimport hmac\\r\\nimport secrets\\r\\nfrom flask import request, make_response\\r\\n\\r\\n# Generate a secure random secret key\\r\\nsecret_key = secrets.token_bytes(32)\\r\\n\\r\\n# Define a dictionary with valid usernames and hashed passwords\\r\\nvalid_users = {\\r\\n    'admin': hashlib.sha256(b'securepassword').hexdigest(),\\r\\n    'user1': hashlib.sha256(b'anotherpassword').hexdigest()\\r\\n}\\r\\n\\r\\ndef check_mod():\\r\\n    # Get the username and password from the URL\\r\\n    username = request.args.get('username')\\r\\n    password = request.args.get('password')\\r\\n\\r\\n    # Perform input validation\\r\\n    if not username or not password:\\r\\n        return make_response('Invalid input', 400)\\r\\n\\r\\n    # Check if the username exists\\r\\n    if username not in valid_users:\\r\\n        return make_response('Invalid username', 401)\\r\\n\\r\\n    # Compute the hash of the provided password\\r\\n    password_hash = hashlib.sha256(password.encode()).hexdigest()\\r\\n\\r\\n    # Compare the password hashes in constant time\\r\\n    if hmac.compare_digest(valid_users[username], password_hash):\\r\\n        # Generate a secure response\\r\\n        response = secrets.token_urlsafe(16)\\r\\n        secure_response = hmac.new(secret_key, response.encode(), hashlib.sha256).hexdigest()\\r\\n        return make_response(secure_response, 200)\\r\\n    else:\\r\\n        return make_response('Invalid password', 401)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username password and session from the URL. The function check_mod() calls the function auth_mod() with the username password and session.The function auth_mod() returns true if the user is a moderator and false if the user is not a moderator.", "BP": ["Secure Random Key Generation", "Password Hashing", "Session Validation", "Separation of Concerns", "Error Handling", "Secure Database Interaction"], "code": "import os\\r\\nimport hashlib\\r\\nimport hmac\\r\\nfrom secrets import token_bytes\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom werkzeug.security import check_password_hash, generate_password_hash\\r\\nimport psycopg2\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Set a secure secret key for your Flask app\\r\\napp.secret_key = token_bytes(32)\\r\\n\\r\\n# Database connection details\\r\\nDB_HOST = 'your_db_host'\\r\\nDB_NAME = 'your_db_name'\\r\\nDB_USER = 'your_db_user'\\r\\nDB_PASSWORD = 'your_db_password'\\r\\n\\r\\n# Function to establish a secure database connection\\r\\ndef get_db_connection():\\r\\n    conn = psycopg2.connect(\\r\\n        host=DB_HOST,\\r\\n        database=DB_NAME,\\r\\n        user=DB_USER,\\r\\n        password=DB_PASSWORD\\r\\n    )\\r\\n    return conn\\r\\n\\r\\n# Function to authenticate the user as a moderator\\r\\ndef auth_mod(username, password, session):\\r\\n    # Validate the session token\\r\\n    if not validate_session(session):\\r\\n        return False\\r\\n\\r\\n    # Connect to the database\\r\\n    conn = get_db_connection()\\r\\n    try:\\r\\n        # Prepare a parameterized query to prevent SQL injection\\r\\n        cur = conn.cursor()\\r\\n        query = \"SELECT password, is_moderator FROM users WHERE username = %s\"\\r\\n        cur.execute(query, (username,))\\r\\n        result = cur.fetchone()\\r\\n\\r\\n        if result:\\r\\n            hashed_password, is_moderator = result\\r\\n            # Verify the password hash\\r\\n            if check_password_hash(hashed_password, password):\\r\\n                return bool(is_moderator)\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error authenticating user: {e}\")\\r\\n    finally:\\r\\n        # Close the database connection\\r\\n        conn.close()\\r\\n\\r\\n    return False\\r\\n\\r\\n# Function to validate the session token\\r\\ndef validate_session(session):\\r\\n    # Implement your session validation logic here\\r\\n    # For example, you can check if the session token exists in your database\\r\\n    # and is not expired\\r\\n    return True\\r\\n\\r\\n# Route for the /check_mod endpoint\\r\\n@app.route('/check_mod', methods=['GET'])\\r\\ndef check_mod():\\r\\n    # Get the username, password, and session from the URL parameters\\r\\n    username = request.args.get('username')\\r\\n    password = request.args.get('password')\\r\\n    session = request.args.get('session')\\r\\n\\r\\n    if not username or not password or not session:\\r\\n        return jsonify({'error': 'Missing required parameters'}), 400\\r\\n\\r\\n    # Call the auth_mod function to authenticate the user as a moderator\\r\\n    is_moderator = auth_mod(username, password, session)\\r\\n\\r\\n    return jsonify({'is_moderator': is_moderator})\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Create a web app. Define a route for the app. Define a function that will be called when the route is called. Connect to the database. Execute a query. Return the result of the query.", "BP": ["Secure Database Connection", "Environment variable configuration", "Input validation", "Input Sanitization", "Error Handling and Logging"], "code": "import os\\r\\nfrom flask import Flask, jsonify, request\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.engine import URL\\r\\nimport logging\\r\\n\\r\\n# Setup Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Load configuration from environment variables\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize SQLAlchemy\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Define database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    name = db.Column(db.String(80), nullable=False)\\r\\n    email = db.Column(db.String(120), unique=True, nullable=False)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return f\"User('{self.name}', '{self.email}')\"\\r\\n\\r\\n# Define route and function\\r\\n@app.route('/users', methods=['GET'])\\r\\ndef get_users():\\r\\n    try:\\r\\n        # Input validation\\r\\n        page = request.args.get('page', 1, type=int)\\r\\n        per_page = request.args.get('per_page', 10, type=int)\\r\\n\\r\\n        # Input sanitization\\r\\n        page = max(page, 1)\\r\\n        per_page = max(per_page, 1)\\r\\n\\r\\n        # Query the database\\r\\n        users = User.query.paginate(page=page, per_page=per_page, error_out=False)\\r\\n\\r\\n        # Serialize the result\\r\\n        user_list = [{'id': user.id, 'name': user.name, 'email': user.email} for user in users.items]\\r\\n\\r\\n        return jsonify({'users': user_list, 'total': users.total, 'pages': users.pages})\\r\\n\\r\\n    except Exception as e:\\r\\n        # Error handling and logging\\r\\n        logging.error(f\"An error occurred: {e}\")\\r\\n        return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Create the database if it doesn't exist\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n\\r\\n    # Run the app\\r\\n    app.run( )", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database using the credentials stored in the environment variables. Execute a query to check if the user is a moderator. Return True if the user is a moderator False otherwise.", "BP": ["Environment Variables", "Error Handling", "Database Connection Management"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\n\\r\\n# Get database credentials from environment variables\\r\\nDB_HOST = os.environ.get('DB_HOST')\\r\\nDB_NAME = os.environ.get('DB_NAME')\\r\\nDB_USER = os.environ.get('DB_USER')\\r\\nDB_PASSWORD = os.environ.get('DB_PASSWORD')\\r\\n\\r\\ndef is_moderator(user_id):\\r\\n    try:\\r\\n        # Connect to the database\\r\\n        conn = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n        cur = conn.cursor()\\r\\n\\r\\n        # Prepare the SQL query using placeholders\\r\\n        query = sql.SQL(\"\"\"\\r\\n            SELECT is_moderator\\r\\n            FROM users\\r\\n            WHERE user_id = %s;\\r\\n        \"\"\")\\r\\n\\r\\n        # Execute the query with the user_id as a parameter\\r\\n        cur.execute(query, (user_id,))\\r\\n        result = cur.fetchone()\\r\\n\\r\\n        # Close the cursor and connection\\r\\n        cur.close()\\r\\n        conn.close()\\r\\n\\r\\n        # Return True if the user is a moderator, False otherwise\\r\\n        return result[0] if result else False\\r\\n\\r\\n    except (Exception, psycopg2.Error) as error:\\r\\n        print(\"Error while connecting to PostgreSQL\", error)\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\nuser_id = 123  # Replace with the actual user ID\\r\\nis_mod = is_moderator(user_id)\\r\\nprint(f\"User with ID {user_id} is a moderator: {is_mod}\")", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database. Execute a query to check if the username exists in the database. If the username exists it returns true otherwise it returns false.", "BP": ["Environment Variables", "Secure Database Connection", "Parameterized Queries", "Error Handling", "Closing Database Connection"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import Error\\r\\n\\r\\n# Load database credentials from environment variables\\r\\nDB_HOST = os.environ.get('DB_HOST')\\r\\nDB_NAME = os.environ.get('DB_NAME')\\r\\nDB_USER = os.environ.get('DB_USER')\\r\\nDB_PASSWORD = os.environ.get('DB_PASSWORD')\\r\\n\\r\\ndef check_username_exists(username):\\r\\n    \"\"\"\\r\\n    Check if a username exists in the database.\\r\\n\\r\\n    Args:\\r\\n        username (str): The username to check.\\r\\n\\r\\n    Returns:\\r\\n        bool: True if the username exists, False otherwise.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Connect to the database\\r\\n        connection = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n\\r\\n        # Create a cursor\\r\\n        cursor = connection.cursor()\\r\\n\\r\\n        # Execute a parameterized query to check if the username exists\\r\\n        query = \"SELECT 1 FROM users WHERE username = %s\"\\r\\n        cursor.execute(query, (username,))\\r\\n\\r\\n        # Check if the query returned any rows\\r\\n        if cursor.fetchone():\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n\\r\\n    except (Exception, Error) as error:\\r\\n        # Handle any database errors\\r\\n        print(f\"Error while checking username exists: {error}\")\\r\\n        return False\\r\\n\\r\\n    finally:\\r\\n        # Close the database connection\\r\\n        if connection:\\r\\n            cursor.close()\\r\\n            connection.close()\\r\\n\\r\\n# Example usage\\r\\nusername = \"johndoe\"\\r\\nif check_username_exists(username):\\r\\n    print(f\"Username '{username}' exists in the database.\")\\r\\nelse:\\r\\n    print(f\"Username '{username}' does not exist in the database.\")", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Import the necessary modules. Create a web app. Define a function that returns a database connection. Define a function that returns the server name. Define a function that returns the database name. Define a function that returns the database user. Define a function that returns the database password.", "BP": ["Secure Configuration", "Error Handling", "Password Hashing", "SQL Injection Prevention"], "code": "import os\\r\\nfrom flask import Flask, request\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport sqlite3\\r\\n\\r\\n# Create a web app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure the database\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///database.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define a model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Create the database tables\\r\\nwith app.app_context():\\r\\n    db.create_all()\\r\\n\\r\\n# Define a function that returns a database connection\\r\\ndef get_db_connection():\\r\\n    conn = sqlite3.connect('database.db')\\r\\n    conn.row_factory = sqlite3.Row\\r\\n    return conn\\r\\n\\r\\n# Define a function that returns the server name\\r\\ndef get_server_name():\\r\\n    return os.environ.get('SERVER_NAME', 'localhost')\\r\\n\\r\\n# Define a function that returns the database name\\r\\ndef get_database_name():\\r\\n    return 'database.db'\\r\\n\\r\\n# Define a function that returns the database user\\r\\ndef get_database_user():\\r\\n    return 'admin'\\r\\n\\r\\n# Define a function that returns the database password\\r\\ndef get_database_password():\\r\\n    return os.environ.get('DATABASE_PASSWORD', 'secure_password')\\r\\n\\r\\n# Define a route for user registration\\r\\n@app.route('/register', methods=['POST'])\\r\\ndef register():\\r\\n    try:\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        existing_user = User.query.filter_by(username=username).first()\\r\\n\\r\\n        if existing_user:\\r\\n            return 'Username already exists', 400\\r\\n\\r\\n        user = User(username=username)\\r\\n        user.set_password(password)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n\\r\\n        return 'User registered successfully', 200\\r\\n    except Exception as e:\\r\\n        db.session.rollback()\\r\\n        app.logger.error(f'Error registering user: {e}')\\r\\n        return 'Error registering user', 500\\r\\n\\r\\n# Define a route for user login\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    try:\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n\\r\\n        if user and user.check_password(password):\\r\\n            return 'Login successful', 200\\r\\n        else:\\r\\n            return 'Invalid username or password', 401\\r\\n    except Exception as e:\\r\\n        app.logger.error(f'Error logging in: {e}')\\r\\n        return 'Error logging in', 500\\r\\n\\r\\n# Secure Configuration\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'change_this_to_a_secure_secret_key')\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\n\\r\\n# Error Handling\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'Page not found', 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    app.logger.error(f'Internal Server Error: {e}')\\r\\n    return 'Internal Server Error', 500\\r\\n\\r\\n# SQL Injection Prevention\\r\\ndef escape_string(value):\\r\\n    return value.replace(\"'\", \"''\")\\r\\n\\r\\n# Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: A function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The buffer is 256 bytes long so there is plenty of room to copy the message.", "BP": ["Input Validation", "Secure Memory Copying", "Limiting Buffer Size", "Memory Management"], "code": "import ctypes\\r\\n\\r\\n# Define the maximum buffer size\\r\\nMAX_BUFFER_SIZE = 256\\r\\n\\r\\n# Define a function to securely copy bytes from one memory location to another\\r\\ndef secure_memcpy(dest, src, nbytes):\\r\\n    \"\"\"\\r\\n    Securely copies a number of bytes from one memory location to another.\\r\\n    \\r\\n    Args:\\r\\n        dest (ctypes.c_void_p): A pointer to the destination memory location.\\r\\n        src (ctypes.c_void_p): A pointer to the source memory location.\\r\\n        nbytes (int): The number of bytes to copy.\\r\\n        \\r\\n    Returns:\\r\\n        bool: True if the copy was successful, False otherwise.\\r\\n    \"\"\"\\r\\n    # Validate input\\r\\n    if not isinstance(dest, ctypes.c_void_p) or not isinstance(src, ctypes.c_void_p) or not isinstance(nbytes, int) or nbytes < 0 or nbytes > MAX_BUFFER_SIZE:\\r\\n        return False\\r\\n    \\r\\n    # Use ctypes to perform secure memory copying\\r\\n    ctypes.memmove(dest, src, nbytes)\\r\\n    \\r\\n    return True\\r\\n\\r\\n# Example usage\\r\\nsrc_buffer = ctypes.create_string_buffer(b'Hello, World!')\\r\\ndest_buffer = ctypes.create_string_buffer(MAX_BUFFER_SIZE)\\r\\n\\r\\nif secure_memcpy(dest_buffer, src_buffer, len(src_buffer.value)):\\r\\n    print(f\"Copied bytes: {dest_buffer.value.decode()}\")\\r\\nelse:\\r\\n    print(\"Error copying bytes.\")", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The strlen function returns the length of a string.The code copies the message to the buffer.", "BP": ["Input Validation", "Boundary Checking", "Destination Buffer Size Checking", "Secure copying", "Error handling", "Separation of Concerns"], "code": "import sys\\r\\n\\r\\n# Define a constant for the maximum buffer size\\r\\nMAX_BUFFER_SIZE = 1024\\r\\n\\r\\ndef secure_strlen(string):\\r\\n    \"\"\"\\r\\n    Safely calculates the length of a string.\\r\\n    \"\"\"\\r\\n    if not isinstance(string, str):\\r\\n        raise TypeError(\"Input must be a string\")\\r\\n    \\r\\n    # Use len() to get the string length\\r\\n    length = len(string)\\r\\n    \\r\\n    return length\\r\\n\\r\\ndef secure_memcpy(dest, src, num_bytes):\\r\\n    \"\"\"\\r\\n    Securely copies bytes from one buffer to another.\\r\\n    \"\"\"\\r\\n    # Check if the input is bytes-like objects\\r\\n    if not isinstance(dest, (bytes, bytearray)) or not isinstance(src, (bytes, bytearray)):\\r\\n        raise TypeError(\"Input buffers must be bytes-like objects\")\\r\\n    \\r\\n    # Validate the number of bytes to copy\\r\\n    if not isinstance(num_bytes, int) or num_bytes < 0:\\r\\n        raise ValueError(\"Number of bytes must be a non-negative integer\")\\r\\n    \\r\\n    # Check if the destination buffer has enough space\\r\\n    dest_len = len(dest)\\r\\n    if dest_len < num_bytes:\\r\\n        raise BufferError(\"Destination buffer is too small\")\\r\\n    \\r\\n    # Copy the bytes from source to destination\\r\\n    for i in range(num_bytes):\\r\\n        try:\\r\\n            dest[i] = src[i]\\r\\n        except IndexError:\\r\\n            # Handle the case where the source buffer is smaller than the specified number of bytes\\r\\n            break\\r\\n    \\r\\n    return dest\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Get the message from the user\\r\\n        message = input(\"Enter a message: \").encode()\\r\\n        \\r\\n        # Validate the message length\\r\\n        message_len = secure_strlen(message)\\r\\n        if message_len > MAX_BUFFER_SIZE:\\r\\n            print(\"Message is too long. Maximum length is\", MAX_BUFFER_SIZE)\\r\\n            return\\r\\n        \\r\\n        # Create a destination buffer\\r\\n        dest_buffer = bytearray(MAX_BUFFER_SIZE)\\r\\n        \\r\\n        # Copy the message to the destination buffer\\r\\n        secure_memcpy(dest_buffer, message, message_len)\\r\\n        \\r\\n        # Print the copied message\\r\\n        print(\"Copied message:\", dest_buffer[:message_len].decode())\\r\\n        \\r\\n    except (TypeError, ValueError, BufferError) as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error: {e}\", file=sys.stderr)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second is the source and the third is the number of bytes to copy.The strlen function returns the length of a string.The code copies the string \"Hello\" to the buffer.", "BP": ["Input Validation", "Clearing Destination Buffer", "Secure String Length Calculation"], "code": "import ctypes\\r\\n\\r\\ndef memcpy(dest, src, n):\\r\\n    \"\"\"\\r\\n    Secure implementation of the memcpy function.\\r\\n    Copies n bytes from src to dest.\\r\\n\\r\\n    Args:\\r\\n        dest (memoryview): The destination buffer.\\r\\n        src (bytes): The source bytes to copy.\\r\\n        n (int): The number of bytes to copy.\\r\\n\\r\\n    Returns:\\r\\n        memoryview: The destination buffer with the copied bytes.\\r\\n    \"\"\"\\r\\n    # Validate inputs\\r\\n    if not isinstance(dest, memoryview):\\r\\n        raise ValueError(\"dest must be a memoryview object\")\\r\\n    if not isinstance(src, bytes):\\r\\n        raise ValueError(\"src must be a bytes object\")\\r\\n    if n < 0:\\r\\n        raise ValueError(\"n cannot be negative\")\\r\\n    if n > len(dest):\\r\\n        raise ValueError(\"n is larger than the destination buffer size\")\\r\\n\\r\\n    # Clear the destination buffer\\r\\n    ctypes.memset(dest.cbytes, 0, dest.nbytes)\\r\\n\\r\\n    # Copy the bytes\\r\\n    dest[:n] = src[:n]\\r\\n\\r\\n    return dest\\r\\n\\r\\ndef strlen(string):\\r\\n    \"\"\"\\r\\n    Secure implementation of the strlen function.\\r\\n    Returns the length of the given string.\\r\\n\\r\\n    Args:\\r\\n        string (bytes or str): The input string.\\r\\n\\r\\n    Returns:\\r\\n        int: The length of the string.\\r\\n    \"\"\"\\r\\n    # Validate input\\r\\n    if not isinstance(string, (bytes, str)):\\r\\n        raise ValueError(\"Input must be a bytes or str object\")\\r\\n\\r\\n    # Convert to bytes if necessary\\r\\n    if isinstance(string, str):\\r\\n        string = string.encode()\\r\\n\\r\\n    # Calculate the length\\r\\n    length = 0\\r\\n    for byte in string:\\r\\n        if byte == 0:\\r\\n            break\\r\\n        length += 1\\r\\n\\r\\n    return length\\r\\n\\r\\n# Example usage\\r\\nbuffer = memoryview(bytearray(10))\\r\\nsource_string = b\"Hello\"\\r\\nmemcpy(buffer, source_string, strlen(source_string))\\r\\nprint(buffer.tobytes())  # Output: b'Hello\\x00\\x00\\x00\\x00\\x00'", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The user is prompted to enter an index of a vehicle.The user enters an index.The index is converted to an integer.The integer is used to access the array of vehicles.The vehicle at the index is printed.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns"], "code": "# Define the list of vehicles\\r\\nVEHICLES = ['Car', 'Truck', 'Motorcycle', 'Bicycle']\\r\\n\\r\\ndef get_valid_index() -> int:\\r\\n    \"\"\"\\r\\n    Prompts the user to enter a valid index for the vehicles list and returns the valid index.\\r\\n    \"\"\"\\r\\n    while True:\\r\\n        try:\\r\\n            index = int(input(\"Enter the index of a vehicle (0-{}): \".format(len(VEHICLES) - 1)))\\r\\n            if index < 0 or index >= len(VEHICLES):\\r\\n                raise ValueError(\"Index out of range\")\\r\\n            return index\\r\\n        except ValueError as e:\\r\\n            print(\"Invalid input:\", e)\\r\\n\\r\\ndef get_vehicle_by_index(index: int) -> str:\\r\\n    \"\"\"\\r\\n    Returns the vehicle at the given index from the vehicles list.\\r\\n    \"\"\"\\r\\n    return VEHICLES[index]\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to get the index from the user, retrieve the vehicle, and print it.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        index = get_valid_index()\\r\\n        vehicle = get_vehicle_by_index(index)\\r\\n        print(\"Vehicle at index {}: {}\".format(index, vehicle))\\r\\n    except IndexError:\\r\\n        print(\"Index out of range\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes in a command line argument and converts it to an integer.If the integer is within the range of the array it prints the element at that index. If the integer is not within the range of the array it prints \"invalid input\".", "BP": ["Input Validation", "Error Handling", "Limiting Access", "Memory Cleanup"], "code": "import sys\\r\\nimport os\\r\\n\\r\\n# Define a function to validate and sanitize user input\\r\\ndef validate_input(user_input):\\r\\n    try:\\r\\n        # Convert the input to an integer\\r\\n        user_input_int = int(user_input)\\r\\n        \\r\\n        # Check if the input is within the valid range\\r\\n        if 0 <= user_input_int < len(arr):\\r\\n            return user_input_int\\r\\n        else:\\r\\n            print(\"Invalid input: Index out of range\")\\r\\n            return None\\r\\n    except ValueError:\\r\\n        print(\"Invalid input: Non-numeric input\")\\r\\n        return None\\r\\n\\r\\n# Define the array\\r\\narr = [1, 2, 3, 4, 5]\\r\\n\\r\\n# Check if the command line argument is provided\\r\\nif len(sys.argv) != 2:\\r\\n    print(\"Usage: python script.py <index>\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Get the command line argument and validate it\\r\\nuser_input = sys.argv[1]\\r\\nvalidated_input = validate_input(user_input)\\r\\n\\r\\n# Process the validated input\\r\\nif validated_input is not None:\\r\\n    print(f\"Element at index {validated_input}: {arr[validated_input]}\")\\r\\nelse:\\r\\n    print(\"Invalid input\")\\r\\n\\r\\n# Clear sensitive data from memory\\r\\nos.system('sync && sudo sh -c \"sync; echo 3 > /proc/sys/vm/drop_caches\"')", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code creates an array of strings called vehicles. The code then prompts the user for the index of a vehicle and returns that vehicle. The code then loops through the array and prints out each vehicle.", "BP": ["Input Validation", "Exception Handling", "Safe Exit", "Secure Data Storage", "Secure Output"], "code": "import os\\r\\nimport hashlib\\r\\nfrom cryptography.fernet import Fernet\\r\\n\\r\\n# Secure data storage\\r\\ndef encrypt_data(data):\\r\\n    key = os.environ.get('ENCRYPTION_KEY', Fernet.generate_key())\\r\\n    cipher_suite = Fernet(key)\\r\\n    encrypted_data = cipher_suite.encrypt(data.encode())\\r\\n    return encrypted_data\\r\\n\\r\\ndef decrypt_data(encrypted_data):\\r\\n    key = os.environ.get('ENCRYPTION_KEY')\\r\\n    cipher_suite = Fernet(key)\\r\\n    decrypted_data = cipher_suite.decrypt(encrypted_data).decode()\\r\\n    return decrypted_data\\r\\n\\r\\n# Secure output\\r\\ndef secure_print(output):\\r\\n    import re\\r\\n    sanitized_output = re.sub(r'[<>]', '', output)\\r\\n    print(sanitized_output)\\r\\n\\r\\n# Input validation\\r\\ndef validate_index(index, length):\\r\\n    try:\\r\\n        index = int(index)\\r\\n        if index >= 0 and index < length:\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\n# Safe exit\\r\\ndef safe_exit():\\r\\n    try:\\r\\n        exit(0)\\r\\n    except SystemExit:\\r\\n        pass\\r\\n\\r\\n# Main program\\r\\nvehicles = ['Car', 'Bike', 'Truck', 'Bus', 'Train']\\r\\nencrypted_vehicles = [encrypt_data(vehicle) for vehicle in vehicles]\\r\\n\\r\\nwhile True:\\r\\n    try:\\r\\n        index = input(\"Enter the index of a vehicle (or 'q' to quit): \")\\r\\n        if index.lower() == 'q':\\r\\n            safe_exit()\\r\\n            break\\r\\n\\r\\n        if validate_index(index, len(encrypted_vehicles)):\\r\\n            vehicle = decrypt_data(encrypted_vehicles[int(index)])\\r\\n            secure_print(f\"The vehicle at index {index} is: {vehicle}\")\\r\\n        else:\\r\\n            secure_print(\"Invalid index. Please try again.\")\\r\\n\\r\\n        secure_print(\"All vehicles:\")\\r\\n        for encrypted_vehicle in encrypted_vehicles:\\r\\n            vehicle = decrypt_data(encrypted_vehicle)\\r\\n            secure_print(vehicle)\\r\\n\\r\\n    except Exception as e:\\r\\n        secure_print(f\"An error occurred: {e}\")", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() is a function that converts a string to an integer. Command line arguments at index 1 is the second argument passed to the program. Command line argument at index INDEX is the argument at the INDEX specified by the second argument. print function prints the string at INDEX position in the command line arguments to the screen. return 0. exit the program.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Separation of Concerns"], "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef is_valid_integer(value):\\r\\n    try:\\r\\n        int(value)\\r\\n        return True\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\ndef sanitize_input(value):\\r\\n    # Remove leading/trailing whitespace\\r\\n    value = value.strip()\\r\\n    \\r\\n    # Remove non-numeric characters\\r\\n    sanitized_value = re.sub(r'[^0-9]', '', value)\\r\\n    \\r\\n    return sanitized_value\\r\\n\\r\\ndef atoi(string):\\r\\n    if not string:\\r\\n        return 0\\r\\n    \\r\\n    sanitized_string = sanitize_input(string)\\r\\n    \\r\\n    if not sanitized_string:\\r\\n        return 0\\r\\n    \\r\\n    if not is_valid_integer(sanitized_string):\\r\\n        return 0\\r\\n    \\r\\n    return int(sanitized_string)\\r\\n\\r\\ndef print_argument(args, index):\\r\\n    if index < 1 or index >= len(args):\\r\\n        print(\"Invalid index\")\\r\\n        return\\r\\n    \\r\\n    print(args[index])\\r\\n\\r\\ndef main():\\r\\n    if len(sys.argv) < 3:\\r\\n        print(\"Usage: python script.py <index> [arguments...]\")\\r\\n        return 1\\r\\n    \\r\\n    index_str = sys.argv[1]\\r\\n    sanitized_index = sanitize_input(index_str)\\r\\n    \\r\\n    if not is_valid_integer(sanitized_index):\\r\\n        print(\"Invalid index\")\\r\\n        return 1\\r\\n    \\r\\n    index = int(sanitized_index)\\r\\n    \\r\\n    print_argument(sys.argv[2:], index)\\r\\n    \\r\\n    return 0\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    sys.exit(main())", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() converts a string to an integer. argc is the number of arguments passed to the program. Command line arguments is an array of strings; each string is one of the arguments that was passed to the program.The first argument is always the name of the program so if the user ran ./a.out foo bar baz; argc would be 4; argv[0] would be ./a.out argv.", "BP": ["Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef atoi(string):\\r\\n    \"\"\"\\r\\n    Converts a string to an integer.\\r\\n    Performs input validation and sanitization to prevent potential vulnerabilities.\\r\\n    \"\"\"\\r\\n    # Remove leading and trailing whitespaces\\r\\n    string = string.strip()\\r\\n\\r\\n    # Validate the input string\\r\\n    if not string:\\r\\n        raise ValueError(\"Input string cannot be empty.\")\\r\\n    elif not re.match(r'^[-+]?\\d+$', string):\\r\\n        raise ValueError(\"Input string must be a valid integer.\")\\r\\n\\r\\n    # Convert the string to an integer\\r\\n    try:\\r\\n        return int(string)\\r\\n    except ValueError:\\r\\n        raise ValueError(\"Unable to convert input string to integer.\")\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to handle command line arguments and call the atoi() function.\\r\\n    \"\"\"\\r\\n    argc = len(sys.argv)\\r\\n    argv = sys.argv\\r\\n\\r\\n    # Check if the program was executed with at least one argument\\r\\n    if argc < 2:\\r\\n        print(\"Usage: python program.py <integer_string>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Iterate over the command line arguments (except the program name)\\r\\n    for arg in argv[1:]:\\r\\n        try:\\r\\n            result = atoi(arg)\\r\\n            print(f\"Converted '{arg}' to integer: {result}\")\\r\\n        except ValueError as e:\\r\\n            print(f\"Error: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes an index as an argument and prints the corresponding argument from the command line arguments. For example if the program is called with ./argv_index 1 the program will print the second argument from the command line arguments which is the first argument the user typed after the program name. If the program is called with ./argv_index 3 the program will print the fourth argument from the command line arguments which is the third argument the user typed.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling"], "code": "import sys\\r\\nimport os\\r\\n\\r\\ndef get_command_line_argument(index):\\r\\n    \"\"\"\\r\\n    Retrieves the command line argument at the specified index.\\r\\n    \\r\\n    Args:\\r\\n        index (int): The index of the command line argument to retrieve.\\r\\n        \\r\\n    Returns:\\r\\n        str: The command line argument at the specified index.\\r\\n        \\r\\n    Raises:\\r\\n        IndexError: If the index is out of range.\\r\\n        ValueError: If the index is not a valid integer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        index = int(index)\\r\\n    except ValueError:\\r\\n        raise ValueError(\"Index must be an integer.\") from None\\r\\n    \\r\\n    try:\\r\\n        return sys.argv[index]\\r\\n    except IndexError:\\r\\n        raise IndexError(\"Index out of range.\") from None\\r\\n\\r\\ndef print_argument(index):\\r\\n    \"\"\"\\r\\n    Prints the command line argument at the specified index.\\r\\n    \\r\\n    Args:\\r\\n        index (int): The index of the command line argument to print.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        argument = get_command_line_argument(index)\\r\\n        print(argument)\\r\\n    except (IndexError, ValueError) as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) < 2:\\r\\n        print(\"Usage: python script.py <index>\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n    \\r\\n    index = sys.argv[1]\\r\\n    print_argument(index)", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is out of bounds it returns -1. Otherwise it returns the value at the given index.The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer. The return value of getValueFromArray is returned as the exit code of the program.", "BP": ["Input Validation", "Array Bounds Checking", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef get_value_from_array(arr, size, index):\\r\\n    \"\"\"\\r\\n    Get the value from the array at the given index.\\r\\n    If the index is out of bounds, return -1.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Validate input\\r\\n        if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\\r\\n            raise ValueError(\"Input array must be a list of integers\")\\r\\n        if not isinstance(size, int) or size < 0:\\r\\n            raise ValueError(\"Size must be a non-negative integer\")\\r\\n        if not isinstance(index, int):\\r\\n            raise ValueError(\"Index must be an integer\")\\r\\n\\r\\n        # Bounds checking\\r\\n        if index < 0 or index >= size:\\r\\n            return -1\\r\\n\\r\\n        return arr[index]\\r\\n    except (ValueError, IndexError) as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        id_sequence = [1, 2, 3, 4, 5]\\r\\n        size = len(id_sequence)\\r\\n\\r\\n        # Input validation\\r\\n        user_input = input(\"Enter an index: \").strip()\\r\\n        if not user_input.isdigit():\\r\\n            print(\"Error: Input must be an integer\", file=sys.stderr)\\r\\n            sys.exit(1)\\r\\n\\r\\n        index = int(user_input)\\r\\n        value = get_value_from_array(id_sequence, size, index)\\r\\n        sys.exit(value)\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers; its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array; its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(user_input, id_sequence):\\r\\n    try:\\r\\n        index = int(user_input)\\r\\n    except ValueError:\\r\\n        print(\"Error: Invalid input. Please enter an integer.\")\\r\\n        return None\\r\\n\\r\\n    if index < 0 or index >= len(id_sequence):\\r\\n        print(\"Error: Index out of bounds.\")\\r\\n        return None\\r\\n\\r\\n    return index\\r\\n\\r\\n# Separation of Concerns\\r\\ndef get_value_from_array(id_sequence, index):\\r\\n    if index is not None:\\r\\n        return id_sequence[index]\\r\\n    else:\\r\\n        return -1\\r\\n\\r\\n# Error Handling and Secure Execution\\r\\ndef main():\\r\\n    id_sequence = [1, 2, 3, 4, 5]  # Example array\\r\\n\\r\\n    try:\\r\\n        user_input = input(\"Enter an index: \")\\r\\n        index = validate_input(user_input, id_sequence)\\r\\n        value = get_value_from_array(id_sequence, index)\\r\\n        print(f\"Value at index {index}: {value}\")\\r\\n        sys.exit(value)\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Exception Handling", "Exception Handling", "Least Privilege Principle"], "code": "import sys\\r\\n\\r\\ndef get_value_from_array(arr, size, index):\\r\\n    \"\"\"\\r\\n    Returns the value at the given index if it's within the array bounds,\\r\\n    otherwise returns -1.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Input validation: Check if index is an integer\\r\\n        index = int(index)\\r\\n        \\r\\n        # Check if index is within array bounds\\r\\n        if 0 <= index < size:\\r\\n            return arr[index]\\r\\n        else:\\r\\n            return -1\\r\\n    except ValueError:\\r\\n        # Handle invalid input (non-integer index)\\r\\n        print(\"Error: Invalid index. Please enter an integer.\")\\r\\n        return -1\\r\\n    except IndexError:\\r\\n        # Handle out-of-bounds index\\r\\n        print(\"Error: Index out of bounds.\")\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    # Define the array with least privilege (read-only)\\r\\n    id_sequence = [10, 20, 30, 40, 50]\\r\\n    size = len(id_sequence)\\r\\n\\r\\n    try:\\r\\n        # Read user input and validate\\r\\n        user_input = input(\"Enter an index: \")\\r\\n        if not user_input:\\r\\n            print(\"Error: No input provided.\")\\r\\n            sys.exit(1)\\r\\n\\r\\n        # Call the function and get the return value\\r\\n        result = get_value_from_array(id_sequence, size, user_input)\\r\\n\\r\\n        # Return the result as the exit code\\r\\n        sys.exit(result)\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected exceptions\\r\\n        print(f\"Error: {str(e)}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. If the index value is out of bounds the function returns -1. The function is called in the main function. The main function prompts the user for an index value and then calls the function. The function returns the value at the index in the array id_sequence. If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Separation of Concerns", "Secure Execution"], "code": "import sys\\r\\n\\r\\n# Define the id_sequence array\\r\\nid_sequence = [1, 2, 3, 4, 5]\\r\\n\\r\\ndef get_value_from_sequence(index):\\r\\n    \"\"\"\\r\\n    Returns the value at the given index in the id_sequence array.\\r\\n    If the index is out of bounds, returns -1.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Validate the index value\\r\\n        if not isinstance(index, int):\\r\\n            print(\"Error: Invalid index type. Index must be an integer.\")\\r\\n            return -1\\r\\n\\r\\n        # Check if the index is within the valid range\\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Error: Index out of bounds.\")\\r\\n            return -1\\r\\n\\r\\n        # Return the value at the given index\\r\\n        return id_sequence[index]\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle any unexpected exceptions\\r\\n        print(f\"Error: {str(e)}\")\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Prompt the user for an index value\\r\\n        user_input = input(\"Enter an index value: \")\\r\\n\\r\\n        # Validate and convert the user input to an integer\\r\\n        try:\\r\\n            index = int(user_input)\\r\\n        except ValueError:\\r\\n            print(\"Error: Invalid input. Please enter an integer.\")\\r\\n            sys.exit(1)\\r\\n\\r\\n        # Call the get_value_from_sequence function with the validated index\\r\\n        value = get_value_from_sequence(index)\\r\\n\\r\\n        # Print the result\\r\\n        if value == -1:\\r\\n            print(\"Index out of bounds or invalid input.\")\\r\\n        else:\\r\\n            print(f\"Value at index {index}: {value}\")\\r\\n\\r\\n    except KeyboardInterrupt:\\r\\n        # Handle keyboard interrupts (Ctrl+C)\\r\\n        print(\"\\nProgram interrupted by the user.\")\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle any unexpected exceptions\\r\\n        print(f\"Error: {str(e)}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. The function first prompts the user for an index value.Then the function checks if the index value is in bounds. If it is not the function returns -1. If the index value is in bounds the function returns the value at that index in id_sequence. The function returns 0 if the program runs.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef get_value_from_sequence(id_sequence):\\r\\n    try:\\r\\n        index = int(input(\"Enter an index value: \"))\\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Index must be an integer.\")\\r\\n        return 0\\r\\n\\r\\n    try:\\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Index out of bounds.\")\\r\\n            return -1\\r\\n        else:\\r\\n            return id_sequence[index]\\r\\n    except IndexError:\\r\\n        print(\"Index out of bounds.\")\\r\\n        return -1\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return 0\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    id_sequence = [1, 2, 3, 4, 5]  # Example sequence\\r\\n    value = get_value_from_sequence(id_sequence)\\r\\n    print(f\"Value at the given index: {value}\")\\r\\n    sys.exit(0)", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence.The function first prompts the user for an index value.Then the function checks if the index value is in bounds.If it is the function returns the value at the index in id_sequence.If the index value is not in bounds the function returns 0.", "BP": ["Input Validation", "Exception Handling", "Least Privilege Principle", "Bounds Checking"], "code": "import sys\\r\\n\\r\\n# Define the id_sequence array\\r\\nid_sequence = [1, 2, 3, 4, 5]\\r\\n\\r\\ndef get_id_from_sequence(user_input):\\r\\n    \"\"\"\\r\\n    Function to get the value from the id_sequence array based on user input index.\\r\\n    Performs input validation and exception handling.\\r\\n\\r\\n    Args:\\r\\n        user_input (str): User input for the index value.\\r\\n\\r\\n    Returns:\\r\\n        int: Value at the specified index in the id_sequence array, or 0 if the index is out of bounds.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Convert user input to integer\\r\\n        index = int(user_input)\\r\\n    except ValueError:\\r\\n        print(\"Error: Invalid input. Please enter an integer.\")\\r\\n        return 0\\r\\n\\r\\n    # Check if index is within the valid range\\r\\n    if index < 0 or index >= len(id_sequence):\\r\\n        print(\"Error: Index out of bounds.\")\\r\\n        return 0\\r\\n\\r\\n    return id_sequence[index]\\r\\n\\r\\ndef main():\\r\\n    # Prompt user for input with least privilege principle\\r\\n    user_input = input(\"Enter an index value: \").strip()\\r\\n\\r\\n    # Call the function and print the result\\r\\n    result = get_id_from_sequence(user_input)\\r\\n    print(f\"Value at index {user_input}: {result}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    try:\\r\\n        main()\\r\\n    except KeyboardInterrupt:\\r\\n        print(\"\\nProgram terminated by user.\")\\r\\n        sys.exit(0)", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is -1 the code will return -1.If the input is 10 the code will return -1.If the input is 0 the code will return the value at index 0 of the array.", "BP": ["Input Validation", "Secure String Operations", "Exception Handling"], "code": "import re\\r\\n\\r\\ndef get_value_at_index(user_input):\\r\\n    # Define the array\\r\\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\r\\n\\r\\n    # Input validation\\r\\n    try:\\r\\n        index = int(user_input)\\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Please enter an integer.\")\\r\\n        return -1\\r\\n\\r\\n    # Bounds checking\\r\\n    if index < -1 or index >= len(arr):\\r\\n        print(\"Index out of range.\")\\r\\n        return -1\\r\\n\\r\\n    # Handle special cases\\r\\n    if index == -1:\\r\\n        return -1\\r\\n\\r\\n    # Secure string operations\\r\\n    try:\\r\\n        value = arr[index]\\r\\n    except IndexError:\\r\\n        print(\"Index out of range.\")\\r\\n        return -1\\r\\n\\r\\n    return value\\r\\n\\r\\n# Get user input\\r\\nuser_input = input(\"Enter an integer: \")\\r\\n\\r\\n# Validate input using a regular expression\\r\\npattern = r'^-?\\d+$'\\r\\nif not re.match(pattern, user_input):\\r\\n    print(\"Invalid input. Please enter an integer.\")\\r\\nelse:\\r\\n    result = get_value_at_index(user_input)\\r\\n    print(f\"Value at index {user_input}: {result}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes in a number from the user and returns the value at that index in the array.If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Array Index Bounds Checking", "Error Handling", "Sanitizing User Input"], "code": "import re\\r\\n\\r\\ndef get_value_from_array(arr):\\r\\n    while True:\\r\\n        try:\\r\\n            index = int(input(\"Enter an index: \"))\\r\\n            # Input validation and sanitization\\r\\n            if not re.match(r'^-?\\d+$', str(index)):\\r\\n                raise ValueError(\"Invalid input. Please enter an integer.\")\\r\\n            # Array index bounds checking\\r\\n            if index < 0 or index >= len(arr):\\r\\n                return -1\\r\\n            return arr[index]\\r\\n        except ValueError as e:\\r\\n            print(e)\\r\\n        except Exception as e:\\r\\n            print(f\"An error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nmy_array = [10, 20, 30, 40, 50]\\r\\nvalue = get_value_from_array(my_array)\\r\\nif value == -1:\\r\\n    print(\"Index out of bounds\")\\r\\nelse:\\r\\n    print(f\"Value at the given index: {value}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is out of bounds the code will return -1.For example if the input is 10 the code will return -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Modularity"], "code": "import logging\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Define a function to validate user input\\r\\ndef validate_input(user_input):\\r\\n    try:\\r\\n        val = int(user_input)\\r\\n        if val < 0:\\r\\n            logging.error(f\"Invalid input: {user_input} (negative value)\")\\r\\n            return None\\r\\n        return val\\r\\n    except ValueError:\\r\\n        logging.error(f\"Invalid input: {user_input} (non-numeric value)\")\\r\\n        return None\\r\\n\\r\\n# Define a function to get the value from the array\\r\\ndef get_value_from_array(arr, index):\\r\\n    try:\\r\\n        value = arr[index]\\r\\n        logging.info(f\"Value at index {index}: {value}\")\\r\\n        return value\\r\\n    except IndexError:\\r\\n        logging.warning(f\"Index {index} is out of bounds for the array\")\\r\\n        return -1\\r\\n\\r\\n# Define the main function\\r\\ndef main():\\r\\n    # Define the array\\r\\n    my_array = [10, 20, 30, 40, 50]\\r\\n\\r\\n    # Get user input\\r\\n    user_input = input(\"Enter an integer: \")\\r\\n\\r\\n    # Validate user input\\r\\n    validated_input = validate_input(user_input)\\r\\n\\r\\n    if validated_input is not None:\\r\\n        # Get the value from the array\\r\\n        value = get_value_from_array(my_array, validated_input)\\r\\n    else:\\r\\n        value = -1\\r\\n\\r\\n    print(f\"Result: {value}\")\\r\\n\\r\\n# Call the main function\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The regular expression is compiled once when the module is loaded.The regular expression is used to match the target URL. If the target URL matches, it is used as the redirect target.If the target URL does not match a default URL is used. The regular expression is not used to construct the redirect URL.", "BP": ["Regular Expression Compilation", "Trusted Domains", "URL Sanitization", "Redirect Handling", "Default Redirect URL", "Secure Libraries"], "code": "import re\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\nfrom functools import lru_cache\\r\\n\\r\\n# Trusted domains\\r\\nTRUSTED_DOMAINS = ['example.com', 'subdomain.example.com']\\r\\n\\r\\n# Default redirect URL\\r\\nDEFAULT_REDIRECT_URL = 'https://example.com/default'\\r\\n\\r\\n# Compile the regular expression once when the module is loaded\\r\\n@lru_cache(maxsize=1)\\r\\ndef get_regex():\\r\\n    # Use a secure regular expression library like 'regex'\\r\\n    import regex\\r\\n    trusted_domains_pattern = r'|'.join(fr'://([\\w\\.-]+\\.{re.escape(domain)})/?'\\r\\n                                        for domain in TRUSTED_DOMAINS)\\r\\n    regex_pattern = fr'^(https?){trusted_domains_pattern}(\\?.*)?$'\\r\\n    return regex.compile(regex_pattern)\\r\\n\\r\\ndef is_trusted_url(url):\\r\\n    \"\"\"\\r\\n    Checks if the given URL belongs to a trusted domain.\\r\\n    \"\"\"\\r\\n    parsed_url = urlparse(url)\\r\\n    return parsed_url.netloc in (f'{domain}' for domain in TRUSTED_DOMAINS)\\r\\n\\r\\ndef secure_redirect(request):\\r\\n    \"\"\"\\r\\n    Handles secure redirection based on the target URL.\\r\\n    \"\"\"\\r\\n    target_url = request.GET.get('target')\\r\\n\\r\\n    # Sanitize the target URL\\r\\n    if not target_url:\\r\\n        return redirect(DEFAULT_REDIRECT_URL)\\r\\n\\r\\n    # Check if the target URL belongs to a trusted domain\\r\\n    if not is_trusted_url(target_url):\\r\\n        return redirect(DEFAULT_REDIRECT_URL)\\r\\n\\r\\n    # Match the target URL against the compiled regular expression\\r\\n    regex = get_regex()\\r\\n    if regex.match(target_url):\\r\\n        # Sanitize the target URL using urljoin\\r\\n        safe_url = urljoin('https://', target_url.lstrip('https://'))\\r\\n        return redirect(safe_url)\\r\\n\\r\\n    # If the target URL does not match, use the default URL\\r\\n    return redirect(DEFAULT_REDIRECT_URL)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple Web application that has a single route.The route takes a target parameter and redirects to it. Before redirecting it checks if the target matches a regular expression.If the target matches the regular expression it redirects to it. If the target does not match the regular expression it redirects to /.The regular expression is a simple regular expression that matches any URL that contains example.com.", "BP": ["Input Sanitization", "URL Validation", "Secure Redirect", "URL Scheme Enforcement"], "code": "import re\\r\\nfrom flask import Flask, redirect, request\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Define a regular expression to match URLs containing example.com\\r\\nURL_REGEX = re.compile(r'^https?://(?:www\\.)?example\\.com(/.*)?$')\\r\\n\\r\\n# Define a list of allowed URL schemes\\r\\nALLOWED_SCHEMES = ['http', 'https']\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    # Get the target parameter from the request\\r\\n    target = request.args.get('target')\\r\\n\\r\\n    # If no target parameter is provided, redirect to the root path\\r\\n    if not target:\\r\\n        return redirect('/')\\r\\n\\r\\n    # Sanitize the target URL by removing whitespace and newlines\\r\\n    target = target.strip().replace('\\n', '').replace('\\r', '')\\r\\n\\r\\n    # Parse the target URL and extract the scheme, netloc, and path\\r\\n    parsed_url = urlparse(target)\\r\\n    url_scheme = parsed_url.scheme\\r\\n    url_netloc = parsed_url.netloc\\r\\n    url_path = parsed_url.path\\r\\n\\r\\n    # Check if the target URL matches the regular expression\\r\\n    if URL_REGEX.match(target):\\r\\n        # Enforce URL scheme to be either http or https\\r\\n        if url_scheme not in ALLOWED_SCHEMES:\\r\\n            return redirect('/')\\r\\n\\r\\n        # Construct the full URL to redirect to\\r\\n        redirect_url = urljoin(f'{url_scheme}://{url_netloc}', url_path)\\r\\n\\r\\n        # Perform secure redirect\\r\\n        return redirect(redirect_url)\\r\\n    else:\\r\\n        # If the target URL does not match the regular expression, redirect to the root path\\r\\n        return redirect('/')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The regular expression matches a string that starts with one or more alphanumeric characters or hyphens followed by a period. The target variable is set to the value of the target query parameter. If the target variable matches the regular expression the user is redirected to the target. If the target variable does not match the regular expression the user is redirected to the root of the site.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect"], "code": "import re\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\nfrom flask import Flask, redirect, request\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Regular expression pattern to match the target URL\\r\\nURL_PATTERN = r'^[\\w\\-]+\\.'\\r\\n\\r\\ndef is_valid_url(target):\\r\\n    \"\"\"\\r\\n    Checks if the target URL is valid by matching it against the URL_PATTERN.\\r\\n    Returns True if the target is valid, False otherwise.\\r\\n    \"\"\"\\r\\n    return bool(re.match(URL_PATTERN, target))\\r\\n\\r\\ndef sanitize_url(target):\\r\\n    \"\"\"\\r\\n    Sanitizes the target URL by removing any potential malicious content.\\r\\n    Returns the sanitized URL as a string.\\r\\n    \"\"\"\\r\\n    sanitized_url = target.replace('\\r', '').replace('\\n', '')\\r\\n    return sanitized_url\\r\\n\\r\\ndef redirect_to_target(target):\\r\\n    \"\"\"\\r\\n    Securely redirects the user to the target URL.\\r\\n    If the target URL is unsafe or invalid, the user is redirected to the root of the site.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Parse the target URL\\r\\n        parsed_url = urlparse(target)\\r\\n\\r\\n        # Check if the URL is valid and has an allowed scheme\\r\\n        if parsed_url.scheme in ['http', 'https'] and is_valid_url(parsed_url.netloc):\\r\\n            # Sanitize the URL to prevent potential attacks\\r\\n            sanitized_url = sanitize_url(target)\\r\\n\\r\\n            # Construct the full URL and redirect\\r\\n            full_url = urljoin(request.url_root, sanitized_url)\\r\\n            return redirect(full_url)\\r\\n\\r\\n    except Exception as e:\\r\\n        # Log the error for debugging and auditing purposes\\r\\n        app.logger.error(f\"Error redirecting to target: {e}\")\\r\\n\\r\\n    # If the target URL is invalid or unsafe, redirect to the root\\r\\n    return redirect('/')\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    # Get the target query parameter\\r\\n    target = request.args.get('target')\\r\\n\\r\\n    if target:\\r\\n        # Redirect to the target URL or the root if it's invalid\\r\\n        return redirect_to_target(target)\\r\\n\\r\\n    # If no target is provided, render the default page\\r\\n    return 'Welcome to the site!'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The redirect_url function takes a url as an argument. The urlparse function from an imported module is used to parse the url. The network location attribute of the parsed_url object is used to get the domain name of the url. If the domain name is example.com the url is redirected. If the domain name is not example.com a 404 error is returned.", "BP": ["Standard Library", "Input Validation", "Exception Handling", "Custom Exception", "Secure Redirect"], "code": "import re\\r\\nfrom urllib.parse import urlparse\\r\\nfrom http import HTTPStatus\\r\\n\\r\\n# Custom exception for invalid URLs\\r\\nclass InvalidURLError(Exception):\\r\\n    pass\\r\\n\\r\\n# Function to validate URLs\\r\\ndef validate_url(url):\\r\\n    # Regular expression pattern for URLs\\r\\n    pattern = r'^https?://(?:www\\.)?([^/]+)/?.*$'\\r\\n    match = re.match(pattern, url)\\r\\n    if not match:\\r\\n        raise InvalidURLError(f\"Invalid URL: {url}\")\\r\\n    return match.group(1)\\r\\n\\r\\n# Function to handle secure redirection\\r\\ndef redirect_url(url):\\r\\n    try:\\r\\n        # Validate the input URL\\r\\n        domain = validate_url(url)\\r\\n        \\r\\n        # Check if the domain is example.com\\r\\n        if domain == \"example.com\":\\r\\n            # Perform secure redirection\\r\\n            # Replace with the actual redirection logic\\r\\n            print(f\"Redirecting to: {url}\")\\r\\n        else:\\r\\n            # Return a 404 error for other domains\\r\\n            raise Exception(f\"Error: {HTTPStatus.NOT_FOUND.value} Not Found\")\\r\\n    except InvalidURLError as e:\\r\\n        # Handle invalid URL exceptions\\r\\n        print(f\"Error: {e}\")\\r\\n    except Exception as e:\\r\\n        # Handle other exceptions\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\n# Example usage\\r\\nredirect_url(\"https://example.com/path\")\\r\\nredirect_url(\"http://example.com\")\\r\\nredirect_url(\"https://other.domain/path\")\\r\\nredirect_url(\"invalid_url\")", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route /redirect/<url> that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. If it is not it returns an error message.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect", "Separation of Concerns", "Secure Libraries", "Secure Regular Expressions"], "code": "import re\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\nfrom flask import Flask, redirect, abort\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure regular expression pattern to validate URLs\\r\\nURL_PATTERN = re.compile(\\r\\n    r'^(?:http|ftp)s?://'  # Scheme (HTTP or HTTPS)\\r\\n    r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # Domain name\\r\\n    r'localhost|'  # Localhost\\r\\n    r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # IPv4\\r\\n    r'(?::\\d+)?'  # Optional port\\r\\n    r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n\\r\\nALLOWED_DOMAIN = 'example.com'\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    \"\"\"Validate the URL using a secure regular expression.\"\"\"\\r\\n    return bool(URL_PATTERN.match(url))\\r\\n\\r\\ndef is_allowed_domain(url):\\r\\n    \"\"\"Check if the URL is from the allowed domain.\"\"\"\\r\\n    try:\\r\\n        parsed_url = urlparse(url)\\r\\n        return parsed_url.netloc.endswith(f'.{ALLOWED_DOMAIN}')\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\n@app.route('/redirect/<path:url>', methods=['GET'])\\r\\ndef redirect_url(url):\\r\\n    if not is_valid_url(url):\\r\\n        abort(400, 'Invalid URL format')\\r\\n\\r\\n    if not is_allowed_domain(url):\\r\\n        abort(403, 'URL from an unauthorized domain')\\r\\n\\r\\n    # Use urljoin to prevent open redirect vulnerabilities\\r\\n    safe_url = urljoin(request.url_root, url)\\r\\n\\r\\n    return redirect(safe_url, code=302)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route redirect url that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. Else it returns an error message.", "BP": ["Input Validation", "Hostname Validation", "Error Handling", "Separation of Concerns"], "code": "from flask import Flask, redirect, abort\\r\\nimport validators\\r\\nimport tldextract\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    \"\"\"\\r\\n    Validates the URL and checks if it is from example.com.\\r\\n\\r\\n    Args:\\r\\n        url (str): The URL to be validated.\\r\\n\\r\\n    Returns:\\r\\n        bool: True if the URL is valid and from example.com, False otherwise.\\r\\n    \"\"\"\\r\\n    # Check if the URL is valid\\r\\n    if not validators.url(url):\\r\\n        return False\\r\\n\\r\\n    # Extract the domain from the URL\\r\\n    ext = tldextract.extract(url)\\r\\n    domain = '.'.join(ext.domain + ext.suffix).lower()\\r\\n\\r\\n    # Check if the domain is example.com\\r\\n    return domain == 'example.com'\\r\\n\\r\\n@app.route('/redirect_url/<path:url>')\\r\\ndef redirect_url(url):\\r\\n    \"\"\"\\r\\n    Route function to redirect the user to the provided URL if it is from example.com.\\r\\n\\r\\n    Args:\\r\\n        url (str): The URL to redirect to.\\r\\n\\r\\n    Returns:\\r\\n        A redirect response if the URL is valid, or an error message if not.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        if is_valid_url(url):\\r\\n            return redirect(url)\\r\\n        else:\\r\\n            abort(403, \"Invalid URL. Only URLs from example.com are allowed.\")\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error redirecting to {url}: {e}\")\\r\\n        abort(500, \"An error occurred while redirecting.\")\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code reads a file from the /safe/ directory.", "BP": ["Input Validation", "Error Handling", "Directory Restriction", "Resource Cleanup", "Separation of Concerns"], "code": "import os\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Define the allowed directory for reading files\\r\\nALLOWED_DIR = \"/safe/\"\\r\\n\\r\\ndef read_file(file_path):\\r\\n    \"\"\"\\r\\n    Read the contents of a file from the /safe/ directory.\\r\\n\\r\\n    Args:\\r\\n        file_path (str): The path of the file to read.\\r\\n\\r\\n    Returns:\\r\\n        str: The contents of the file.\\r\\n\\r\\n    Raises:\\r\\n        ValueError: If the file path is not within the allowed directory.\\r\\n        FileNotFoundError: If the file does not exist.\\r\\n        PermissionError: If the file cannot be read due to permission issues.\\r\\n        Exception: If any other unexpected error occurs while reading the file.\\r\\n    \"\"\"\\r\\n    # Validate the file path\\r\\n    if not os.path.normpath(file_path).startswith(ALLOWED_DIR):\\r\\n        raise ValueError(f\"File path '{file_path}' is not within the allowed directory '{ALLOWED_DIR}'.\")\\r\\n\\r\\n    try:\\r\\n        # Open the file in read mode\\r\\n        with open(file_path, \"r\") as file:\\r\\n            # Read the contents of the file\\r\\n            contents = file.read()\\r\\n    except FileNotFoundError:\\r\\n        raise FileNotFoundError(f\"File '{file_path}' does not exist.\")\\r\\n    except PermissionError:\\r\\n        raise PermissionError(f\"Permission denied to read file '{file_path}'.\")\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected exceptions\\r\\n        raise Exception(f\"An unexpected error occurred while reading file '{file_path}': {str(e)}\")\\r\\n\\r\\n    return contents\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to read a file from the /safe/ directory.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Get the file path from the user\\r\\n        file_path = input(\"Enter the file path (e.g., /safe/file.txt): \")\\r\\n\\r\\n        # Read the file\\r\\n        file_contents = read_file(file_path)\\r\\n\\r\\n        # Print the contents of the file\\r\\n        print(f\"File contents:\\n{file_contents}\")\\r\\n    except Exception as e:\\r\\n        # Handle any exceptions raised by the read_file function or elsewhere\\r\\n        print(f\"Error: {str(e)}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads a requested file from the /safe/ directory.", "BP": ["Avoid Hardcoding Sensitive Paths", "Validate File Path", "Exception Handling", "Secure File Access", "Avoid Information Leaks"], "code": "import os\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Define a safe base directory for file access\\r\\nBASE_DIR = \"/safe\"\\r\\n\\r\\ndef read_file(requested_file):\\r\\n    try:\\r\\n        # Construct the full path using the safe base directory and the requested file\\r\\n        file_path = os.path.join(BASE_DIR, requested_file)\\r\\n        \\r\\n        # Validate the file path to prevent directory traversal attacks\\r\\n        normalized_path = os.path.normpath(file_path)\\r\\n        if not normalized_path.startswith(BASE_DIR):\\r\\n            raise ValueError(\"Invalid file path\")\\r\\n        \\r\\n        # Check if the file exists and is a regular file\\r\\n        if not os.path.isfile(normalized_path):\\r\\n            raise FileNotFoundError(f\"File not found: {requested_file}\")\\r\\n        \\r\\n        # Open the file in read mode and read its contents\\r\\n        with open(normalized_path, \"r\") as f:\\r\\n            content = f.read()\\r\\n        \\r\\n        return content\\r\\n    \\r\\n    except (ValueError, FileNotFoundError, PermissionError) as e:\\r\\n        # Handle exceptions and avoid information leaks\\r\\n        error_message = str(e)\\r\\n        return f\"Error: {error_message}\"\\r\\n    \\r\\n    except Exception as e:\\r\\n        # Handle any other exceptions\\r\\n        return \"An unexpected error occurred\"\\r\\n\\r\\n# Example usage\\r\\nrequested_file = \"example.txt\"\\r\\ncontent = read_file(requested_file)\\r\\nprint(content)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads the requested file from the safe directory.", "BP": ["Error Handling", "Preventing Code Injection Vulnerabilities", "Secure File Reading"], "code": "import os\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Define the safe directory path\\r\\nSAFE_DIR = \"/path/to/safe/directory\"\\r\\n\\r\\ndef read_file(file_name):\\r\\n    # Check if the requested file is within the safe directory\\r\\n    requested_path = os.path.join(SAFE_DIR, file_name)\\r\\n    normalized_path = os.path.normpath(requested_path)\\r\\n\\r\\n    if not normalized_path.startswith(SAFE_DIR):\\r\\n        # The requested file is outside the safe directory\\r\\n        return \"Access denied: You are not authorized to access this file.\"\\r\\n\\r\\n    try:\\r\\n        # Open the requested file for reading\\r\\n        with open(normalized_path, \"r\") as file:\\r\\n            content = file.read()\\r\\n        return content\\r\\n    except (IOError, OSError):\\r\\n        # Handle file not found or permission error\\r\\n        return \"Error: File not found or you don't have permission to access this file.\"\\r\\n\\r\\n# Example usage\\r\\nfile_name = \"example.txt\"\\r\\nfile_content = read_file(file_name)\\r\\nprint(file_content)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator above the img() function associates the URL of /img with this function.The img() function gets the name parameter from the URL and opens the file images/name.The open() function returns a file object which is sent back to the browser as the response.", "BP": ["Input Sanitization", "File Type Validation", "Error Handling"], "code": "from flask import Flask, send_file, abort\\r\\nimport os\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport mimetypes\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Define the allowed image file extensions\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Helper function to check if the file extension is allowed\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# Route decorator for the img() function\\r\\n@app.route('/img/<path:name>')\\r\\ndef img(name):\\r\\n    # Sanitize the input filename\\r\\n    filename = secure_filename(name)\\r\\n\\r\\n    # Check if the file exists and is an allowed image file\\r\\n    image_path = os.path.join('images', filename)\\r\\n    if not os.path.isfile(image_path) or not allowed_file(filename):\\r\\n        abort(404)  # Return 404 Not Found if the file doesn't exist or is not an allowed image\\r\\n\\r\\n    try:\\r\\n        # Get the MIME type of the file\\r\\n        mime_type = mimetypes.guess_type(image_path)[0]\\r\\n\\r\\n        # Send the file back to the browser as the response\\r\\n        return send_file(image_path, mimetype=mime_type)\\r\\n    except Exception as e:\\r\\n        # Handle any exceptions that may occur during file sending\\r\\n        app.logger.error(f'Error sending file: {str(e)}')\\r\\n        abort(500)  # Return 500 Internal Server Error if an exception occurs\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator is used to tell Flask what URL should trigger our function.The function checks if the file exists in the images folder. If the file exists it sends the file to the browser.", "BP": ["Directory Traversal Protection", "Unauthorized Access Prevention", "Error Handling"], "code": "import os\\r\\nfrom flask import Flask, send_file, abort\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Helper function to sanitize file paths\\r\\ndef secure_file_path(file_path):\\r\\n    # Resolve the file path to its absolute path\\r\\n    abs_path = os.path.abspath(file_path)\\r\\n    \\r\\n    # Check if the file is inside the allowed directory\\r\\n    images_dir = os.path.join(app.root_path, 'images')\\r\\n    if not abs_path.startswith(images_dir):\\r\\n        return None\\r\\n    \\r\\n    # Check if the file exists\\r\\n    if not os.path.isfile(abs_path):\\r\\n        return None\\r\\n    \\r\\n    return abs_path\\r\\n\\r\\n# Decorator to handle routes\\r\\ndef route(path):\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            try:\\r\\n                return func(*args, **kwargs)\\r\\n            except Exception as e:\\r\\n                app.logger.error(f\"Error occurred: {str(e)}\")\\r\\n                abort(500)\\r\\n        \\r\\n        @app.route(path, methods=['GET'])\\r\\n        def route_func(*args, **kwargs):\\r\\n            file_path = kwargs.get('file_path')\\r\\n            if file_path:\\r\\n                secure_path = secure_file_path(os.path.join('images', file_path))\\r\\n                if secure_path:\\r\\n                    try:\\r\\n                        return send_file(secure_path)\\r\\n                    except Exception as e:\\r\\n                        app.logger.error(f\"Error sending file: {str(e)}\")\\r\\n                        abort(500)\\r\\n                else:\\r\\n                    abort(404)\\r\\n            else:\\r\\n                return wrapper(*args, **kwargs)\\r\\n        \\r\\n        return route_func\\r\\n    return decorator\\r\\n\\r\\n# Example route\\r\\n@route('/images/<path:file_path>')\\r\\ndef serve_image(file_path):\\r\\n    # This function will never be called directly\\r\\n    # The @route decorator handles the request\\r\\n    pass\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The img() function is called when the user visits the /img route.The request.args.get('file') function gets the value of the file parameter in the URL.The open() function opens the file in read binary mode. The read() function reads the file and returns it.", "BP": ["Input Validation", "Error Handling", "File Contents Retrieval", "Response Handling", "Secure File Path"], "code": "import os\\r\\nfrom flask import make_response, abort\\r\\n\\r\\n# Define the base directory for images\\r\\nBASE_DIR = '/path/to/images'\\r\\n\\r\\ndef img():\\r\\n    # Get the file parameter from the URL\\r\\n    file_name = request.args.get('file')\\r\\n\\r\\n    # Perform input validation\\r\\n    if not file_name:\\r\\n        abort(400, 'Missing file parameter')\\r\\n\\r\\n    # Sanitize the file name to prevent path traversal attacks\\r\\n    file_name = os.path.basename(file_name)\\r\\n\\r\\n    # Construct the absolute file path\\r\\n    file_path = os.path.join(BASE_DIR, file_name)\\r\\n\\r\\n    # Check if the file exists and if it's a regular file\\r\\n    if not os.path.isfile(file_path):\\r\\n        abort(404, 'File not found')\\r\\n\\r\\n    # Check if the file is an image\\r\\n    if not file_name.endswith(('.jpg', '.png', '.gif')):\\r\\n        abort(400, 'Invalid file format')\\r\\n\\r\\n    try:\\r\\n        # Open the file in read binary mode\\r\\n        with open(file_path, 'rb') as f:\\r\\n            # Read the file contents\\r\\n            file_contents = f.read()\\r\\n\\r\\n        # Create a response object with the file contents\\r\\n        response = make_response(file_contents)\\r\\n\\r\\n        # Set the appropriate content type header\\r\\n        if file_name.endswith('.jpg'):\\r\\n            response.headers.set('Content-Type', 'image/jpeg')\\r\\n        elif file_name.endswith('.png'):\\r\\n            response.headers.set('Content-Type', 'image/png')\\r\\n        elif file_name.endswith('.gif'):\\r\\n            response.headers.set('Content-Type', 'image/gif')\\r\\n\\r\\n        return response\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle any exceptions that may occur during file operations\\r\\n        abort(500, f'Internal server error: {str(e)}')", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Unzip all files from the archive to the /tmp/unpack directory.", "BP": ["Secure File Handling", "Input Validation", "Error Handling"], "code": "import os\\r\\nimport tarfile\\r\\nimport tempfile\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Set the path for the archive file\\r\\narchive_path = Path(\"archive.zip\")\\r\\n\\r\\n# Create a temporary directory for unpacking\\r\\nwith tempfile.TemporaryDirectory() as temp_dir:\\r\\n    # Open the archive file safely\\r\\n    try:\\r\\n        with tarfile.open(archive_path, \"r\") as tar:\\r\\n            # Check if the archive has relative paths\\r\\n            for member in tar.getmembers():\\r\\n                if os.path.isabs(member.name):\\r\\n                    raise ValueError(\"Archive contains absolute paths\")\\r\\n\\r\\n            # Extract files to the temporary directory\\r\\n            tar.extractall(path=temp_dir)\\r\\n    except (tarfile.ReadError, ValueError) as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return\\r\\n\\r\\n    # Move files to the destination directory\\r\\n    dest_dir = Path(\"/tmp/unpack\")\\r\\n    dest_dir.mkdir(parents=True, exist_ok=True)\\r\\n    for item in os.listdir(temp_dir):\\r\\n        src_path = Path(temp_dir) / item\\r\\n        dest_path = dest_dir / item\\r\\n        os.rename(src_path, dest_path)\\r\\n\\r\\nprint(\"Files extracted successfully\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Extract all files from the archive to the /tmp/unpack directory.", "BP": ["Use of Temporary Directory", "Error Handling", "File Validation", "Cleanup"], "code": "import os\\r\\nimport tarfile\\r\\nimport tempfile\\r\\nimport shutil\\r\\n\\r\\n# Define the archive file path\\r\\narchive_file = \"archive.zip\"\\r\\n\\r\\n# Define the target extraction directory\\r\\ntarget_dir = os.path.join(tempfile.gettempdir(), \"unpack\")\\r\\n\\r\\n# Create the target directory if it doesn't exist\\r\\nos.makedirs(target_dir, exist_ok=True)\\r\\n\\r\\ntry:\\r\\n    # Open the archive file in read mode\\r\\n    with tarfile.open(archive_file, mode=\"r\") as archive:\\r\\n        # Extract all files to the target directory\\r\\n        archive.extractall(path=target_dir)\\r\\n\\r\\n    # Validate the extracted files\\r\\n    validate_extracted_files(target_dir)\\r\\n\\r\\nexcept (tarfile.TarError, OSError) as e:\\r\\n    # Handle extraction errors\\r\\n    print(f\"Error extracting files: {e}\")\\r\\n    # Clean up the target directory if extraction failed\\r\\n    shutil.rmtree(target_dir, ignore_errors=True)\\r\\nfinally:\\r\\n    # Clean up the target directory after successful extraction\\r\\n    shutil.rmtree(target_dir, ignore_errors=True)\\r\\n\\r\\ndef validate_extracted_files(target_dir):\\r\\n    \"\"\"\\r\\n    Validate the extracted files to ensure they are safe.\\r\\n    This function should implement appropriate checks based on your use case,\\r\\n    such as checking file types, sizes, and applying security scans.\\r\\n    \"\"\"\\r\\n    # Example: Check if any file exceeds a maximum size limit\\r\\n    max_file_size = 1024 * 1024  # 1 MB\\r\\n    for root, dirs, files in os.walk(target_dir):\\r\\n        for file in files:\\r\\n            file_path = os.path.join(root, file)\\r\\n            if os.path.getsize(file_path) > max_file_size:\\r\\n                print(f\"Warning: File {file_path} exceeds the maximum size limit.\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The with statement is used to wrap the execution of a block with methods defined by a context manager.The tarfile module makes it possible to read and write tar archives including those using gzip or bz2 compression.The open() function opens and returns a file handle that can be used to read or write a file in the usual way.", "BP": ["Input Validation", "Exception Handling", "Secure File Extraction", "Separation of Concerns", "Handling of Relative and Absolute Paths"], "code": "import os\\r\\nimport tarfile\\r\\nimport shutil\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Define allowed file extensions\\r\\nALLOWED_EXTENSIONS = ['.txt', '.py', '.log']\\r\\n\\r\\n# Define a function to validate input file path\\r\\ndef validate_file_path(file_path):\\r\\n    try:\\r\\n        # Check if the file path is absolute or relative\\r\\n        if os.path.isabs(file_path):\\r\\n            file_path = Path(file_path)\\r\\n        else:\\r\\n            # Handle relative paths\\r\\n            file_path = Path.cwd() / file_path\\r\\n\\r\\n        # Check if the file exists and is a file\\r\\n        if file_path.is_file():\\r\\n            # Check if the file extension is allowed\\r\\n            if file_path.suffix.lower() in ALLOWED_EXTENSIONS:\\r\\n                return str(file_path)\\r\\n            else:\\r\\n                raise ValueError(f\"File extension '{file_path.suffix}' is not allowed.\")\\r\\n        else:\\r\\n            raise FileNotFoundError(f\"File '{file_path}' not found.\")\\r\\n    except (ValueError, FileNotFoundError) as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return None\\r\\n\\r\\n# Define a function to extract a tar.gz file securely\\r\\ndef extract_tar_gz(tar_file_path, extract_dir):\\r\\n    try:\\r\\n        # Validate the input file path\\r\\n        validated_tar_file_path = validate_file_path(tar_file_path)\\r\\n        if validated_tar_file_path:\\r\\n            # Create the extraction directory if it doesn't exist\\r\\n            extract_dir = Path(extract_dir)\\r\\n            extract_dir.mkdir(parents=True, exist_ok=True)\\r\\n\\r\\n            with tarfile.open(validated_tar_file_path, 'r:gz') as tar:\\r\\n                # Extract files securely\\r\\n                tar.extractall(path=extract_dir, members=get_safe_members(tar))\\r\\n\\r\\n            print(f\"Files extracted successfully to '{extract_dir}'.\")\\r\\n    except tarfile.TarError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\n# Define a function to get safe members from a tar archive\\r\\ndef get_safe_members(tar):\\r\\n    for member in tar.getmembers():\\r\\n        # Check if the member is a file (not a directory)\\r\\n        if member.isfile():\\r\\n            # Check if the file extension is allowed\\r\\n            if os.path.splitext(member.name)[1].lower() in ALLOWED_EXTENSIONS:\\r\\n                yield member\\r\\n\\r\\n# Example usage\\r\\ntar_file_path = input(\"Enter the path to the tar.gz file: \")\\r\\nextract_dir = input(\"Enter the directory to extract files: \")\\r\\n\\r\\nextract_tar_gz(tar_file_path, extract_dir)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code executes the command getent passwd <username> and stores the output in the file pointer output. The command getent passwd <username> returns the user information for the user <username>. The command getent passwd <username> is executed by the system() function. The command getent passwd <username> is executed by the popen() function.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Secure File Handling", "Error Handling", "Principle of Least Privilege"], "code": "import re\\r\\nimport subprocess\\r\\nfrom pathlib import Path\\r\\n\\r\\ndef get_user_info(username):\\r\\n    # Input Sanitization\\r\\n    sanitized_username = re.sub(r'[^a-zA-Z0-9_-]', '', username)\\r\\n\\r\\n    if not sanitized_username:\\r\\n        raise ValueError(\"Invalid username\")\\r\\n\\r\\n    try:\\r\\n        # Secure Subprocess Execution\\r\\n        process = subprocess.Popen(['getent', 'passwd', sanitized_username], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\\r\\n        output, error = process.communicate()\\r\\n\\r\\n        if process.returncode != 0:\\r\\n            raise subprocess.CalledProcessError(process.returncode, process.args, output=output, stderr=error)\\r\\n\\r\\n        # Secure File Handling\\r\\n        with Path(\"/path/to/output/file.txt\").open(\"w\", encoding=\"utf-8\") as output_file:\\r\\n            output_file.write(output)\\r\\n\\r\\n        return output\\r\\n\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error executing command: {e.stderr}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    user_info = get_user_info(\"valid_username\")\\r\\n    print(user_info)\\r\\nexcept ValueError as e:\\r\\n    print(f\"Invalid input: {e}\")", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code is a simple program that takes a username as a command line argument and prints the user information from the /etc/passwd file. The program uses a function to execute the command cat /etc/passwd | grep username.The function executes the command specified in its argument. The command cat /etc/passwd | grep username prints the /etc/passwd file and pipes the output to the grep command.", "BP": ["Input Sanitization", "Error Handling", "Principle of Least Privilege", "Secure File Reading", "Secure Pattern Matching"], "code": "import os\\r\\nimport re\\r\\nimport sys\\r\\nfrom subprocess import run, PIPE\\r\\n\\r\\ndef get_user_info(username):\\r\\n    # Sanitize the input\\r\\n    sanitized_username = re.escape(username)\\r\\n\\r\\n    # Use a non-privileged user to read the password file\\r\\n    try:\\r\\n        passwd_file = open(\"/etc/passwd\", \"r\")\\r\\n    except PermissionError:\\r\\n        print(\"Error: Insufficient permissions to read /etc/passwd\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Use secure pattern matching with re.search\\r\\n    pattern = r\"^{}:\".format(sanitized_username)\\r\\n    for line in passwd_file:\\r\\n        match = re.search(pattern, line)\\r\\n        if match:\\r\\n            print(line.strip())\\r\\n            break\\r\\n    else:\\r\\n        print(f\"User '{username}' not found in /etc/passwd\")\\r\\n\\r\\n    passwd_file.close()\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <username>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    username = sys.argv[1]\\r\\n    get_user_info(username)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code takes a username as a command line argument.It then uses the a function to run the command id <username>. The id command prints information about the user. The function returns the exit status of the command. If the command is successful the exit status is 0.If the command fails the exit status is non-zero.The code prints the exit status of the command.", "BP": ["Input Validation", "Input Sanitization", "Secure Command Execution", "Error Handling", "Secure Exit"], "code": "import sys\\r\\nimport subprocess\\r\\nimport re\\r\\nimport os\\r\\n\\r\\ndef validate_username(username):\\r\\n    # Check if the username contains only alphanumeric characters and underscores\\r\\n    if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\ndef run_id_command(username):\\r\\n    try:\\r\\n        # Sanitize the username input\\r\\n        sanitized_username = re.escape(username)\\r\\n\\r\\n        # Construct the command to run\\r\\n        command = f\"id {sanitized_username}\"\\r\\n\\r\\n        # Run the command with subprocess and capture the output and exit status\\r\\n        process = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\\r\\n        exit_status = process.returncode\\r\\n\\r\\n        # Print the output and exit status\\r\\n        if exit_status == 0:\\r\\n            print(f\"Command executed successfully: {process.stdout.strip()}\")\\r\\n        else:\\r\\n            print(f\"Command failed with exit status {exit_status}: {process.stderr.strip()}\")\\r\\n\\r\\n        return exit_status\\r\\n\\r\\n    except Exception as e:\\r\\n        print(f\"Error occurred: {str(e)}\")\\r\\n        return 1\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <username>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    username = sys.argv[1]\\r\\n\\r\\n    # Validate the username input\\r\\n    if not validate_username(username):\\r\\n        print(\"Invalid username. Only alphanumeric characters and underscores are allowed.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Run the id command with the provided username\\r\\n    exit_status = run_id_command(username)\\r\\n\\r\\n    # Secure exit\\r\\n    os._exit(exit_status)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator tells the web application what URL should trigger our function.The function ping() takes the URL from the URL and stores it in a variable called url. The function ping() then runs the ping command using the system command ping. The output of the ping command is stored in a variable called output. The function ping() returns the output of the ping command.", "BP": ["Input Validation", "Subprocess Handling", "Output Escaping", "URL Validation", "Error Handling"], "code": "import re\\r\\nimport subprocess\\r\\nfrom flask import Flask, request, escape\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef validate_url(url):\\r\\n    # Use a regular expression to validate the URL format\\r\\n    url_regex = re.compile(\\r\\n        r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\\r\\n        r'localhost|'  # localhost...\\r\\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or IP\\r\\n        r'(?::\\d+)?'  # optional port\\r\\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n    return bool(url_regex.match(url))\\r\\n\\r\\ndef validate_input(url):\\r\\n    # Validate the URL format\\r\\n    if not validate_url(url):\\r\\n        return \"Invalid URL format\", 400\\r\\n\\r\\n    # Additional input validation can be added here\\r\\n\\r\\n    return None\\r\\n\\r\\ndef escape_output(output):\\r\\n    # Use HTML escaping to prevent XSS attacks\\r\\n    return escape(output)\\r\\n\\r\\ndef run_ping(url):\\r\\n    # Validate the input URL\\r\\n    error = validate_input(url)\\r\\n    if error:\\r\\n        return error\\r\\n\\r\\n    try:\\r\\n        # Run the ping command\\r\\n        output = subprocess.check_output(['ping', '-c', '4', url], universal_newlines=True)\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        # Handle errors from the ping command\\r\\n        return f\"Error: {escape_output(str(e))}\", 500\\r\\n    except Exception as e:\\r\\n        # Handle other exceptions\\r\\n        return f\"Error: {escape_output(str(e))}\", 500\\r\\n\\r\\n    # Escape the output to prevent XSS attacks\\r\\n    output = escape_output(output)\\r\\n\\r\\n    return output, 200\\r\\n\\r\\n@app.route('/ping', methods=['GET'])\\r\\ndef ping():\\r\\n    url = request.args.get('url')\\r\\n    output, status_code = run_ping(url)\\r\\n    return output, status_code\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The URL is returned to the browser. The code is a simple example of how to run a system command.", "BP": ["Input Sanitization", "Use of subprocess", "Validation of Request Method", "Validation of URL Parameter", "Error Handling", "Appropriate HTTP Status Codes"], "code": "import re\\r\\nimport subprocess\\r\\nfrom urllib.parse import urlparse\\r\\nfrom flask import Flask, request, make_response\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Regular expression to validate URLs\\r\\nURL_PATTERN = r'^(http|https)://([\\w\\-.]+)(\\.[a-zA-Z]{2,5})([\\w\\-.\\?%&=]*)?$'\\r\\n\\r\\ndef validate_url(url):\\r\\n    \"\"\"\\r\\n    Validate the URL using a regular expression.\\r\\n    \"\"\"\\r\\n    return bool(re.match(URL_PATTERN, url))\\r\\n\\r\\ndef ping_url(url):\\r\\n    \"\"\"\\r\\n    Ping the given URL using the system command \"ping\".\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Use subprocess to run the system command\\r\\n        ping_command = ['ping', '-c', '4', urlparse(url).netloc]\\r\\n        result = subprocess.run(ping_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\\r\\n        return result.stdout\\r\\n    except Exception as e:\\r\\n        # Handle any errors that occur during the ping process\\r\\n        return f\"Error: {str(e)}\"\\r\\n\\r\\ndef ping_decorator(func):\\r\\n    def wrapper(*args, **kwargs):\\r\\n        # Validate the request method\\r\\n        if request.method != 'GET':\\r\\n            return make_response('Method Not Allowed', 405)\\r\\n\\r\\n        # Get the URL parameter from the request\\r\\n        url = request.args.get('url')\\r\\n\\r\\n        # Validate the URL parameter\\r\\n        if not url or not validate_url(url):\\r\\n            return make_response('Invalid URL', 400)\\r\\n\\r\\n        # Call the decorated function with the validated URL\\r\\n        response = func(url)\\r\\n        return make_response(response, 200)\\r\\n\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/ping', methods=['GET'])\\r\\n@ping_decorator\\r\\ndef ping(url):\\r\\n    \"\"\"\\r\\n    Ping the given URL and return the result.\\r\\n    \"\"\"\\r\\n    return ping_url(url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The output of the ping command is stored in the variable \"pong\". If the ping command returns 0 the URL is alive.Else the URL is not alive.", "BP": ["Input Validation", "Input Sanitization", "Principle of Least Privilege", "Exception Handling", "Secure Output"], "code": "import re\\r\\nimport subprocess\\r\\nfrom functools import wraps\\r\\nfrom urllib.parse import urlparse\\r\\n\\r\\n# Define a regular expression pattern to validate URLs\\r\\nURL_PATTERN = re.compile(r'^https?://(?:[\\w\\-]+\\.)+\\w+(?:/\\S*)?$')\\r\\n\\r\\ndef validate_url(url):\\r\\n    \"\"\"Validate the input URL using a regular expression\"\"\"\\r\\n    if not URL_PATTERN.match(url):\\r\\n        raise ValueError(\"Invalid URL\")\\r\\n\\r\\ndef sanitize_url(url):\\r\\n    \"\"\"Sanitize the input URL by removing potential malicious characters\"\"\"\\r\\n    return ''.join(char for char in url if char.isalnum() or char in ('-', '.', ':', '/', '?', '=', '%'))\\r\\n\\r\\ndef bind_to_url(url):\\r\\n    \"\"\"\\r\\n    Decorator function to bind a function to a URL.\\r\\n    Performs input validation, input sanitization, applies the principle of least privilege,\\r\\n    handles exceptions, and secures output.\\r\\n    \"\"\"\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            try:\\r\\n                # Validate and sanitize the input URL\\r\\n                sanitized_url = sanitize_url(url)\\r\\n                validate_url(sanitized_url)\\r\\n\\r\\n                # Run the ping command using a subprocess with the principle of least privilege\\r\\n                ping_command = [\"ping\", \"-c\", \"1\", sanitized_url]\\r\\n                ping_process = subprocess.run(ping_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\\r\\n\\r\\n                # Check if the ping command was successful\\r\\n                if ping_process.returncode == 0:\\r\\n                    pong = \"URL is alive\"\\r\\n                else:\\r\\n                    pong = \"URL is not alive\"\\r\\n\\r\\n                # Secure output by escaping HTML entities\\r\\n                import html\\r\\n                output = html.escape(pong)\\r\\n\\r\\n                # Call the original function with the output\\r\\n                return func(output, *args, **kwargs)\\r\\n            except Exception as e:\\r\\n                # Handle exceptions and return a sanitized error message\\r\\n                import html\\r\\n                error_message = html.escape(str(e))\\r\\n                return func(f\"Error: {error_message}\", *args, **kwargs)\\r\\n\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n# Example usage\\r\\n@bind_to_url(\"https://www.example.com\")\\r\\ndef ping(result):\\r\\n    print(result)\\r\\n\\r\\nping()", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a system function to execute the ls command.The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the system function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Error Handling", "Principle of Least Privilege"], "code": "import subprocess\\r\\nimport shlex\\r\\nimport os\\r\\n\\r\\ndef run_ls_command(directory, sanitize_input=True):\\r\\n    # Input Sanitization\\r\\n    if sanitize_input:\\r\\n        directory = os.path.normpath(directory)\\r\\n        if not os.path.isdir(directory):\\r\\n            raise ValueError(f\"Invalid directory: {directory}\")\\r\\n\\r\\n    try:\\r\\n        # Secure Subprocess Execution\\r\\n        command = shlex.split(f\"ls {directory}\")\\r\\n        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)\\r\\n\\r\\n        # Principle of Least Privilege\\r\\n        if os.geteuid() != 0:\\r\\n            print(\"Warning: This script is not running with root privileges.\")\\r\\n\\r\\n        return result.stdout\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        # Error Handling\\r\\n        print(f\"Error: {e.stderr.strip()}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\n# Example usage\\r\\ndirectory = input(\"Enter a directory path: \")\\r\\noutput = run_ls_command(directory)\\r\\nif output:\\r\\n    print(output.strip())", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a function to execute the ls command.The function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Subprocess Execution", "Secure Command Execution"], "code": "import shlex\\r\\nimport subprocess\\r\\nimport re\\r\\n\\r\\ndef execute_command(command_str):\\r\\n    # Input Validation: Check if the command string is empty or contains only whitespace\\r\\n    if not command_str.strip():\\r\\n        raise ValueError(\"Invalid command: Empty or whitespace-only input.\")\\r\\n\\r\\n    # Input Sanitization: Remove potential malicious characters from the command string\\r\\n    sanitized_command = re.sub(r'[^a-zA-Z0-9\\s\\./\\-_]', '', command_str)\\r\\n\\r\\n    # Split the sanitized command into a list of arguments\\r\\n    args = shlex.split(sanitized_command)\\r\\n\\r\\n    # Error Handling: Check if the command is allowed\\r\\n    if args[0] != \"ls\":\\r\\n        raise ValueError(\"Invalid command: Only 'ls' command is allowed.\")\\r\\n\\r\\n    try:\\r\\n        # Secure Subprocess Execution\\r\\n        completed_process = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)\\r\\n        output = completed_process.stdout.decode().strip()\\r\\n        error = completed_process.stderr.decode().strip()\\r\\n\\r\\n        if error:\\r\\n            print(f\"Error executing command: {error}\")\\r\\n        else:\\r\\n            print(output)\\r\\n\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error executing command: {e.stderr.decode().strip()}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error executing command: {e}\")\\r\\n\\r\\n# Input Sanitization and Secure Command Execution\\r\\ncommand = input(\"Enter command (only 'ls' is allowed): \")\\r\\nexecute_command(command)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses the system function to execute the ls command. The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Command Execution"], "code": "import subprocess\\r\\nimport shlex\\r\\nfrom typing import List\\r\\n\\r\\ndef secure_execute_command(command: str) -> None:\\r\\n    \"\"\"\\r\\n    Securely execute a command using subprocess module.\\r\\n\\r\\n    This function performs input validation, input sanitization, and error handling\\r\\n    to prevent code injection and other security vulnerabilities.\\r\\n\\r\\n    Args:\\r\\n        command (str): The command to execute.\\r\\n\\r\\n    Returns:\\r\\n        None\\r\\n    \"\"\"\\r\\n    # Input Validation and Sanitization\\r\\n    allowed_commands = ['ls']  # List of allowed commands\\r\\n    sanitized_command = shlex.quote(command)\\r\\n    command_parts = shlex.split(sanitized_command)\\r\\n\\r\\n    if command_parts[0] not in allowed_commands:\\r\\n        print(f\"Error: Command '{command}' is not allowed.\")\\r\\n        return\\r\\n\\r\\n    try:\\r\\n        # Secure Command Execution\\r\\n        result = subprocess.run(command_parts, capture_output=True, check=True, text=True)\\r\\n        print(result.stdout.strip())\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error: Command '{command}' failed with exit code {e.returncode}.\")\\r\\n        print(f\"Error output: {e.stderr.strip()}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nsecure_execute_command(\"ls -l\")", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The function http_hello_page is called when the server receives a request for the URL /hello. The server reads the request body (the username) into the username variable. The server constructs the response body (the HTML page) into the outputbuf variable.The server writes the response body to the response stream. The server closes the response stream.The server is now ready to handle the next request.", "BP": ["Input Sanitization", "Separation of Concerns", "Error Handling", "Secure Handling Request Body", "Secure Handling Response Body"], "code": "import html\\r\\nfrom http import HTTPStatus\\r\\n\\r\\ndef http_hello_page(environ, start_response):\\r\\n    try:\\r\\n        # Read the request body (username)\\r\\n        request_body_size = int(environ.get('CONTENT_LENGTH', 0))\\r\\n        username = environ['wsgi.input'].read(request_body_size).decode('utf-8')\\r\\n\\r\\n        # Sanitize the input (username)\\r\\n        sanitized_username = html.escape(username)\\r\\n\\r\\n        # Construct the response body (HTML page)\\r\\n        outputbuf = f\"\"\"\\r\\n<!DOCTYPE html>\\r\\n<html>\\r\\n<head>\\r\\n    <title>Hello Page</title>\\r\\n</head>\\r\\n<body>\\r\\n    <h1>Hello, {sanitized_username}!</h1>\\r\\n</body>\\r\\n</html>\\r\\n\"\"\"\\r\\n\\r\\n        # Encode the response body as bytes\\r\\n        response_body = outputbuf.encode('utf-8')\\r\\n\\r\\n        # Set the response headers\\r\\n        headers = [\\r\\n            ('Content-Type', 'text/html'),\\r\\n            ('Content-Length', str(len(response_body))),\\r\\n        ]\\r\\n\\r\\n        # Start the response process with a successful status code\\r\\n        start_response(str(HTTPStatus.OK), headers)\\r\\n\\r\\n        # Write the response body to the response stream\\r\\n        return [response_body]\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle exceptions securely\\r\\n        error_msg = f\"Error: {str(e)}\"\\r\\n        response_body = error_msg.encode('utf-8')\\r\\n        headers = [\\r\\n            ('Content-Type', 'text/plain'),\\r\\n            ('Content-Length', str(len(response_body))),\\r\\n        ]\\r\\n        start_response(str(HTTPStatus.INTERNAL_SERVER_ERROR), headers)\\r\\n        return [response_body]", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The function http_hello_page takes in a request and a response. The request is a file stream that contains the request from the client. The response is a file stream that we can write to in order to send a response to the client. The request contains the username that the client entered. We read the username from the request. We construct a response that says \"Hello [username]\". We write the response to the response file stream.", "BP": ["Input Sanitization", "Error Handling", "Separation of Concerns"], "code": "import re\\r\\n\\r\\ndef sanitize_input(user_input):\\r\\n    \"\"\"\\r\\n    Sanitize user input to prevent injection attacks.\\r\\n    \"\"\"\\r\\n    sanitized_input = re.sub(r'[^a-zA-Z0-9_]', '', user_input)\\r\\n    return sanitized_input\\r\\n\\r\\ndef get_username_from_request(request_stream):\\r\\n    \"\"\"\\r\\n    Read and sanitize the username from the request stream.\\r\\n    \"\"\"\\r\\n    request_data = request_stream.read().decode('utf-8')\\r\\n    match = re.search(r'username=([a-zA-Z0-9_]+)', request_data)\\r\\n    if match:\\r\\n        username = match.group(1)\\r\\n        sanitized_username = sanitize_input(username)\\r\\n        return sanitized_username\\r\\n    else:\\r\\n        return None\\r\\n\\r\\ndef construct_response(username):\\r\\n    \"\"\"\\r\\n    Construct the response message.\\r\\n    \"\"\"\\r\\n    if username:\\r\\n        response_body = f\"Hello {username}\"\\r\\n    else:\\r\\n        response_body = \"Hello, guest\"\\r\\n    response_headers = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n\"\\r\\n    response = response_headers + response_body\\r\\n    return response.encode('utf-8')\\r\\n\\r\\ndef http_hello_page(request_stream, response_stream):\\r\\n    \"\"\"\\r\\n    Handle the HTTP request and send the response.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        username = get_username_from_request(request_stream)\\r\\n        response_data = construct_response(username)\\r\\n        response_stream.write(response_data)\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        error_response = \"HTTP/1.1 500 Internal Server Error\\r\\nContent-Type: text/plain\\r\\n\\r\\nInternal Server Error\"\\r\\n        response_stream.write(error_response.encode('utf-8'))", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The function http_hello_page takes in a request and a response. The request is a file stream that contains the request from the client. The response is a file stream that we can write to. The request contains the username that the client entered. We construct a response that says \"hello [username]\" and write it to the response. The response is sent back to the client.The function escape_html is a function that escapes HTML.", "BP": ["Input Sanitization", "Escaping HTML Characters", "Separation of Concerns", "Error Handling"], "code": "import html\\r\\n\\r\\ndef escape_html(input_str):\\r\\n    \"\"\"\\r\\n    Escape HTML characters in the given input string.\\r\\n    \\r\\n    Args:\\r\\n        input_str (str): The input string to be escaped.\\r\\n        \\r\\n    Returns:\\r\\n        str: The escaped string.\\r\\n    \"\"\"\\r\\n    return html.escape(input_str)\\r\\n\\r\\ndef http_hello_page(request, response):\\r\\n    \"\"\"\\r\\n    Handle the HTTP request and generate a response with a personalized greeting.\\r\\n    \\r\\n    Args:\\r\\n        request (file-like object): A file-like object containing the HTTP request from the client.\\r\\n        response (file-like object): A file-like object to write the HTTP response.\\r\\n        \\r\\n    Returns:\\r\\n        None\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Read the request body\\r\\n        request_body = request.read().decode('utf-8')\\r\\n        \\r\\n        # Extract the username from the request body\\r\\n        username = extract_username(request_body)\\r\\n        \\r\\n        # Escape HTML characters in the username\\r\\n        escaped_username = escape_html(username)\\r\\n        \\r\\n        # Construct the response\\r\\n        response_body = f\"Hello {escaped_username}\"\\r\\n        \\r\\n        # Write the response to the response stream\\r\\n        response.write(response_body.encode('utf-8'))\\r\\n        \\r\\n    except Exception as e:\\r\\n        # Handle exceptions and log the error\\r\\n        error_message = f\"An error occurred: {str(e)}\"\\r\\n        log_error(error_message)\\r\\n        \\r\\n        # Send an error response to the client\\r\\n        error_response = \"Internal Server Error\"\\r\\n        response.write(error_response.encode('utf-8'))\\r\\n\\r\\ndef extract_username(request_body):\\r\\n    \"\"\"\\r\\n    Extract the username from the request body.\\r\\n    \\r\\n    Args:\\r\\n        request_body (str): The request body as a string.\\r\\n        \\r\\n    Returns:\\r\\n        str: The extracted username.\\r\\n    \"\"\"\\r\\n    # Implement the logic to extract the username from the request body\\r\\n    # This will depend on the format of the request body\\r\\n    # For example, if the request body is a query string like \"username=John\",\\r\\n    # you can use the following code:\\r\\n    #\\r\\n    # import urllib.parse\\r\\n    # parsed_body = urllib.parse.parse_qs(request_body)\\r\\n    # username = parsed_body.get('username', [''])[0]\\r\\n    #\\r\\n    # Replace this with the appropriate logic for your use case\\r\\n    username = \"DefaultUsername\"\\r\\n    return username\\r\\n\\r\\ndef log_error(error_message):\\r\\n    \"\"\"\\r\\n    Log the error message.\\r\\n    \\r\\n    Args:\\r\\n        error_message (str): The error message to be logged.\\r\\n        \\r\\n    Returns:\\r\\n        None\\r\\n    \"\"\"\\r\\n    # Implement the logic to log the error message\\r\\n    # This could involve writing to a log file, sending an email, or integrating with a logging service\\r\\n    print(error_message)", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The render_response_from_env function takes an environment as an argument. The function gets the name parameter from the request. The function gets the template from the environment. The function renders the template with the name parameter. The function returns a response with the rendered template. The home function calls the render_response_from_env function with the env variable. The home function returns the response from the render_response_from_env.", "BP": ["Input Sanitization", "Security Headers", "Separation of Concerns"], "code": "from flask import Flask, request, render_template_string, make_response\\r\\nimport jinja2\\r\\nfrom markupsafe import Markup, escape\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Security Headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Render Response from Environment\\r\\ndef render_response_from_env(env):\\r\\n    # Get the name parameter from the request\\r\\n    name = request.args.get('name', '')\\r\\n    # Sanitize the input\\r\\n    name = escape(name)\\r\\n\\r\\n    # Get the template from the environment\\r\\n    template = env.get_template('home.html')\\r\\n\\r\\n    # Render the template with the sanitized name parameter\\r\\n    rendered_template = template.render(name=name)\\r\\n\\r\\n    # Create a response with the rendered template\\r\\n    response = make_response(rendered_template)\\r\\n    return response\\r\\n\\r\\n# Home Function\\r\\ndef home():\\r\\n    # Create a Jinja2 environment\\r\\n    env = jinja2.Environment(autoescape=True)\\r\\n\\r\\n    # Call the render_response_from_env function with the env variable\\r\\n    response = render_response_from_env(env)\\r\\n\\r\\n    return response\\r\\n\\r\\n# Route for the home page\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return home()\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The render_response_from_env function takes an environment as an argument. The function gets the name parameter from the request. The function gets the template from the environment. The function renders the template with the name parameter. The function returns a response with the rendered template. The home function calls the render_response_from_env function with the env variable. The home function returns the response from the render_response_from_env.", "BP": ["Input Sanitization", "Automatic HTML Escaping", "Error Handling"], "code": "from urllib.parse import quote\\r\\nfrom jinja2 import Environment, escape\\r\\n\\r\\ndef render_response_from_env(env):\\r\\n    name = sanitize_input(request.args.get('name', ''))\\r\\n    try:\\r\\n        template = env.get_template('template.html')\\r\\n    except TemplateNotFound:\\r\\n        return 'Template not found', 404\\r\\n    except Exception as e:\\r\\n        return 'Internal Server Error', 500\\r\\n\\r\\n    rendered_template = template.render(name=escape(name))\\r\\n    return rendered_template, 200\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    return quote(input_str, safe='')\\r\\n\\r\\ndef home():\\r\\n    env = Environment(autoescape=True)\\r\\n    response, status_code = render_response_from_env(env)\\r\\n    return response, status_code", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The render_response_from_env function takes an environment as an argument. The function gets the name parameter from the user request. The function gets the template from the environment. The function renders the template with the name parameter from the request. The function returns a response with the rendered template. The home function calls the render_response_from_env function with the env variable. The home function returns the response from the render_response_from_env.", "BP": ["Session Security", "Input Sanitization", "Error Handling", "Logging and Monitoring", "CSRF Protection"], "code": "import os\\r\\nimport logging\\r\\nfrom flask import Flask, request, session\\r\\nfrom jinja2 import TemplateNotFound\\r\\nfrom markupsafe import escape\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure random secret key\\r\\n\\r\\n# Set up CSRF protection\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Set up environment\\r\\nenv = Environment(loader=FileSystemLoader('templates'))\\r\\n\\r\\ndef render_response_from_env(env):\\r\\n    try:\\r\\n        # Get the name parameter from the request, sanitize it\\r\\n        name = escape(request.args.get('name', ''))\\r\\n\\r\\n        # Check if the user is authenticated\\r\\n        if 'user_id' not in session:\\r\\n            logging.warning('Unauthenticated access attempt')\\r\\n            return 'Unauthorized', 403\\r\\n\\r\\n        # Get the template from the environment\\r\\n        template = env.get_template('home.html')\\r\\n    except TemplateNotFound:\\r\\n        logging.error('Template not found')\\r\\n        return 'Template not found', 404\\r\\n    except Exception as e:\\r\\n        logging.error(f'Error rendering template: {str(e)}')\\r\\n        return 'Internal server error', 500\\r\\n\\r\\n    try:\\r\\n        # Render the template with the name parameter\\r\\n        rendered_template = template.render(name=name)\\r\\n    except Exception as e:\\r\\n        logging.error(f'Error rendering template: {str(e)}')\\r\\n        return 'Internal server error', 500\\r\\n\\r\\n    # Return the response with the rendered template\\r\\n    return rendered_template\\r\\n\\r\\n@app.route('/')\\r\\ndef home():\\r\\n    # Call the render_response_from_env function with the env variable\\r\\n    response = render_response_from_env(env)\\r\\n    return response\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL. The function hello() is called when a user visits the URL /hello/<username>. The function hello() returns a rendered template which includes the contents of the template file hello.html as well as the value of the username variable. The username variable is passed to the template hello.html which displays the value of the variable.", "BP": ["Input validation", "Input Sanitization", "Error Handling", "Decorator Function", "Secure URL Handling"], "code": "from flask import Flask, render_template, abort\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Define the allowed character pattern for usernames\\r\\nUSERNAME_PATTERN = r'^[a-zA-Z0-9_]+$'\\r\\n\\r\\n# Decorator function to handle URL mapping\\r\\ndef route(path):\\r\\n    def decorator(func):\\r\\n        @app.route(path)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            try:\\r\\n                return func(*args, **kwargs)\\r\\n            except Exception as e:\\r\\n                # Handle exceptions and log the error\\r\\n                app.logger.error(f\"Error occurred: {str(e)}\")\\r\\n                abort(500)\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n@route('/hello/<username>')\\r\\ndef hello(username):\\r\\n    # Input validation and sanitization\\r\\n    if not re.match(USERNAME_PATTERN, username):\\r\\n        # Handle invalid usernames\\r\\n        abort(400, \"Invalid username. Only alphanumeric characters and underscores are allowed.\")\\r\\n\\r\\n    # Limit the username length to prevent DOS attacks\\r\\n    if len(username) > 20:\\r\\n        abort(400, \"Username is too long.\")\\r\\n\\r\\n    try:\\r\\n        # Render the template with the sanitized username\\r\\n        return render_template('hello.html', username=username)\\r\\n    except Exception as e:\\r\\n        # Handle exceptions and log the error\\r\\n        app.logger.error(f\"Error occurred: {str(e)}\")\\r\\n        abort(500)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)  # Run the Flask app in production mode", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The first line imports the web application class. An instance of this class will be our WSGI application. The second line creates the application object. The third line is a decorator. It tells the application which URL should call the associated function. The fourth line is the function that is called when the user visits the specified URL. The fifth line returns the message to the user. The sixth line runs the application.", "BP": ["XSS Prevention", "Secure Host and Port", "Disable Debug Mode", "Secure Dependencies", "Input Validation", "Secure Headers"], "code": "from flask import Flask, request, escape\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Disable debug mode\\r\\napp.config['DEBUG'] = False\\r\\n\\r\\n# Secure headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Secure host and port\\r\\nhost = '127.0.0.1'\\r\\nport = 5000\\r\\n\\r\\n# Secure dependencies\\r\\nimport urllib3\\r\\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\\r\\n\\r\\n# Input validation\\r\\n@app.route('/', methods=['GET'])\\r\\ndef hello():\\r\\n    name = request.args.get('name', 'World')\\r\\n    name = escape(name)  # Escape user input to prevent XSS\\r\\n    return f'Hello, {name}!'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host=host, port=port)", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: A decorator creates a mapping between the URL given as an argument and the function that follows it. The function hello() returns a string with the text Hello followed by the value of the variable username. The variable username is passed as an argument to the function hello(). The escape() function converts special characters to HTML-safe sequences. The function hello() is called when a user navigates to the URL /hello/username\".", "BP": ["Input Validation", "Input Sanitization", "Secure URL Routing", "Separation of Concerns", "Error Handling"], "code": "import re\\r\\nfrom flask import Flask, escape, abort\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure URL routing with input validation\\r\\ndef secure_route(route):\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            # Input validation for the URL parameter\\r\\n            username = kwargs.get('username')\\r\\n            if not username or not re.match(r'^[\\w\\-]+$', username):\\r\\n                abort(400, \"Invalid username\")\\r\\n\\r\\n            return func(username=escape(username))\\r\\n        app.route(route, methods=['GET'])(wrapper)\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n# Separation of Concerns: User-facing logic\\r\\n@secure_route('/hello/<username>')\\r\\ndef hello(username):\\r\\n    try:\\r\\n        return f\"Hello {username}\"\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"An error occurred: {e}\")\\r\\n        abort(500, \"An internal server error occurred\")\\r\\n\\r\\n# Input Sanitization\\r\\ndef escape(value):\\r\\n    return value.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('\"', '&quot;').replace(\"'\", '&#x27;')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)", "CWE": "CWE-79"}
{"text": "Generate Python code for the following: The user enters their email address into the unsubscribe form on the website. The email address is passed to the unsubscribe function.The unsubscribe function connects to the database and checks if the email address is in the database.If the email address is in the database it is removed.If the email address is not in the database the user is told that they are not in the database.", "BP": ["Input Validation", "Data Sanitization", "Error Handling", "Principle of Least Privilege"], "code": "import re\\r\\nimport hashlib\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import errorcode\\r\\n\\r\\n# Validate email address using a regular expression\\r\\ndef validate_email(email):\\r\\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(pattern, email))\\r\\n\\r\\n# Hash the email address for storage\\r\\ndef hash_email(email):\\r\\n    return hashlib.sha256(email.encode()).hexdigest()\\r\\n\\r\\n# Connect to the database\\r\\ndef connect_db():\\r\\n    try:\\r\\n        db = mysql.connector.connect(\\r\\n            host=\"your_host\",\\r\\n            user=\"your_user\",\\r\\n            password=\"your_password\",\\r\\n            database=\"your_database\"\\r\\n        )\\r\\n        return db\\r\\n    except mysql.connector.Error as err:\\r\\n        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:\\r\\n            print(\"Something is wrong with your user name or password\")\\r\\n        elif err.errno == errorcode.ER_BAD_DB_ERROR:\\r\\n            print(\"Database does not exist\")\\r\\n        else:\\r\\n            print(err)\\r\\n        return None\\r\\n\\r\\n# Unsubscribe function\\r\\ndef unsubscribe(email):\\r\\n    # Validate email address\\r\\n    if not validate_email(email):\\r\\n        return \"Invalid email address\"\\r\\n\\r\\n    # Hash the email address\\r\\n    hashed_email = hash_email(email)\\r\\n\\r\\n    # Connect to the database\\r\\n    db = connect_db()\\r\\n    if db is None:\\r\\n        return \"Failed to connect to the database\"\\r\\n\\r\\n    # Check if the email address is in the database\\r\\n    cursor = db.cursor()\\r\\n    query = \"SELECT COUNT(*) FROM subscribers WHERE email_hash = %s\"\\r\\n    cursor.execute(query, (hashed_email,))\\r\\n    count = cursor.fetchone()[0]\\r\\n\\r\\n    if count > 0:\\r\\n        # Remove the email address from the database\\r\\n        query = \"DELETE FROM subscribers WHERE email_hash = %s\"\\r\\n        cursor.execute(query, (hashed_email,))\\r\\n        db.commit()\\r\\n        return \"You have been unsubscribed\"\\r\\n    else:\\r\\n        return \"You are not subscribed\"\\r\\n\\r\\n    cursor.close()\\r\\n    db.close()\\r\\n\\r\\n# Example usage\\r\\nemail = input(\"Enter your email address: \")\\r\\nresult = unsubscribe(email)\\r\\nprint(result)", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: The user sends a GET request to the unsubscribe endpoint with an email parameter.The code checks if the email is in the database. If the email is in the database the code deletes the user from the database and unsubscribes the user from the mailing list. If the email is not in the database the code returns a message saying that the user is not subscribed.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns", "Database Session Management"], "code": "import re\\r\\nfrom flask import request, jsonify\\r\\nfrom database import db_session\\r\\nfrom models import User\\r\\nfrom mailing_list import unsubscribe_user\\r\\n\\r\\n# Regular expression pattern to validate email format\\r\\nEMAIL_REGEX = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n\\r\\ndef unsubscribe():\\r\\n    email = request.args.get('email')\\r\\n\\r\\n    # Input validation\\r\\n    if not email or not re.match(EMAIL_REGEX, email):\\r\\n        return jsonify({'error': 'Invalid email address'}), 400\\r\\n\\r\\n    # Prevent SQL Injection\\r\\n    email = email.replace(\"'\", \"''\")\\r\\n\\r\\n    # Check if email exists in the database\\r\\n    user = db_session.query(User).filter(User.email == email).first()\\r\\n\\r\\n    if user:\\r\\n        try:\\r\\n            # Unsubscribe user from mailing list\\r\\n            unsubscribe_user(user.email)\\r\\n\\r\\n            # Delete user from the database\\r\\n            db_session.delete(user)\\r\\n            db_session.commit()\\r\\n\\r\\n            return jsonify({'message': 'User unsubscribed successfully'}), 200\\r\\n        except Exception as e:\\r\\n            db_session.rollback()\\r\\n            return jsonify({'error': str(e)}), 500\\r\\n    else:\\r\\n        return jsonify({'message': 'User is not subscribed'}), 404\\r\\n\\r\\n# Close the database session after the request is completed\\r\\n@app.teardown_appcontext\\r\\ndef shutdown_session(exception=None):\\r\\n    db_session.remove()", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: Check if the email exists in the database. If it doesn't it returns 0. If it does it calls a php script that unsubscribes the email. If the php script returns 0 it returns 1. If not it returns 0.", "BP": ["Input Sanitization", "Parameterized Queries", "Secure HTTP Requests", "Secure URL Construction"], "code": "import sqlite3\\r\\nimport requests\\r\\nfrom urllib.parse import urlencode, quote_plus\\r\\n\\r\\n# Function to sanitize user input\\r\\ndef sanitize_input(input_str):\\r\\n    return ''.join(char for char in input_str if char.isalnum() or char in ['@', '.', '_', '-'])\\r\\n\\r\\n# Function to check if email exists in the database\\r\\ndef check_email_exists(email):\\r\\n    conn = sqlite3.connect('database.db')\\r\\n    c = conn.cursor()\\r\\n\\r\\n    # Sanitize the email input\\r\\n    sanitized_email = sanitize_input(email)\\r\\n\\r\\n    # Use parameterized queries to prevent SQL injection\\r\\n    c.execute(\"SELECT COUNT(*) FROM users WHERE email = ?\", (sanitized_email,))\\r\\n    result = c.fetchone()[0]\\r\\n\\r\\n    conn.close()\\r\\n\\r\\n    return result\\r\\n\\r\\n# Function to unsubscribe email\\r\\ndef unsubscribe_email(email):\\r\\n    sanitized_email = sanitize_input(email)\\r\\n    encoded_email = quote_plus(sanitized_email)\\r\\n\\r\\n    # Construct the URL for the PHP script with the encoded email\\r\\n    php_script_url = f\"https://example.com/unsubscribe.php?email={encoded_email}\"\\r\\n\\r\\n    try:\\r\\n        # Send a GET request to the PHP script\\r\\n        response = requests.get(php_script_url, timeout=10)\\r\\n\\r\\n        # Check the response from the PHP script\\r\\n        if response.status_code == 200 and response.text == \"0\":\\r\\n            return 1  # Unsubscription successful\\r\\n        else:\\r\\n            return 0  # Unsubscription failed\\r\\n    except requests.exceptions.RequestException:\\r\\n        return 0  # Request failed\\r\\n\\r\\n# Example usage\\r\\ninput_email = \"user@example.com\"\\r\\n\\r\\n# Check if the email exists in the database\\r\\nemail_exists = check_email_exists(input_email)\\r\\n\\r\\nif email_exists:\\r\\n    # Unsubscribe the email\\r\\n    unsubscribe_result = unsubscribe_email(input_email)\\r\\n    print(unsubscribe_result)\\r\\nelse:\\r\\n    print(0)", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: The buy_stock function is called when the user clicks on the buy button.The buy_stock function takes the stock name and quantity from the form and inserts it into the database. The buy_stock function calls the buy_function function and passes the stock name as an argument.The buy_function function takes the stock name as an argument.", "BP": ["Input Validation", "Parameterized Queries", "Least Privilege", "Error Handling", "Secure Database Connection", "Secure Communication", "Input Sanitization"], "code": "import sqlite3\\r\\nimport hashlib\\r\\nfrom urllib.parse import quote_plus\\r\\n\\r\\n# Configuration\\r\\nDB_FILE = 'database.db'\\r\\nSSL_CERT = 'ssl/server.crt'\\r\\nSSL_KEY = 'ssl/server.key'\\r\\n\\r\\n# Establish a secure database connection\\r\\ndef get_db_connection():\\r\\n    conn = sqlite3.connect(DB_FILE, check_same_thread=False)\\r\\n    conn.row_factory = sqlite3.Row\\r\\n    return conn\\r\\n\\r\\n# Input validation and sanitization\\r\\ndef validate_input(stock_name, quantity):\\r\\n    # Ensure stock_name is a non-empty string\\r\\n    if not isinstance(stock_name, str) or not stock_name.strip():\\r\\n        raise ValueError(\"Invalid stock name\")\\r\\n\\r\\n    # Ensure quantity is a positive integer\\r\\n    try:\\r\\n        quantity = int(quantity)\\r\\n    except ValueError:\\r\\n        raise ValueError(\"Invalid quantity\")\\r\\n\\r\\n    if quantity <= 0:\\r\\n        raise ValueError(\"Quantity must be a positive integer\")\\r\\n\\r\\n    # Sanitize user input to prevent SQL injection\\r\\n    stock_name = quote_plus(stock_name.strip())\\r\\n\\r\\n    return stock_name, quantity\\r\\n\\r\\n# Buy function with parameterized query\\r\\ndef buy_function(stock_name):\\r\\n    try:\\r\\n        conn = get_db_connection()\\r\\n        cur = conn.cursor()\\r\\n\\r\\n        # Parameterized query to prevent SQL injection\\r\\n        query = \"SELECT * FROM stocks WHERE name = ?\"\\r\\n        cur.execute(query, (stock_name,))\\r\\n        stock = cur.fetchone()\\r\\n\\r\\n        if stock:\\r\\n            # Perform stock buying operations\\r\\n            print(f\"Buying stock: {stock['name']}\")\\r\\n        else:\\r\\n            print(f\"Stock '{stock_name}' not found.\")\\r\\n\\r\\n    except sqlite3.Error as e:\\r\\n        print(f\"Database error: {e}\")\\r\\n    finally:\\r\\n        if conn:\\r\\n            conn.close()\\r\\n\\r\\n# Buy stock function\\r\\ndef buy_stock(stock_name, quantity):\\r\\n    try:\\r\\n        stock_name, quantity = validate_input(stock_name, quantity)\\r\\n\\r\\n        conn = get_db_connection()\\r\\n        cur = conn.cursor()\\r\\n\\r\\n        # Parameterized query to prevent SQL injection\\r\\n        query = \"INSERT INTO transactions (stock_name, quantity) VALUES (?, ?)\"\\r\\n        cur.execute(query, (stock_name, quantity))\\r\\n        conn.commit()\\r\\n\\r\\n        print(f\"Bought {quantity} shares of {stock_name}\")\\r\\n\\r\\n        # Call buy_function with the stock name\\r\\n        buy_function(stock_name)\\r\\n\\r\\n    except ValueError as e:\\r\\n        print(f\"Invalid input: {e}\")\\r\\n    except sqlite3.Error as e:\\r\\n        print(f\"Database error: {e}\")\\r\\n    finally:\\r\\n        if conn:\\r\\n            conn.close()\\r\\n\\r\\n# Example usage\\r\\nbuy_stock(\"AAPL\", 100)", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: The user enters the stock name and quantity in the form.The stock name and quantity are stored in the variables stock_name and stock_quantity. The username is stored in the variable username.The buy order is inserted into the database.The user is redirected to the profile page.", "BP": ["Input Validation", "Input Sanitization", "Authentication", "Authorization", "Database Security", "Error Handling", "HTTPS Implementation", "CSRF Protection"], "code": "from flask import Flask, render_template, request, redirect, session, url_for\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport re\\r\\nimport bcrypt\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///stocks.db'\\r\\ncsrf = CSRFProtect(app)\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n    def __init__(self, username, password):\\r\\n        self.username = username\\r\\n        self.password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\\r\\n\\r\\nclass Stock(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    stock_name = db.Column(db.String(80), nullable=False)\\r\\n    stock_quantity = db.Column(db.Integer, nullable=False)\\r\\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\\r\\n\\r\\n@app.route('/buy_stock', methods=['GET', 'POST'])\\r\\ndef buy_stock():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        stock_name = request.form.get('stock_name')\\r\\n        stock_quantity = request.form.get('stock_quantity')\\r\\n\\r\\n        # Input Validation and Sanitization\\r\\n        if not stock_name or not stock_quantity:\\r\\n            return render_template('buy_stock.html', error='Please enter stock name and quantity.')\\r\\n\\r\\n        stock_name = re.sub(r'[^a-zA-Z0-9]', '', stock_name)\\r\\n        if not stock_name.isalnum():\\r\\n            return render_template('buy_stock.html', error='Stock name should contain only alphanumeric characters.')\\r\\n\\r\\n        try:\\r\\n            stock_quantity = int(stock_quantity)\\r\\n        except ValueError:\\r\\n            return render_template('buy_stock.html', error='Quantity should be a number.')\\r\\n\\r\\n        if stock_quantity < 1:\\r\\n            return render_template('buy_stock.html', error='Quantity should be greater than zero.')\\r\\n\\r\\n        # Insert order into database\\r\\n        user = User.query.filter_by(username=session['username']).first()\\r\\n        stock = Stock(stock_name=stock_name, stock_quantity=stock_quantity, user_id=user.id)\\r\\n        db.session.add(stock)\\r\\n        db.session.commit()\\r\\n\\r\\n        return redirect(url_for('profile'))\\r\\n\\r\\n    return render_template('buy_stock.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input Validation and Sanitization\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter username and password.')\\r\\n\\r\\n        username = re.sub(r'[^a-zA-Z0-9]', '', username)\\r\\n        if not username.isalnum():\\r\\n            return render_template('login.html', error='Username should contain only alphanumeric characters.')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and bcrypt.checkpw(password.encode('utf-8'), user.password_hash):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('profile'))\\r\\n\\r\\n        return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/profile')\\r\\ndef profile():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    user = User.query.filter_by(username=session['username']).first()\\r\\n    stocks = Stock.query.filter_by(user_id=user.id).all()\\r\\n\\r\\n    return render_template('profile.html', stocks=stocks)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n    app.run(host='0.0.0.0', port=5000,  , ssl_context='adhoc')", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: The user enters the stock name and quantity in the form. The form is submitted to the buy_order route. The buy_order route takes the stock name and quantity and inserts it into the database. The user is redirected to the stock_view page. The code is a very simple example of how to insert data into a database.", "BP": ["Input Validation", "Parameterized Queries", "Secure Session Management", "Authentication and Authorization", "Secure Templates", "Secure Secret Key", "CSRF Protection", "Error Handling", "Password Hashing"], "code": "from flask import Flask, render_template, request, redirect, session, url_for\\r\\nimport bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom functools import wraps\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'your_secret_key')\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///orders.db'\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(50), nullable=False, unique=True)\\r\\n    password_hash = db.Column(db.String(100), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return bcrypt.checkpw(password.encode('utf-8'), self.password_hash.encode('utf-8'))\\r\\n\\r\\n\\r\\nclass Order(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    stock_name = db.Column(db.String(50), nullable=False)\\r\\n    quantity = db.Column(db.Integer, nullable=False)\\r\\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\\r\\n\\r\\n\\r\\ndef login_required(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        if 'user_id' not in session:\\r\\n            return redirect(url_for('login'))\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter username and password')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('stock_view'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid username or password')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n\\r\\n@app.route('/buy_order', methods=['POST'])\\r\\n@login_required\\r\\ndef buy_order():\\r\\n    stock_name = request.form.get('stock_name')\\r\\n    quantity = request.form.get('quantity')\\r\\n\\r\\n    if not stock_name or not quantity:\\r\\n        return 'Please enter stock name and quantity', 400\\r\\n\\r\\n    try:\\r\\n        quantity = int(quantity)\\r\\n    except ValueError:\\r\\n        return 'Invalid quantity', 400\\r\\n\\r\\n    user_id = session['user_id']\\r\\n    order = Order(stock_name=stock_name, quantity=quantity, user_id=user_id)\\r\\n    db.session.add(order)\\r\\n    db.session.commit()\\r\\n\\r\\n    return redirect(url_for('stock_view'))\\r\\n\\r\\n\\r\\n@app.route('/stock_view')\\r\\n@login_required\\r\\ndef stock_view():\\r\\n    user_id = session['user_id']\\r\\n    orders = Order.query.filter_by(user_id=user_id).all()\\r\\n    return render_template('stock_view.html', orders=orders)\\r\\n\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n    app.run( )", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: Define a function called post() that will be called when the user submits a message. It gets the username and message from the request. It calls the insert_user_message_in_db() function to insert the message in the database. It redirects the user to the main page. Now add the code to display the messages.", "BP": ["Input Validation", "Input Sanitization", "Secure Database Interaction", "URL Redirection", "HTML Rendering"], "code": "from flask import Flask, request, redirect, url_for, escape\\r\\nimport re\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import errorcode\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configuration for database connection\\r\\ndb_config = {\\r\\n    'user': 'your_username',\\r\\n    'password': 'your_password',\\r\\n    'host': 'your_host',\\r\\n    'database': 'your_database'\\r\\n}\\r\\n\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        conn = mysql.connector.connect(**db_config)\\r\\n        return conn\\r\\n    except mysql.connector.Error as err:\\r\\n        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:\\r\\n            print(\"Something is wrong with your user name or password\")\\r\\n        elif err.errno == errorcode.ER_BAD_DB_ERROR:\\r\\n            print(\"Database does not exist\")\\r\\n        else:\\r\\n            print(err)\\r\\n        return None\\r\\n\\r\\ndef close_db_connection(conn):\\r\\n    if conn:\\r\\n        conn.close()\\r\\n\\r\\ndef insert_user_message_in_db(username, message):\\r\\n    conn = get_db_connection()\\r\\n    if conn:\\r\\n        try:\\r\\n            cursor = conn.cursor()\\r\\n            query = \"INSERT INTO messages (username, message) VALUES (%s, %s)\"\\r\\n            cursor.execute(query, (username, message))\\r\\n            conn.commit()\\r\\n        except mysql.connector.Error as err:\\r\\n            print(f\"Error: {err}\")\\r\\n        finally:\\r\\n            close_db_connection(conn)\\r\\n\\r\\n@app.route('/post', methods=['POST'])\\r\\ndef post():\\r\\n    # Input Validation and Sanitization\\r\\n    username = escape(request.form.get('username', ''))\\r\\n    message = escape(request.form.get('message', ''))\\r\\n\\r\\n    # Check if username and message are not empty\\r\\n    if not username or not message:\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    # Check if username and message contain only allowed characters\\r\\n    allowed_chars = re.compile(r'^[\\w\\s.,!?]+$')\\r\\n    if not allowed_chars.match(username) or not allowed_chars.match(message):\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    # Insert message into the database\\r\\n    insert_user_message_in_db(username, message)\\r\\n\\r\\n    # URL Redirection\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    conn = get_db_connection()\\r\\n    messages = []\\r\\n    if conn:\\r\\n        try:\\r\\n            cursor = conn.cursor()\\r\\n            query = \"SELECT username, message FROM messages\"\\r\\n            cursor.execute(query)\\r\\n            messages = cursor.fetchall()\\r\\n        except mysql.connector.Error as err:\\r\\n            print(f\"Error: {err}\")\\r\\n        finally:\\r\\n            close_db_connection(conn)\\r\\n\\r\\n    # HTML Rendering\\r\\n    html = \"<h1>Messages</h1>\"\\r\\n    for message in messages:\\r\\n        username, content = message\\r\\n        html += f\"<p><strong>{escape(username)}</strong>: {escape(content)}</p>\"\\r\\n\\r\\n    return html\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: Create a new route called /post. It gets the username and message from the request. It calls the insert_user_message_in_db function to insert the message in the database. It redirects the user to the / route. Now add the code to display the messages.", "BP": ["Input Sanitization", "Parameterized Queries", "Secure Database Connection", "Error Handling", "Separation of Concerns", "Secure Redirection", "Secure Session Key"], "code": "from flask import Flask, request, redirect, session, escape\\r\\nimport os\\r\\nfrom sqlalchemy import create_engine, text\\r\\nfrom sqlalchemy.exc import SQLAlchemyError\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure session key\\r\\n\\r\\n# Set up database connection\\r\\ndb_user = os.environ.get('DB_USER')\\r\\ndb_pass = os.environ.get('DB_PASS')\\r\\ndb_host = os.environ.get('DB_HOST')\\r\\ndb_name = os.environ.get('DB_NAME')\\r\\ndb_conn_str = f'mysql+pymysql://{db_user}:{db_pass}@{db_host}/{db_name}'\\r\\nengine = create_engine(db_conn_str, echo=False, pool_recycle=3600)\\r\\n\\r\\n# Route for posting a message\\r\\n@app.route('/post', methods=['POST'])\\r\\ndef post_message():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/')  # Redirect if user is not logged in\\r\\n\\r\\n    username = escape(session['username'])  # Sanitize user input\\r\\n    message = escape(request.form.get('message', ''))  # Sanitize user input\\r\\n\\r\\n    try:\\r\\n        with engine.connect() as conn:\\r\\n            # Use parameterized query to prevent SQL injection\\r\\n            stmt = text('INSERT INTO messages (user_id, message) VALUES (:user_id, :message)')\\r\\n            conn.execute(stmt, {'user_id': session['user_id'], 'message': message})\\r\\n    except SQLAlchemyError as e:\\r\\n        # Handle database errors\\r\\n        print(f'Database error: {str(e)}')\\r\\n        return redirect('/')\\r\\n\\r\\n    return redirect('/')  # Secure redirection\\r\\n\\r\\n# Route for displaying messages\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/login')  # Redirect if user is not logged in\\r\\n\\r\\n    try:\\r\\n        with engine.connect() as conn:\\r\\n            # Retrieve messages from the database\\r\\n            stmt = text('SELECT m.message, u.username FROM messages m JOIN users u ON m.user_id = u.id ORDER BY m.created_at DESC')\\r\\n            messages = conn.execute(stmt).fetchall()\\r\\n    except SQLAlchemyError as e:\\r\\n        # Handle database errors\\r\\n        print(f'Database error: {str(e)}')\\r\\n        messages = []\\r\\n\\r\\n    return render_template('index.html', messages=messages, username=session['username'])\\r\\n\\r\\n# Separation of concerns: Other functions like authentication, database operations, etc. can be placed in separate modules or files.\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-89"}
{"text": "Generate Python code for the following: Define a function called post() that will be called when the user submits a message. It gets the username and message from the request. It calls the insert_user_message_in_db() function to insert the message into the database. It redirects the user back to the main page. Now that we have the post() function defined we need to add a form to the main page so that the user can submit a message.", "BP": ["Input Validation", "Output Encoding", "Secure Database Access", "Secure Redirects", "CSRF Protection", "Rate Limiting", "Secure Session Management", "Form Design"], "code": "from flask import Flask, render_template, request, redirect, session, escape\\r\\nimport bcrypt\\r\\nimport sqlite3\\r\\nimport re\\r\\nimport time\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/' # This should be a secure, random value in production\\r\\n\\r\\n# Rate Limiting\\r\\nrate_limit = {}\\r\\n\\r\\n# Database Configuration\\r\\ndb_file = 'messages.db'\\r\\n\\r\\n# CSRF Protection\\r\\ndef generate_csrf_token():\\r\\n    if '_csrf_token' not in session:\\r\\n        session['_csrf_token'] = secrets.token_urlsafe(16)\\r\\n    return session['_csrf_token']\\r\\n\\r\\napp.jinja_env.globals['csrf_token'] = generate_csrf_token\\r\\n\\r\\n# Input Validation\\r\\nusername_regex = re.compile(r'^[\\w\\-\\s]+$')\\r\\nmessage_regex = re.compile(r'^[\\w\\-\\s!?.,]+$')\\r\\n\\r\\ndef validate_input(username, message):\\r\\n    if not username_regex.match(username):\\r\\n        return False, \"Invalid username\"\\r\\n    if not message_regex.match(message):\\r\\n        return False, \"Invalid message\"\\r\\n    return True, None\\r\\n\\r\\n# Database Access\\r\\ndef insert_user_message_in_db(username, message):\\r\\n    conn = sqlite3.connect(db_file)\\r\\n    c = conn.cursor()\\r\\n    c.execute(\"INSERT INTO messages (username, message) VALUES (?, ?)\", (username, message))\\r\\n    conn.commit()\\r\\n    conn.close()\\r\\n\\r\\n# Form Design\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef index():\\r\\n    if request.method == 'POST':\\r\\n        # CSRF Protection\\r\\n        if request.form.get('_csrf_token') != session.get('_csrf_token'):\\r\\n            return \"Invalid CSRF token\", 400\\r\\n\\r\\n        # Rate Limiting\\r\\n        client_ip = request.remote_addr\\r\\n        current_time = time.time()\\r\\n        if client_ip in rate_limit and current_time - rate_limit[client_ip] < 5:  # 5 seconds\\r\\n            return \"Rate limit exceeded\", 429\\r\\n        rate_limit[client_ip] = current_time\\r\\n\\r\\n        # Input Validation\\r\\n        username = request.form.get('username')\\r\\n        message = request.form.get('message')\\r\\n        valid, error = validate_input(username, message)\\r\\n        if not valid:\\r\\n            return error, 400\\r\\n\\r\\n        # Secure Database Access\\r\\n        insert_user_message_in_db(username, message)\\r\\n\\r\\n        # Secure Redirects\\r\\n        return redirect('/')\\r\\n\\r\\n    # Secure Session Management\\r\\n    session.permanent = True\\r\\n\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.after_request\\r\\ndef secure_response(response):\\r\\n    # Output Encoding\\r\\n    response.data = escape(response.data)\\r\\n    return response\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run( )", "CWE": "CWE-89"}
