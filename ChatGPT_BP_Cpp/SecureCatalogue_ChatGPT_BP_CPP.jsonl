{"text": "Generate C++ code for the following: A function copies a number of bytes from one memory location to another. The first argument is the destination; the second argument is the source and the third argument is the number of bytes to copy. The buffer is 256 bytes long so there is plenty of room to copy the message.", "BP": ["Null pointer checks", "Buffer size check", "Use of memory-safe functions", "Error Handling", "Null Terminator"], "code": "#include <iostream>\\r\\n#include <cstring>  // for memcpy, memset\\r\\n#include <stdexcept> // for std::invalid_argument\\r\\n\\r\\nconst size_t BUFFER_SIZE = 256;  // Define buffer size\\r\\n\\r\\n// Memory copy function with safety checks\\r\\nvoid safeMemoryCopy(void* dest, const void* src, size_t numBytes) {\\r\\n    // Null pointer check\\r\\n    if (dest == nullptr || src == nullptr) {\\r\\n        throw std::invalid_argument(\"Null pointer passed as argument.\");\\r\\n    }\\r\\n\\r\\n    // Buffer size check\\r\\n    if (numBytes > BUFFER_SIZE) {\\r\\n        throw std::out_of_range(\"Number of bytes to copy exceeds buffer size.\");\\r\\n    }\\r\\n\\r\\n    // Use memory-safe function (memmove) instead of memcpy\\r\\n    // memmove allows overlapping memory regions\\r\\n    std::memmove(dest, src, numBytes);\\r\\n\\r\\n    // Ensure that the destination buffer is null-terminated\\r\\n    if (numBytes < BUFFER_SIZE) {\\r\\n        static_cast<char*>(dest)[numBytes] = '\\0';\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    // Define source and destination buffers\\r\\n    char source[BUFFER_SIZE] = \"Hello, World!\";  // Example source message\\r\\n    char destination[BUFFER_SIZE];               // Destination buffer\\r\\n\\r\\n    try {\\r\\n        // Perform memory copy\\r\\n        safeMemoryCopy(destination, source, strlen(source));\\r\\n\\r\\n        // Output the copied content\\r\\n        std::cout << \"Copied message: \" << destination << std::endl;\\r\\n    } catch (const std::exception& e) {\\r\\n        // Handle any errors\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: The code takes an index as an argument and prints the corresponding argument from the command line arguments. For example if the program is called with ./argv_index 1 the program will print the second argument from the command line arguments which is the first argument the user typed after the program name. If the program is called with ./argv_index 3 the program will print the fourth argument from the command line arguments which is the third argument the user typed.", "BP": ["Input Validation", "Error Handling", "Secure Library Functions", "Avoiding Buffer Overflows", "Secure Output"], "code": "#include <iostream>\\r\\n#include <stdexcept>\\r\\n#include <cstdlib> // for std::strtol\\r\\n#include <climits> // for INT_MAX and INT_MIN\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Ensure there are at least two arguments: the program name and an index\\r\\n    if (argc < 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <index>\" << std::endl;\\r\\n        return 1; // Return non-zero for error\\r\\n    }\\r\\n\\r\\n    // Perform input validation on the index argument\\r\\n    char* endptr;\\r\\n    long index = std::strtol(argv[1], &endptr, 10);\\r\\n\\r\\n    // Check if the conversion succeeded and ensure it's a valid integer\\r\\n    if (*endptr != '\\0' || endptr == argv[1]) {\\r\\n        std::cerr << \"Error: Invalid index. Please enter a valid integer.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Check for out-of-range errors\\r\\n    if (index < 1 || index > INT_MAX) {\\r\\n        std::cerr << \"Error: Index out of valid range. Enter a positive integer within range.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Convert 1-based index to 0-based for array lookup\\r\\n    int arg_index = static_cast<int>(index);\\r\\n\\r\\n    // Ensure the index is within the number of provided arguments\\r\\n    if (arg_index >= argc) {\\r\\n        std::cerr << \"Error: Index exceeds the number of arguments.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Output the argument securely\\r\\n    std::cout << \"Argument at index \" << index << \": \" << argv[arg_index] << std::endl;\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: The code takes in a command line argument and converts it to an integer.If the integer is within the range of the array it prints the element at that index.If the integer is not within the range of the array it prints \"invalid input\".", "BP": ["Input Validation", "Error Handling", "Array Bounds Checking", "Secure Type Conversions", "Secure Output"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n#include <limits> // for std::numeric_limits\\r\\n\\r\\n// Function to convert a string to an integer securely\\r\\nint convertToInt(const std::string& input) {\\r\\n    try {\\r\\n        size_t pos;\\r\\n        // Convert the string to an integer using std::stoi\\r\\n        int number = std::stoi(input, &pos);\\r\\n\\r\\n        // Ensure that the entire string was a valid integer\\r\\n        if (pos != input.length()) {\\r\\n            throw std::invalid_argument(\"Input contains non-integer characters.\");\\r\\n        }\\r\\n\\r\\n        return number;\\r\\n    } catch (const std::invalid_argument& e) {\\r\\n        throw std::runtime_error(\"Invalid input: Not a valid integer.\");\\r\\n    } catch (const std::out_of_range& e) {\\r\\n        throw std::runtime_error(\"Invalid input: Integer out of range.\");\\r\\n    }\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Define an array of integers\\r\\n    const int arr[] = {10, 20, 30, 40, 50};\\r\\n    const int arrSize = sizeof(arr) / sizeof(arr[0]);\\r\\n\\r\\n    // Check if a command-line argument is provided\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Error: Please provide a single integer as a command-line argument.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        // Convert the argument to an integer\\r\\n        int index = convertToInt(argv[1]);\\r\\n\\r\\n        // Check if the index is within the array bounds\\r\\n        if (index >= 0 && index < arrSize) {\\r\\n            std::cout << \"Element at index \" << index << \": \" << arr[index] << std::endl;\\r\\n        } else {\\r\\n            std::cerr << \"Invalid input: Index out of bounds.\" << std::endl;\\r\\n        }\\r\\n    } catch (const std::runtime_error& e) {\\r\\n        // Handle any conversion or validation errors\\r\\n        std::cerr << e.what() << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: atoi() converts a string to an integer. argc is the number of arguments passed to the program. Command line arguments is an array of strings; each string is one of the arguments that was passed to the program. The first argument is always the name of the program so if the user ran ./a.out foo bar baz; argc would be 4; argv[0] would be ./a.out argv.", "BP": ["Input Validation", "Use of Secure Functions", "Error Handling", "Robust Integer Conversion", "Command-line Input Handling", "Output Formatting"], "code": "#include <iostream>\\r\\n#include <cstdlib>      // for atoi\\r\\n#include <string>       // for std::string\\r\\n#include <limits>       // for std::numeric_limits\\r\\n#include <cerrno>       // for errno\\r\\n#include <cstring>      // for strerror\\r\\n#include <climits>      // for INT_MAX and INT_MIN\\r\\n\\r\\n// Function to convert a string to an integer with robust error handling\\r\\nbool convertStringToInt(const char* str, int& result) {\\r\\n    char* endPtr;\\r\\n    errno = 0; // Reset errno before calling strtol()\\r\\n\\r\\n    long tempResult = strtol(str, &endPtr, 10); // Using strtol for better error checking\\r\\n\\r\\n    // Check for errors:\\r\\n    // 1. If no digits were found (endPtr points to the start of the string)\\r\\n    if (endPtr == str) {\\r\\n        std::cerr << \"Error: No digits found in argument \\\"\" << str << \"\\\".\\n\";\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // 2. If there are any non-numeric characters in the string\\r\\n    if (*endPtr != '\\0') {\\r\\n        std::cerr << \"Error: Argument \\\"\" << str << \"\\\" contains non-numeric characters.\\n\";\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // 3. Check for out-of-range values\\r\\n    if ((errno == ERANGE && (tempResult == LONG_MAX || tempResult == LONG_MIN)) || tempResult > INT_MAX || tempResult < INT_MIN) {\\r\\n        std::cerr << \"Error: Argument \\\"\" << str << \"\\\" is out of the range for an int.\\n\";\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // Assign the valid converted value\\r\\n    result = static_cast<int>(tempResult);\\r\\n    return true;\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Check if there are enough arguments passed\\r\\n    if (argc < 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <list of integers>\\n\";\\r\\n        return 1; // Return with error code 1 for insufficient arguments\\r\\n    }\\r\\n\\r\\n    // Process each argument passed, starting from argv[1] as argv[0] is the program name\\r\\n    for (int i = 1; i < argc; ++i) {\\r\\n        int convertedValue;\\r\\n        if (convertStringToInt(argv[i], convertedValue)) {\\r\\n            std::cout << \"Argument \" << i << \" (\" << argv[i] << \") converted to integer: \" << convertedValue << \"\\n\";\\r\\n        } else {\\r\\n            std::cerr << \"Error converting argument \" << i << \": \\\"\" << argv[i] << \"\\\" to an integer.\\n\";\\r\\n            return 2; // Exit with error code 2 for conversion errors\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return 0; // Program executed successfully\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: atoi() is a function that converts a string to an integer. Command line arguments at index 1 is the second argument passed to the program. Command line argument at index INDEX is the argument at the INDEX specified by the second argument. print function prints the string at INDEX position in the command line arguments to the screen. return 0. exit the program.", "BP": ["Input Validation", "Secure String-to-Integer Conversion", "Error Handling", "Avoiding Unnecessary Memory Allocations", "Secure Output"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <cstdlib>    // For atoi()\\r\\n#include <stdexcept>  // For exceptions\\r\\n#include <cerrno>     // For errno\\r\\n#include <limits>     // For integer limits\\r\\n\\r\\n// Function to safely convert a string to an integer\\r\\nint safeStringToInt(const std::string& str) {\\r\\n    errno = 0; // Reset errno before calling strtol\\r\\n    char* endPtr = nullptr;\\r\\n    long value = std::strtol(str.c_str(), &endPtr, 10);\\r\\n\\r\\n    // Check if the entire string was converted and check for out-of-range errors\\r\\n    if (*endPtr != '\\0' || errno == ERANGE || value < std::numeric_limits<int>::min() || value > std::numeric_limits<int>::max()) {\\r\\n        throw std::invalid_argument(\"Invalid integer input: \" + str);\\r\\n    }\\r\\n\\r\\n    return static_cast<int>(value);\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    try {\\r\\n        // Check if at least two arguments are provided (program name + second argument)\\r\\n        if (argc < 2) {\\r\\n            std::cerr << \"Error: No arguments provided.\\n\";\\r\\n            return 1;\\r\\n        }\\r\\n\\r\\n        // Convert the second argument (at index 1) to an integer (this will be the index argument)\\r\\n        int index = safeStringToInt(argv[1]);\\r\\n\\r\\n        // Check if index is within valid range (between 1 and argc-1)\\r\\n        if (index < 1 || index >= argc) {\\r\\n            std::cerr << \"Error: Index out of range. Must be between 1 and \" << argc - 1 << \".\\n\";\\r\\n            return 1;\\r\\n        }\\r\\n\\r\\n        // Print the argument at the specified index\\r\\n        std::cout << \"Argument at index \" << index << \": \" << argv[index] << std::endl;\\r\\n\\r\\n        return 0; // Success\\r\\n    } catch (const std::exception& ex) {\\r\\n        // Handle any exceptions thrown during conversion or other operations\\r\\n        std::cerr << \"Error: \" << ex.what() << std::endl;\\r\\n        return 1; // Return error code\\r\\n    }\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. The function first prompts the user for an index value. Then the function checks if the index value is in bounds. If it is not the function returns -1. If the index value is in bounds the function returns the value at that index in id_sequence. The function returns 0 if the program runs.", "BP": ["Input Validation", "Bounds Checking", "Secure Coding Practices", "Error Handling"], "code": "#include <iostream>\\r\\n#include <limits>  // for std::numeric_limits\\r\\n\\r\\nconst int id_sequence[] = {10, 20, 30, 40, 50};  // Example array\\r\\nconst int id_size = sizeof(id_sequence) / sizeof(id_sequence[0]);  // Calculate size of array\\r\\n\\r\\nint getValueAtIndex() {\\r\\n    int index;\\r\\n\\r\\n    // Prompt user for input and perform input validation\\r\\n    std::cout << \"Enter an index: \";\\r\\n    \\r\\n    // Input validation for integer input\\r\\n    while (!(std::cin >> index)) {\\r\\n        std::cerr << \"Invalid input. Please enter a valid integer.\\n\";\\r\\n        // Clear the error flag on cin and ignore bad input\\r\\n        std::cin.clear();\\r\\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\\r\\n        std::cout << \"Enter an index: \";\\r\\n    }\\r\\n\\r\\n    // Bounds checking\\r\\n    if (index < 0 || index >= id_size) {\\r\\n        std::cerr << \"Error: Index out of bounds.\\n\";\\r\\n        return -1;\\r\\n    }\\r\\n\\r\\n    // Return the value at the specified index\\r\\n    return id_sequence[index];\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    int result = getValueAtIndex();\\r\\n\\r\\n    if (result == -1) {\\r\\n        std::cerr << \"Error encountered. Exiting program.\\n\";\\r\\n        return -1;  // Return -1 if there's an error\\r\\n    }\\r\\n\\r\\n    std::cout << \"Value at the specified index: \" << result << std::endl;\\r\\n\\r\\n    return 0;  // Return 0 if the program runs successfully\\r\\n}", "CWE": "CWE-125"}
{"text": "Generate C++ code for the following: The code takes an integer as input and returns the value at the index of the integer in the array. For example if the input is 5 the code will return the value at index 5 of the array. If the input is -1 the code will return -1. If the input is 10 the code will return -1. If the input is 0 the code will return the value at index 0 of the array.", "BP": ["Input Validation", "Bounds Checking", "Use of std::vector", "Error Handling", "Secure Data Types", "Avoiding Undefined Behavior"], "code": "#include <iostream>\\r\\n#include <vector>\\r\\n#include <limits>\\r\\n\\r\\n// Function to safely get an integer input from the user\\r\\nint getInput() {\\r\\n    int input;\\r\\n    while (true) {\\r\\n        std::cout << \"Enter an index: \";\\r\\n        std::cin >> input;\\r\\n\\r\\n        // Check if the input is a valid integer\\r\\n        if (std::cin.fail()) {\\r\\n            std::cin.clear();  // Clear the error state\\r\\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');  // Discard invalid input\\r\\n            std::cout << \"Invalid input. Please enter a valid integer.\\n\";\\r\\n        } else {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n    return input;\\r\\n}\\r\\n\\r\\n// Function to return the value at the specified index, or -1 for invalid input\\r\\nint getValueAtIndex(const std::vector<int>& arr, int index) {\\r\\n    if (index < 0 || index >= arr.size()) {\\r\\n        return -1;  // Return -1 if index is out of bounds\\r\\n    }\\r\\n    return arr[index];  // Return the value at the valid index\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    // Initialize a sample vector with some values\\r\\n    std::vector<int> myArray = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\\r\\n\\r\\n    // Get input from the user\\r\\n    int index = getInput();\\r\\n\\r\\n    // Check bounds and print the value or error\\r\\n    int result = getValueAtIndex(myArray, index);\\r\\n\\r\\n    if (result == -1) {\\r\\n        std::cout << \"Invalid index! Returning: \" << result << std::endl;\\r\\n    } else {\\r\\n        std::cout << \"Value at index \" << index << \": \" << result << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-125"}
{"text": "Generate C++ code for the following: The code takes in a number from the user and returns the value at that index in the array. If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Index Validation", "Use of std::vector", "Error Handling", "Consistent Data Types", "Encapsulation"], "code": "#include <iostream>\\r\\n#include <vector>\\r\\n#include <limits> // for numeric_limits\\r\\n\\r\\n// Class encapsulating the functionality\\r\\nclass ArrayHandler {\\r\\nprivate:\\r\\n    std::vector<int> data; // Encapsulated data member\\r\\n\\r\\npublic:\\r\\n    // Constructor to initialize the vector with some values\\r\\n    ArrayHandler() {\\r\\n        data = {10, 20, 30, 40, 50}; // Example data\\r\\n    }\\r\\n\\r\\n    // Function to safely get the value at a specific index\\r\\n    int getValueAtIndex(int index) {\\r\\n        if (index < 0 || index >= data.size()) {\\r\\n            std::cerr << \"Error: Index out of bounds.\\n\";\\r\\n            return -1;\\r\\n        }\\r\\n        return data[index];\\r\\n    }\\r\\n\\r\\n    // Function to take input from the user and validate it\\r\\n    int getValidatedInput() {\\r\\n        int index;\\r\\n        while (true) {\\r\\n            std::cout << \"Enter an index (0 to \" << data.size() - 1 << \"): \";\\r\\n            std::cin >> index;\\r\\n\\r\\n            // Input validation: Check if input is an integer\\r\\n            if (std::cin.fail()) {\\r\\n                std::cin.clear(); // Clear the error state\\r\\n                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // Ignore invalid input\\r\\n                std::cerr << \"Invalid input. Please enter a valid integer.\\n\";\\r\\n            } else {\\r\\n                break; // Valid input, exit the loop\\r\\n            }\\r\\n        }\\r\\n        return index;\\r\\n    }\\r\\n\\r\\n    // Function to handle the overall process\\r\\n    void handleInputAndOutput() {\\r\\n        int index = getValidatedInput();\\r\\n        int result = getValueAtIndex(index);\\r\\n\\r\\n        if (result != -1) {\\r\\n            std::cout << \"Value at index \" << index << \" is: \" << result << \"\\n\";\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nint main() {\\r\\n    ArrayHandler handler;\\r\\n    handler.handleInputAndOutput();\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-125"}
{"text": "Generate C++ code for the following: The code takes an integer as input and returns the value at the index of the integer in the array. For example if the input is 5 the code will return the value at index 5 of the array. If the input is out of bounds the code will return -1. For example if the input is 10 the code will return -1. ", "BP": ["Input Validation", "Bounds Checking", "Error Handling", "Secure Data Structures", "Secure Library Functions"], "code": "#include <iostream>\\r\\n#include <limits> // For input validation\\r\\n\\r\\n// Function to safely get an integer from user\\r\\nint getIntegerInput() {\\r\\n    int input;\\r\\n    while (true) {\\r\\n        std::cout << \"Enter an index: \";\\r\\n        std::cin >> input;\\r\\n        \\r\\n        // Input validation\\r\\n        if (std::cin.fail()) {\\r\\n            std::cin.clear(); // Clear the error flag\\r\\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // Discard invalid input\\r\\n            std::cout << \"Invalid input. Please enter an integer.\" << std::endl;\\r\\n        } else {\\r\\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // Clear extra input\\r\\n            return input;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// Function to return the value at the index if valid, else return -1\\r\\nint getValueAtIndex(const int arr[], size_t size, int index) {\\r\\n    // Bounds checking\\r\\n    if (index >= 0 && index < static_cast<int>(size)) {\\r\\n        return arr[index];\\r\\n    } else {\\r\\n        std::cerr << \"Error: Index out of bounds.\" << std::endl;\\r\\n        return -1; // Return -1 if index is out of bounds\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    // Example array\\r\\n    const int arr[] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\\r\\n    const size_t arraySize = sizeof(arr) / sizeof(arr[0]); // Get array size\\r\\n\\r\\n    // Get valid integer input\\r\\n    int index = getIntegerInput();\\r\\n\\r\\n    // Get the value at the input index or handle error\\r\\n    int value = getValueAtIndex(arr, arraySize, index);\\r\\n\\r\\n    // Display the result\\r\\n    if (value != -1) {\\r\\n        std::cout << \"Value at index \" << index << \" is: \" << value << std::endl;\\r\\n    } else {\\r\\n        std::cout << \"Invalid index provided.\" << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-125"}
{"text": "Generate C++ code for the following: The code reads in a value from the command line and adds an offset of 1000 to it. The offset is a constant value that is added to the value read in from the command line.", "BP": ["Input Validation", "Integer Overflow/Underflow Prevention", "Secure Coding Practices", "Error Handling"], "code": "#include <iostream>\\r\\n#include <limits>\\r\\n#include <cstdlib>\\r\\n#include <cerrno>\\r\\n#include <climits>\\r\\n\\r\\nconst int OFFSET = 1000;\\r\\n\\r\\nbool isInteger(const char* str, int& outValue) {\\r\\n    char* end;\\r\\n    errno = 0; // Reset errno before calling strtol\\r\\n    long value = std::strtol(str, &end, 10);\\r\\n\\r\\n    // Check for conversion errors\\r\\n    if (errno == ERANGE || value < INT_MIN || value > INT_MAX) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // Ensure entire string was converted and no extra characters exist\\r\\n    if (*end != '\\0') {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    outValue = static_cast<int>(value);\\r\\n    return true;\\r\\n}\\r\\n\\r\\nbool willAdditionOverflow(int a, int b) {\\r\\n    if (b > 0 && a > INT_MAX - b) {\\r\\n        return true; // Overflow\\r\\n    }\\r\\n    if (b < 0 && a < INT_MIN - b) {\\r\\n        return true; // Underflow\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <integer>\\n\";\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    int inputValue;\\r\\n    if (!isInteger(argv[1], inputValue)) {\\r\\n        std::cerr << \"Error: Invalid input. Please enter a valid integer.\\n\";\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    // Check for overflow/underflow when adding OFFSET\\r\\n    if (willAdditionOverflow(inputValue, OFFSET)) {\\r\\n        std::cerr << \"Error: Addition of \" << OFFSET << \" would result in overflow or underflow.\\n\";\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    int result = inputValue + OFFSET;\\r\\n\\r\\n    std::cout << \"Result: \" << result << std::endl;\\r\\n    return EXIT_SUCCESS;\\r\\n}", "CWE": "CWE-190"}
{"text": "Generate C++ code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": ["Input Validation", "Secure Input Conversion", "Error Handling", "Secure Coding Practices"], "code": "#include <iostream>\\r\\n#include <cstdlib>   // For std::strtol\\r\\n#include <cerrno>    // For errno\\r\\n#include <climits>   // For INT_MAX and INT_MIN\\r\\n\\r\\nint main(int argc, char *argv[]) {\\r\\n    // Ensure at least one argument is passed (the program name is counted as an argument)\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Error: Please provide exactly one integer argument.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    char *endptr = nullptr;\\r\\n    errno = 0;  // Reset errno before calling strtol\\r\\n\\r\\n    // Attempt to convert the input string to a long integer\\r\\n    long value = std::strtol(argv[1], &endptr, 10);\\r\\n\\r\\n    // Check for conversion errors\\r\\n    if (errno == ERANGE || value > INT_MAX || value < INT_MIN) {\\r\\n        std::cerr << \"Error: The value is out of range.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    if (endptr == argv[1] || *endptr != '\\0') {\\r\\n        std::cerr << \"Error: Invalid input. Please enter a valid integer.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Now that the input is validated, we can safely add 1000 to it\\r\\n    int result = static_cast<int>(value) + 1000;\\r\\n\\r\\n    // Output the result\\r\\n    std::cout << \"Result: \" << result << std::endl;\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-190"}
{"text": "Generate C++ code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP": ["Input Validation", "Data Type Conversion", "Error Handling", "Integer Overflow/Underflow Check", "Separation of Concerns", "Secure Function Usage"], "code": "#include <iostream>\\r\\n#include <stdexcept>\\r\\n#include <climits> // for INT_MAX, INT_MIN\\r\\n#include <cstdlib> // for strtol\\r\\n#include <cerrno>  // for errno\\r\\n\\r\\n// Function to safely convert string to integer\\r\\nlong safeStringToInt(const char* str) {\\r\\n    char* end;\\r\\n    errno = 0; // reset errno before the conversion\\r\\n    long value = std::strtol(str, &end, 10);\\r\\n\\r\\n    // Check for conversion errors\\r\\n    if (errno == ERANGE || value > INT_MAX || value < INT_MIN) {\\r\\n        throw std::out_of_range(\"Integer overflow or underflow\");\\r\\n    }\\r\\n    if (*end != '\\0') {\\r\\n        throw std::invalid_argument(\"Invalid input: Not a valid integer\");\\r\\n    }\\r\\n\\r\\n    return value;\\r\\n}\\r\\n\\r\\n// Function to safely add 1000 and check for overflow/underflow\\r\\nint safeAdd(int value, int to_add) {\\r\\n    if (value > 0 && to_add > INT_MAX - value) {\\r\\n        throw std::overflow_error(\"Integer overflow\");\\r\\n    }\\r\\n    if (value < 0 && to_add < INT_MIN - value) {\\r\\n        throw std::underflow_error(\"Integer underflow\");\\r\\n    }\\r\\n    return value + to_add;\\r\\n}\\r\\n\\r\\n// Main function\\r\\nint main(int argc, char* argv[]) {\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <integer>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        // Convert input string to integer safely\\r\\n        int value = static_cast<int>(safeStringToInt(argv[1]));\\r\\n\\r\\n        // Add 1000 safely, checking for overflow/underflow\\r\\n        int result = safeAdd(value, 1000);\\r\\n\\r\\n        std::cout << \"Result: \" << result << std::endl;\\r\\n    } catch (const std::exception& e) {\\r\\n        // Catch any exceptions and display error message\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-190"}
{"text": "Generate C++ code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a page with the username; email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": ["Session Management", "Password Hashing", "Input Validation", "Input Sanitization", "Error Handling", "Secure Transmission", "Access Control", "Secure Coding Practices", "User Authentication and Authorization", "Logging and Monitoring", "Secure Configuration"], "code": "#include \"crow.h\"\\r\\n#include <openssl/sha.h>\\r\\n#include <openssl/rand.h>\\r\\n#include <unordered_map>\\r\\n#include <regex>\\r\\n#include <string>\\r\\n#include <iostream>\\r\\n\\r\\n// A simple in-memory session storage (for demo purposes)\\r\\nstd::unordered_map<std::string, crow::json::wvalue> session_store;\\r\\n\\r\\n// Dummy database for users (in real-world, use proper database storage)\\r\\nstruct User {\\r\\n    std::string username;\\r\\n    std::string email;\\r\\n    std::string hashed_password;\\r\\n    std::string ssn;\\r\\n};\\r\\n\\r\\nstd::unordered_map<std::string, User> user_db = {\\r\\n    {\"john_doe\", {\"john_doe\", \"john@example.com\", \"5e88489f\", \"123456789\"}}\\r\\n};\\r\\n\\r\\n// Function to hash passwords using SHA-256\\r\\nstd::string hash_password(const std::string& password) {\\r\\n    unsigned char hash[SHA256_DIGEST_LENGTH];\\r\\n    SHA256_CTX sha256;\\r\\n    SHA256_Init(&sha256);\\r\\n    SHA256_Update(&sha256, password.c_str(), password.size());\\r\\n    SHA256_Final(hash, &sha256);\\r\\n\\r\\n    char buffer[65];\\r\\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {\\r\\n        sprintf(buffer + (i * 2), \"%02x\", hash[i]);\\r\\n    }\\r\\n    buffer[64] = 0;\\r\\n    return std::string(buffer);\\r\\n}\\r\\n\\r\\n// Input validation function\\r\\nbool validate_input(const std::string& username, const std::string& password) {\\r\\n    // Validate using regex (e.g., alphanumeric for username, strong password)\\r\\n    std::regex username_pattern(\"^[a-zA-Z0-9_]{3,16}$\");\\r\\n    std::regex password_pattern(\"^(?=.*[A-Za-z])(?=.*\\\\d)[A-Za-z\\\\d]{8,}$\");\\r\\n\\r\\n    return std::regex_match(username, username_pattern) &&\\r\\n           std::regex_match(password, password_pattern);\\r\\n}\\r\\n\\r\\n// Sanitize input to prevent XSS attacks\\r\\nstd::string sanitize_input(const std::string& input) {\\r\\n    std::string sanitized = input;\\r\\n    std::replace(sanitized.begin(), sanitized.end(), '<', '[');\\r\\n    std::replace(sanitized.begin(), sanitized.end(), '>', ']');\\r\\n    return sanitized;\\r\\n}\\r\\n\\r\\n// Function to authenticate user\\r\\nbool authenticate(const std::string& username, const std::string& password) {\\r\\n    auto it = user_db.find(username);\\r\\n    if (it != user_db.end()) {\\r\\n        std::string hashed_password = hash_password(password);\\r\\n        return it->second.hashed_password == hashed_password;\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\n\\r\\n// Middleware to check if the user is authenticated\\r\\nbool is_authenticated(const std::string& session_id) {\\r\\n    return session_store.find(session_id) != session_store.end();\\r\\n}\\r\\n\\r\\n// Error page handler\\r\\ncrow::response error_page(const std::string& message) {\\r\\n    crow::json::wvalue error_response;\\r\\n    error_response[\"error\"] = message;\\r\\n    return crow::response(400, error_response);\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    crow::SimpleApp app;\\r\\n\\r\\n    // Secure transmission (HTTPS should be configured properly in production)\\r\\n    CROW_ROUTE(app, \"/login\")\\r\\n        .methods(\"POST\"_method)\\r\\n    ([&](const crow::request& req) {\\r\\n        auto body = crow::json::load(req.body);\\r\\n        if (!body) {\\r\\n            return error_page(\"Invalid input\");\\r\\n        }\\r\\n\\r\\n        std::string username = sanitize_input(body[\"username\"].s());\\r\\n        std::string password = sanitize_input(body[\"password\"].s());\\r\\n\\r\\n        // Validate input\\r\\n        if (!validate_input(username, password)) {\\r\\n            return error_page(\"Invalid username or password format.\");\\r\\n        }\\r\\n\\r\\n        // Authenticate user\\r\\n        if (!authenticate(username, password)) {\\r\\n            return error_page(\"Authentication failed.\");\\r\\n        }\\r\\n\\r\\n        // Create a new session (for demo, session id is just random)\\r\\n        std::string session_id = crow::utility::random_string(32);\\r\\n\\r\\n        session_store[session_id] = {{\"username\", username}, {\"email\", user_db[username].email}, {\"ssn\", user_db[username].ssn}};\\r\\n\\r\\n        // Return the session ID as a cookie\\r\\n        crow::response res;\\r\\n        res.set_header(\"Set-Cookie\", \"session_id=\" + session_id + \"; HttpOnly; Secure; SameSite=Strict;\");\\r\\n        res.code = 200;\\r\\n        res.body = \"Login successful\";\\r\\n        return res;\\r\\n    });\\r\\n\\r\\n    // Secure route to access user info\\r\\n    CROW_ROUTE(app, \"/info\").methods(\"GET\"_method)([](const crow::request& req) {\\r\\n        std::string session_id = req.get_header_value(\"Cookie\");\\r\\n\\r\\n        // Check if the session is valid\\r\\n        if (session_id.empty() || !is_authenticated(session_id)) {\\r\\n            return error_page(\"Unauthorized access. Please log in.\");\\r\\n        }\\r\\n\\r\\n        auto session_data = session_store[session_id];\\r\\n        std::string username = session_data[\"username\"].s();\\r\\n        std::string email = session_data[\"email\"].s();\\r\\n        std::string ssn = session_data[\"ssn\"].s();\\r\\n\\r\\n        // Mask SSN (only showing last 4 digits)\\r\\n        std::string masked_ssn = \"XXX-XX-\" + ssn.substr(ssn.length() - 4);\\r\\n\\r\\n        crow::json::wvalue result;\\r\\n        result[\"username\"] = sanitize_input(username);\\r\\n        result[\"email\"] = sanitize_input(email);\\r\\n        result[\"ssn\"] = masked_ssn;\\r\\n\\r\\n        return crow::response(200, result);\\r\\n    });\\r\\n\\r\\n    // Secure server settings (SSL/TLS)\\r\\n    // NOTE: In production, configure actual SSL certificates\\r\\n    app.bindaddr(\"0.0.0.0\").port(18080).run();\\r\\n}", "CWE": "CWE-200"}
{"text": "Generate C++ code for the following: The with statement is used to wrap the execution of a block with methods defined by a context manager. The tarfile module makes it possible to read and write tar archives including those using gzip or bz2 compression. The open() function opens and returns a file handle that can be used to read or write a file in the usual way.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Exception Management", "Secure Memory Management"], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <stdexcept>\\r\\n#include <memory>\\r\\n#include <regex>\\r\\n\\r\\n// Class to manage file opening and closing using RAII\\r\\nclass FileManager {\\r\\npublic:\\r\\n    FileManager(const std::string& filename) {\\r\\n        validateFilename(filename); // Validate the filename for security\\r\\n\\r\\n        file.open(filename, std::ios::in | std::ios::binary);  // Open file in binary read mode\\r\\n\\r\\n        if (!file.is_open()) {\\r\\n            throw std::runtime_error(\"Error: Could not open the file.\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ~FileManager() {\\r\\n        if (file.is_open()) {\\r\\n            file.close();  // Automatically close the file\\r\\n        }\\r\\n    }\\r\\n\\r\\n    std::ifstream& getFile() {\\r\\n        return file;\\r\\n    }\\r\\n\\r\\nprivate:\\r\\n    std::ifstream file;\\r\\n\\r\\n    void validateFilename(const std::string& filename) {\\r\\n        // Ensure the filename only contains valid characters\\r\\n        std::regex validPattern(\"^[a-zA-Z0-9_\\\\-\\\\.]+$\");\\r\\n        if (!std::regex_match(filename, validPattern)) {\\r\\n            throw std::invalid_argument(\"Error: Invalid filename provided.\");\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\n// Function to read and process the file\\r\\nvoid processFile(const std::string& filename) {\\r\\n    try {\\r\\n        FileManager fileManager(filename);  // RAII will handle file opening/closing\\r\\n        std::ifstream& file = fileManager.getFile();\\r\\n\\r\\n        // Secure memory management using unique_ptr for buffer\\r\\n        std::unique_ptr<char[]> buffer(new char[1024]);\\r\\n        while (file.read(buffer.get(), 1024)) {\\r\\n            // Simulate processing the file (e.g., reading the tar contents)\\r\\n            std::cout << \"Processing 1024 bytes of data...\\n\";\\r\\n        }\\r\\n\\r\\n        if (file.eof()) {\\r\\n            std::cout << \"Finished processing the file.\\n\";\\r\\n        } else {\\r\\n            throw std::runtime_error(\"Error: File read interrupted.\");\\r\\n        }\\r\\n\\r\\n    } catch (const std::invalid_argument& e) {\\r\\n        std::cerr << e.what() << '\\n';\\r\\n    } catch (const std::runtime_error& e) {\\r\\n        std::cerr << \"Runtime error: \" << e.what() << '\\n';\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << \"An unexpected error occurred: \" << e.what() << '\\n';\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::string filename;\\r\\n    \\r\\n    // Input validation\\r\\n    std::cout << \"Enter the file name: \";\\r\\n    std::getline(std::cin, filename);\\r\\n\\r\\n    try {\\r\\n        processFile(filename);\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << \"Failed to process the file: \" << e.what() << '\\n';\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-22"}
{"text": "Generate C++ code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database. If it is it will redirect the user to the user_page. If it is not it will return.", "BP": ["Password Hashing", "Database Simulation", "Separation of Concerns", "Input Validation", "Error Handling", "Secure Libraries", "Session Management", "Input Sanitization", "Secure Communication", "Password Policy", "Error Logging and Monitoring"], "code": "#include <iostream>\\r\\n#include <unordered_map>\\r\\n#include <httplib.h>\\r\\n#include <bcrypt.h>\\r\\n#include <nlohmann/json.hpp>\\r\\n\\r\\n// Simulating a database for simplicity\\r\\nstd::unordered_map<std::string, std::string> user_db = {\\r\\n    {\"user1\", bcrypt::generateHash(\"SecurePass123\")},\\r\\n    {\"user2\", bcrypt::generateHash(\"AnotherPass456\")}\\r\\n};\\r\\n\\r\\n// Simulating session management\\r\\nstd::unordered_map<std::string, std::string> session_db;\\r\\n\\r\\n// Function to generate a simple HTML form for login\\r\\nstd::string login_form() {\\r\\n    return R\"(\\r\\n    <html>\\r\\n        <body>\\r\\n            <h2>Login Form</h2>\\r\\n            <form method=\"POST\" action=\"/do_login\">\\r\\n                Username: <input type=\"text\" name=\"username\"><br>\\r\\n                Password: <input type=\"password\" name=\"password\"><br>\\r\\n                <input type=\"submit\" value=\"Login\">\\r\\n            </form>\\r\\n        </body>\\r\\n    </html>\\r\\n    )\";\\r\\n}\\r\\n\\r\\n// Function to validate input (basic sanitization)\\r\\nbool validate_input(const std::string& username, const std::string& password) {\\r\\n    return !username.empty() && !password.empty() && username.size() <= 50 && password.size() <= 50;\\r\\n}\\r\\n\\r\\n// Function to generate a random session token (simple simulation)\\r\\nstd::string generate_session_token() {\\r\\n    return \"session_token_\" + std::to_string(rand() % 100000);\\r\\n}\\r\\n\\r\\n// Error logging (simple console-based logging)\\r\\nvoid log_error(const std::string& error_message) {\\r\\n    std::cerr << \"[ERROR] \" << error_message << std::endl;\\r\\n}\\r\\n\\r\\n// Login page handler (GET request)\\r\\nvoid login_page(const httplib::Request& req, httplib::Response& res) {\\r\\n    res.set_content(login_form(), \"text/html\");\\r\\n}\\r\\n\\r\\n// Login processing (POST request)\\r\\nvoid do_login(const httplib::Request& req, httplib::Response& res) {\\r\\n    if (req.has_param(\"username\") && req.has_param(\"password\")) {\\r\\n        std::string username = req.get_param_value(\"username\");\\r\\n        std::string password = req.get_param_value(\"password\");\\r\\n\\r\\n        // Input validation and sanitization\\r\\n        if (!validate_input(username, password)) {\\r\\n            log_error(\"Invalid input data\");\\r\\n            res.set_content(\"Invalid input. Please try again.\", \"text/plain\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Check if user exists in the database\\r\\n        if (user_db.find(username) != user_db.end()) {\\r\\n            std::string stored_hash = user_db[username];\\r\\n\\r\\n            // Check if the password matches using bcrypt\\r\\n            if (bcrypt::validatePassword(password, stored_hash)) {\\r\\n                std::string session_token = generate_session_token();\\r\\n                session_db[session_token] = username;\\r\\n\\r\\n                // Redirect to the user page\\r\\n                res.set_redirect(\"/user_page?session=\" + session_token);\\r\\n            } else {\\r\\n                log_error(\"Incorrect password attempt for user: \" + username);\\r\\n                res.set_content(\"Invalid username or password.\", \"text/plain\");\\r\\n            }\\r\\n        } else {\\r\\n            log_error(\"User not found: \" + username);\\r\\n            res.set_content(\"Invalid username or password.\", \"text/plain\");\\r\\n        }\\r\\n    } else {\\r\\n        log_error(\"Username or password not provided\");\\r\\n        res.set_content(\"Username and password are required.\", \"text/plain\");\\r\\n    }\\r\\n}\\r\\n\\r\\n// Simulated user page\\r\\nvoid user_page(const httplib::Request& req, httplib::Response& res) {\\r\\n    if (req.has_param(\"session\")) {\\r\\n        std::string session_token = req.get_param_value(\"session\");\\r\\n\\r\\n        // Check if session is valid\\r\\n        if (session_db.find(session_token) != session_db.end()) {\\r\\n            std::string username = session_db[session_token];\\r\\n            res.set_content(\"Welcome, \" + username + \"!\", \"text/plain\");\\r\\n        } else {\\r\\n            res.set_content(\"Invalid session. Please login again.\", \"text/plain\");\\r\\n        }\\r\\n    } else {\\r\\n        res.set_content(\"Session not found. Please login.\", \"text/plain\");\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    httplib::Server server;\\r\\n\\r\\n    // GET request to serve login page\\r\\n    server.Get(\"/login\", login_page);\\r\\n\\r\\n    // POST request to handle login\\r\\n    server.Post(\"/do_login\", do_login);\\r\\n\\r\\n    // Simulated user page after successful login\\r\\n    server.Get(\"/user_page\", user_page);\\r\\n\\r\\n    std::cout << \"Server starting at http://localhost:8080\\n\";\\r\\n    server.listen(\"localhost\", 8080);\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-306"}
{"text": "Generate C++ code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate. The program allocates a buffer of the specified size. The program prints the contents of the buffer. The program exits.", "BP": ["Input Validation", "Secure Memory Allocation and Deallocation", "Buffer Overflow Prevention", "Error Handling", "Secure Coding Practices"], "code": "#include <iostream>\\r\\n#include <cstring>  // For memset\\r\\n#include <cstdlib>  // For std::malloc, std::free, std::atoi\\r\\n#include <limits>   // For std::numeric_limits\\r\\n#include <stdexcept> // For std::invalid_argument\\r\\n\\r\\n// Constants for input validation\\r\\nconstexpr size_t MAX_BUFFER_SIZE = 1024 * 1024; // 1 MB Max buffer size\\r\\n\\r\\n// Function to print the buffer contents\\r\\nvoid printBuffer(const char* buffer, size_t size) {\\r\\n    if (!buffer) {\\r\\n        std::cerr << \"Error: Buffer is null!\" << std::endl;\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    std::cout << \"Buffer contents (first 100 bytes or up to buffer size):\" << std::endl;\\r\\n    for (size_t i = 0; i < std::min(size, size_t(100)); ++i) {\\r\\n        std::cout << static_cast<int>(buffer[i]) << \" \";\\r\\n    }\\r\\n    std::cout << std::endl;\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Input validation: Check if buffer size is provided\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <buffer_size>\" << std::endl;\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    // Secure input parsing: Validate the buffer size\\r\\n    size_t bufferSize = 0;\\r\\n    try {\\r\\n        long inputSize = std::stol(argv[1]);\\r\\n\\r\\n        // Check if input size is within a valid range\\r\\n        if (inputSize <= 0 || inputSize > std::numeric_limits<size_t>::max() || inputSize > MAX_BUFFER_SIZE) {\\r\\n            throw std::invalid_argument(\"Invalid buffer size\");\\r\\n        }\\r\\n\\r\\n        bufferSize = static_cast<size_t>(inputSize);\\r\\n    } catch (const std::invalid_argument& e) {\\r\\n        std::cerr << \"Error: Invalid buffer size argument. Must be a positive integer <= \" << MAX_BUFFER_SIZE << \" bytes.\" << std::endl;\\r\\n        return EXIT_FAILURE;\\r\\n    } catch (const std::out_of_range& e) {\\r\\n        std::cerr << \"Error: Buffer size is too large.\" << std::endl;\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    // Secure memory allocation\\r\\n    char* buffer = static_cast<char*>(std::malloc(bufferSize));\\r\\n    if (!buffer) {\\r\\n        std::cerr << \"Error: Memory allocation failed.\" << std::endl;\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    // Initialize the buffer to zeros (secure memory handling)\\r\\n    std::memset(buffer, 0, bufferSize);\\r\\n\\r\\n    // Print buffer contents\\r\\n    printBuffer(buffer, bufferSize);\\r\\n\\r\\n    // Secure memory deallocation\\r\\n    std::free(buffer);\\r\\n    buffer = nullptr;\\r\\n\\r\\n    return EXIT_SUCCESS;\\r\\n}", "CWE": "CWE-416"}
{"text": "Generate C++ code for the following: The code reads the contents of a file into a buffer.It then calculates the checksum of the buffer. If the checksum is 0 the buffer is empty. The number of bytes read and the checksum are saved to a file.", "BP": ["Input Validation", "File I/O Handling", "Buffer Management", "Checksum Calculation", "Secure Output", "Error Handling", "Secure Coding Practices"], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <vector>\\r\\n#include <cstdint>\\r\\n#include <cstring>\\r\\n#include <stdexcept>\\r\\n#include <iomanip> // For std::setw and std::setfill\\r\\n\\r\\n// Function to calculate checksum (simple sum of bytes modulo 256)\\r\\nuint8_t calculateChecksum(const std::vector<uint8_t>& buffer) {\\r\\n    uint32_t checksum = 0;\\r\\n    for (uint8_t byte : buffer) {\\r\\n        checksum += byte;\\r\\n    }\\r\\n    return static_cast<uint8_t>(checksum % 256);\\r\\n}\\r\\n\\r\\n// Function to read file into buffer\\r\\nstd::vector<uint8_t> readFileIntoBuffer(const std::string& filename) {\\r\\n    // Open the file in binary mode\\r\\n    std::ifstream inputFile(filename, std::ios::binary);\\r\\n    if (!inputFile) {\\r\\n        throw std::runtime_error(\"Error: Could not open file for reading.\");\\r\\n    }\\r\\n\\r\\n    // Seek to the end to get file size\\r\\n    inputFile.seekg(0, std::ios::end);\\r\\n    std::streampos fileSize = inputFile.tellg();\\r\\n    if (fileSize <= 0) {\\r\\n        throw std::runtime_error(\"Error: File is empty or unreadable.\");\\r\\n    }\\r\\n\\r\\n    // Resize buffer to file size\\r\\n    std::vector<uint8_t> buffer(fileSize);\\r\\n\\r\\n    // Seek back to the beginning and read the file into buffer\\r\\n    inputFile.seekg(0, std::ios::beg);\\r\\n    inputFile.read(reinterpret_cast<char*>(buffer.data()), buffer.size());\\r\\n\\r\\n    if (!inputFile) {\\r\\n        throw std::runtime_error(\"Error: Failed to read the entire file.\");\\r\\n    }\\r\\n\\r\\n    inputFile.close();\\r\\n    return buffer;\\r\\n}\\r\\n\\r\\n// Function to save checksum and bytes read to output file\\r\\nvoid saveResultsToFile(const std::string& outputFilename, size_t bytesRead, uint8_t checksum) {\\r\\n    std::ofstream outputFile(outputFilename, std::ios::out | std::ios::trunc);\\r\\n    if (!outputFile) {\\r\\n        throw std::runtime_error(\"Error: Could not open file for writing.\");\\r\\n    }\\r\\n\\r\\n    // Output number of bytes read and checksum in a secure format\\r\\n    outputFile << \"Bytes Read: \" << bytesRead << \"\\n\";\\r\\n    outputFile << \"Checksum: \" << std::setw(2) << std::setfill('0') << std::hex << static_cast<int>(checksum) << \"\\n\";\\r\\n\\r\\n    if (!outputFile) {\\r\\n        throw std::runtime_error(\"Error: Failed to write to output file.\");\\r\\n    }\\r\\n\\r\\n    outputFile.close();\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    if (argc != 3) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <input_file> <output_file>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    std::string inputFilename = argv[1];\\r\\n    std::string outputFilename = argv[2];\\r\\n\\r\\n    try {\\r\\n        // Read file into buffer\\r\\n        std::vector<uint8_t> buffer = readFileIntoBuffer(inputFilename);\\r\\n\\r\\n        // Calculate checksum\\r\\n        uint8_t checksum = calculateChecksum(buffer);\\r\\n\\r\\n        // If checksum is 0, buffer is considered empty\\r\\n        if (checksum == 0) {\\r\\n            std::cerr << \"Warning: Checksum is 0. Buffer may be empty or only contain null bytes.\" << std::endl;\\r\\n        }\\r\\n\\r\\n        // Save results to the output file\\r\\n        saveResultsToFile(outputFilename, buffer.size(), checksum);\\r\\n\\r\\n        std::cout << \"Processing complete. Results saved to \" << outputFilename << std::endl;\\r\\n    }\\r\\n    catch (const std::exception& e) {\\r\\n        std::cerr << e.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-416"}
{"text": "Generate C++ code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 then the buffer is empty. The number of bytes read and the checksum are saved to another file.", "BP": ["Error Handling", "Input Validation", "Memory Management", "Cryptographic Security", "Secure File I/O", "Secure Coding Practices"], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <vector>\\r\\n#include <openssl/sha.h>  // For SHA-256 checksum\\r\\n#include <iomanip>        // For std::setw and std::setfill\\r\\n#include <sstream>        // For converting SHA-256 to string\\r\\n#include <cstring>        // For std::memset\\r\\n\\r\\n// Function to calculate SHA-256 checksum of the buffer\\r\\nstd::string calculateSHA256(const std::vector<unsigned char>& buffer) {\\r\\n    unsigned char hash[SHA256_DIGEST_LENGTH];\\r\\n    SHA256_CTX sha256;\\r\\n    if (!SHA256_Init(&sha256)) {\\r\\n        throw std::runtime_error(\"Failed to initialize SHA-256 context\");\\r\\n    }\\r\\n    if (!SHA256_Update(&sha256, buffer.data(), buffer.size())) {\\r\\n        throw std::runtime_error(\"Failed to update SHA-256 hash\");\\r\\n    }\\r\\n    if (!SHA256_Final(hash, &sha256)) {\\r\\n        throw std::runtime_error(\"Failed to finalize SHA-256 hash\");\\r\\n    }\\r\\n\\r\\n    // Convert the hash to a hex string\\r\\n    std::stringstream ss;\\r\\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\\r\\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\\r\\n    }\\r\\n    return ss.str();\\r\\n}\\r\\n\\r\\n// Function to securely read file contents into a buffer\\r\\nstd::vector<unsigned char> readFile(const std::string& filePath) {\\r\\n    std::ifstream inputFile(filePath, std::ios::binary);\\r\\n    if (!inputFile.is_open()) {\\r\\n        throw std::runtime_error(\"Failed to open input file: \" + filePath);\\r\\n    }\\r\\n\\r\\n    // Get the file size securely\\r\\n    inputFile.seekg(0, std::ios::end);\\r\\n    std::streamsize fileSize = inputFile.tellg();\\r\\n    if (fileSize < 0) {\\r\\n        throw std::runtime_error(\"Failed to get the file size\");\\r\\n    }\\r\\n    inputFile.seekg(0, std::ios::beg);\\r\\n\\r\\n    if (fileSize == 0) {\\r\\n        std::cerr << \"Warning: Input file is empty.\" << std::endl;\\r\\n    }\\r\\n\\r\\n    // Read the file into a buffer\\r\\n    std::vector<unsigned char> buffer(static_cast<size_t>(fileSize));\\r\\n    if (!inputFile.read(reinterpret_cast<char*>(buffer.data()), buffer.size())) {\\r\\n        throw std::runtime_error(\"Failed to read input file\");\\r\\n    }\\r\\n\\r\\n    inputFile.close();\\r\\n    return buffer;\\r\\n}\\r\\n\\r\\n// Function to securely write the number of bytes and checksum to another file\\r\\nvoid writeOutputFile(const std::string& outputPath, size_t bytesRead, const std::string& checksum) {\\r\\n    std::ofstream outputFile(outputPath, std::ios::binary);\\r\\n    if (!outputFile.is_open()) {\\r\\n        throw std::runtime_error(\"Failed to open output file: \" + outputPath);\\r\\n    }\\r\\n\\r\\n    outputFile << \"Bytes Read: \" << bytesRead << \"\\n\";\\r\\n    outputFile << \"Checksum (SHA-256): \" << checksum << \"\\n\";\\r\\n\\r\\n    outputFile.close();\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    try {\\r\\n        std::string inputFilePath = \"input.txt\";\\r\\n        std::string outputFilePath = \"output.txt\";\\r\\n\\r\\n        // Read the file content securely\\r\\n        std::vector<unsigned char> buffer = readFile(inputFilePath);\\r\\n        size_t bytesRead = buffer.size();\\r\\n\\r\\n        // If the buffer is empty, checksum will be a string of zeros\\r\\n        std::string checksum;\\r\\n        if (bytesRead == 0) {\\r\\n            checksum = std::string(SHA256_DIGEST_LENGTH * 2, '0');  // Empty checksum (64 zeros)\\r\\n        } else {\\r\\n            checksum = calculateSHA256(buffer);\\r\\n        }\\r\\n\\r\\n        // Save the results to an output file\\r\\n        writeOutputFile(outputFilePath, bytesRead, checksum);\\r\\n\\r\\n        std::cout << \"Operation completed successfully.\" << std::endl;\\r\\n\\r\\n    } catch (const std::exception& ex) {\\r\\n        std::cerr << \"Error: \" << ex.what() << std::endl;\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    return EXIT_SUCCESS;\\r\\n}", "CWE": "CWE-416"}
{"text": "Generate C++ code for the following: There is a form in an html page that allows the user to upload a pdf file. There is a web server that is running on the user's localhost. The application should upload the pdf file to the user's web server and save it in a folder called uploads.", "BP": ["Input Validation", "Path Traversal Protection", "File I/O Security", "Sanitize Filename", "Logging and Monitoring", "Secure Storage and Permissions", "Input Sanitization", "Secure Communication"], "code": "#include <boost/beast.hpp>\\r\\n#include <boost/filesystem.hpp>\\r\\n#include <boost/algorithm/string.hpp>\\r\\n#include <fstream>\\r\\n#include <iostream>\\r\\n#include <regex>\\r\\n#include <string>\\r\\n\\r\\n// Namespace declarations for convenience\\r\\nnamespace beast = boost::beast;\\r\\nnamespace http = beast::http;\\r\\nnamespace fs = boost::filesystem;\\r\\nusing tcp = boost::asio::ip::tcp;\\r\\n\\r\\n// Function to sanitize the file name (remove path traversal characters)\\r\\nstd::string sanitize_filename(const std::string& filename) {\\r\\n    // Remove potentially dangerous characters (like ../ or backslashes)\\r\\n    std::string sanitized = filename;\\r\\n    sanitized = std::regex_replace(sanitized, std::regex(\"[^a-zA-Z0-9._-]\"), \"_\");\\r\\n    return sanitized;\\r\\n}\\r\\n\\r\\n// Function to check if the uploaded file is a PDF\\r\\nbool is_valid_pdf(const std::string& file_path) {\\r\\n    std::ifstream file(file_path, std::ios::binary);\\r\\n    if (file) {\\r\\n        char buffer[4];\\r\\n        file.read(buffer, 4);\\r\\n        // Check if the first 4 bytes are \"%PDF\"\\r\\n        return std::memcmp(buffer, \"%PDF\", 4) == 0;\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\n\\r\\n// Simple logger for monitoring and logging events\\r\\nvoid log_event(const std::string& message) {\\r\\n    std::ofstream log_file(\"server.log\", std::ios_base::app);\\r\\n    log_file << message << std::endl;\\r\\n}\\r\\n\\r\\n// HTTP POST request handler for file uploads\\r\\nvoid handle_upload(http::request<http::string_body>& req, http::response<http::string_body>& res) {\\r\\n    if (req.method() != http::verb::post) {\\r\\n        res.result(http::status::method_not_allowed);\\r\\n        res.body() = \"Method Not Allowed\";\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    std::string body = req.body();\\r\\n\\r\\n    // Simple parsing of multipart form-data to extract the uploaded file\\r\\n    size_t file_start = body.find(\"filename=\");\\r\\n    if (file_start == std::string::npos) {\\r\\n        res.result(http::status::bad_request);\\r\\n        res.body() = \"Invalid Request: No file found\";\\r\\n        log_event(\"Failed upload attempt: No file found\");\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    size_t file_end = body.find(\"\\r\\n\", file_start);\\r\\n    std::string original_filename = body.substr(file_start + 10, file_end - file_start - 11);\\r\\n\\r\\n    // Sanitize the filename\\r\\n    std::string sanitized_filename = sanitize_filename(original_filename);\\r\\n\\r\\n    // Path traversal protection: Ensure the file is saved in the 'uploads' folder\\r\\n    fs::path upload_dir = fs::path(\"uploads\");\\r\\n    fs::path file_path = upload_dir / sanitized_filename;\\r\\n\\r\\n    // Ensure the upload directory exists\\r\\n    if (!fs::exists(upload_dir)) {\\r\\n        fs::create_directory(upload_dir);\\r\\n    }\\r\\n\\r\\n    // Write the file to the uploads folder\\r\\n    std::ofstream outfile(file_path.string(), std::ios::binary);\\r\\n    if (!outfile) {\\r\\n        res.result(http::status::internal_server_error);\\r\\n        res.body() = \"Server Error: Unable to save file\";\\r\\n        log_event(\"Failed to open file for writing: \" + file_path.string());\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    size_t file_content_start = body.find(\"\\r\\n\\r\\n\", file_end) + 4;\\r\\n    size_t file_content_end = body.find(\"--\", file_content_start);\\r\\n    outfile.write(body.data() + file_content_start, file_content_end - file_content_start);\\r\\n    outfile.close();\\r\\n\\r\\n    // Validate if the uploaded file is a valid PDF\\r\\n    if (!is_valid_pdf(file_path.string())) {\\r\\n        fs::remove(file_path);  // Remove the invalid file\\r\\n        res.result(http::status::unsupported_media_type);\\r\\n        res.body() = \"Error: Uploaded file is not a valid PDF\";\\r\\n        log_event(\"Invalid PDF uploaded: \" + file_path.string());\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // Set secure permissions (read/write only for the owner)\\r\\n#ifdef _WIN32\\r\\n    _chmod(file_path.string().c_str(), _S_IREAD | _S_IWRITE);\\r\\n#else\\r\\n    chmod(file_path.string().c_str(), S_IRUSR | S_IWUSR);\\r\\n#endif\\r\\n\\r\\n    // Log successful upload\\r\\n    log_event(\"File uploaded successfully: \" + sanitized_filename);\\r\\n\\r\\n    // Response to the client\\r\\n    res.result(http::status::ok);\\r\\n    res.body() = \"File uploaded successfully: \" + sanitized_filename;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    try {\\r\\n        boost::asio::io_context ioc;\\r\\n        tcp::acceptor acceptor(ioc, tcp::endpoint(tcp::v4(), 8080));\\r\\n\\r\\n        log_event(\"Server started on port 8080\");\\r\\n\\r\\n        for (;;) {\\r\\n            tcp::socket socket(ioc);\\r\\n            acceptor.accept(socket);\\r\\n\\r\\n            // Read the request\\r\\n            beast::flat_buffer buffer;\\r\\n            http::request<http::string_body> req;\\r\\n            http::read(socket, buffer, req);\\r\\n\\r\\n            // Create response object\\r\\n            http::response<http::string_body> res{http::status::ok, req.version()};\\r\\n            res.set(http::field::server, \"PDF Uploader\");\\r\\n            res.set(http::field::content_type, \"text/plain\");\\r\\n\\r\\n            // Handle the file upload\\r\\n            handle_upload(req, res);\\r\\n\\r\\n            // Write the response\\r\\n            http::write(socket, res);\\r\\n\\r\\n            socket.shutdown(tcp::socket::shutdown_send);\\r\\n        }\\r\\n    } catch (std::exception& e) {\\r\\n        log_event(std::string(\"Server error: \") + e.what());\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-434"}
{"text": "Generate C++ code for the following: The file_is_safe_type function is a function that checks if the file is safe to upload. The upload_file function is the function that handles the upload of the file. The p.save(os.path.join('uploads' filename)) line saves the file to the uploads folder. The uploads folder is created in the same directory as the source file.", "BP": ["File Type Validation", "Destination Directory Creation", "Secure File Copy", "Input Validation", "Error Handling", "Input Sanitization", "Secure File Handling"], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <filesystem>\\r\\n#include <string>\\r\\n#include <regex>\\r\\n\\r\\nnamespace fs = std::filesystem;\\r\\n\\r\\n// Function to check if the file type is safe\\r\\nbool file_is_safe_type(const std::string& filename) {\\r\\n    // Define the allowed file types (you can add more)\\r\\n    const std::regex allowed_file_types(\"(\\\\.jpg|\\\\.jpeg|\\\\.png|\\\\.gif|\\\\.pdf|\\\\.txt)$\", std::regex::icase);\\r\\n\\r\\n    // Check if the file matches one of the allowed types\\r\\n    if (std::regex_search(filename, allowed_file_types)) {\\r\\n        return true;\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\n\\r\\n// Function to sanitize the filename by removing any dangerous characters\\r\\nstd::string sanitize_filename(const std::string& filename) {\\r\\n    std::string sanitized_filename = filename;\\r\\n    sanitized_filename = std::regex_replace(sanitized_filename, std::regex(\"[^a-zA-Z0-9._-]\"), \"_\");\\r\\n    return sanitized_filename;\\r\\n}\\r\\n\\r\\n// Function to handle the file upload\\r\\nbool upload_file(const std::string& filepath) {\\r\\n    try {\\r\\n        // Check if the file exists\\r\\n        if (!fs::exists(filepath)) {\\r\\n            throw std::runtime_error(\"File does not exist.\");\\r\\n        }\\r\\n\\r\\n        // Extract the filename from the filepath\\r\\n        std::string filename = fs::path(filepath).filename().string();\\r\\n\\r\\n        // Perform file type validation\\r\\n        if (!file_is_safe_type(filename)) {\\r\\n            throw std::runtime_error(\"File type is not allowed.\");\\r\\n        }\\r\\n\\r\\n        // Sanitize the filename to prevent directory traversal attacks\\r\\n        filename = sanitize_filename(filename);\\r\\n\\r\\n        // Define the upload directory path\\r\\n        const std::string upload_dir = \"uploads\";\\r\\n\\r\\n        // Create the uploads directory if it does not exist\\r\\n        if (!fs::exists(upload_dir)) {\\r\\n            if (!fs::create_directory(upload_dir)) {\\r\\n                throw std::runtime_error(\"Failed to create upload directory.\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Define the destination path for the uploaded file\\r\\n        std::string destination = upload_dir + \"/\" + filename;\\r\\n\\r\\n        // Perform secure file copy\\r\\n        fs::copy_file(filepath, destination, fs::copy_options::overwrite_existing);\\r\\n\\r\\n        std::cout << \"File uploaded successfully to: \" << destination << std::endl;\\r\\n        return true;\\r\\n    }\\r\\n    catch (const std::exception& e) {\\r\\n        // Error handling\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::string filepath;\\r\\n\\r\\n    // Input validation: ensure the user inputs a valid filepath\\r\\n    std::cout << \"Enter the file path to upload: \";\\r\\n    std::getline(std::cin, filepath);\\r\\n\\r\\n    if (filepath.empty()) {\\r\\n        std::cerr << \"Error: File path cannot be empty.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Attempt to upload the file\\r\\n    if (!upload_file(filepath)) {\\r\\n        std::cerr << \"File upload failed.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-434"}
{"text": "Generate C++ code for the following: The upload_image() function is called when the user uploads an image. The image is read and converted to base64. The image name and base64 string are inserted into the database.", "BP": ["Input Validation", "Output Encoding", "Secure Database Interaction", "Error Handling and Logging", "Authentication and Authorization"], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <sstream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n#include <sqlite3.h>\\r\\n#include <openssl/bio.h>\\r\\n#include <openssl/evp.h>\\r\\n#include <openssl/buffer.h>\\r\\n#include <filesystem>   // For input validation\\r\\n#include <syslog.h>     // For logging\\r\\n\\r\\n// Function prototypes\\r\\nbool authenticate_user(const std::string& user_token);\\r\\nbool authorize_user(const std::string& user_role);\\r\\nstd::string base64_encode(const std::string& input);\\r\\nbool validate_image(const std::string& filename);\\r\\nbool upload_image(const std::string& filepath, const std::string& image_name);\\r\\n\\r\\n// Authenticate user based on token (dummy implementation)\\r\\nbool authenticate_user(const std::string& user_token) {\\r\\n    // Simulate authentication (In real application, query a user database or use OAuth/JWT)\\r\\n    return user_token == \"valid_token\";\\r\\n}\\r\\n\\r\\n// Authorize user based on role (dummy implementation)\\r\\nbool authorize_user(const std::string& user_role) {\\r\\n    // Simulate authorization (In real application, check user roles)\\r\\n    return user_role == \"admin\" || user_role == \"uploader\";\\r\\n}\\r\\n\\r\\n// Function to perform Base64 encoding\\r\\nstd::string base64_encode(const std::string& input) {\\r\\n    BIO* bio, * b64;\\r\\n    BUF_MEM* bufferPtr;\\r\\n    b64 = BIO_new(BIO_f_base64());\\r\\n    bio = BIO_new(BIO_s_mem());\\r\\n    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL); // Do not add newlines\\r\\n    bio = BIO_push(b64, bio);\\r\\n\\r\\n    BIO_write(bio, input.data(), input.size());\\r\\n    BIO_flush(bio);\\r\\n    BIO_get_mem_ptr(bio, &bufferPtr);\\r\\n    BIO_set_close(bio, BIO_NOCLOSE);\\r\\n\\r\\n    std::string encoded_data(bufferPtr->data, bufferPtr->length);\\r\\n    BIO_free_all(bio);\\r\\n    return encoded_data;\\r\\n}\\r\\n\\r\\n// Validate that the uploaded file is an image\\r\\nbool validate_image(const std::string& filename) {\\r\\n    std::string extension = std::filesystem::path(filename).extension().string();\\r\\n    return extension == \".jpg\" || extension == \".jpeg\" || extension == \".png\" || extension == \".gif\";\\r\\n}\\r\\n\\r\\n// Function to upload image\\r\\nbool upload_image(const std::string& filepath, const std::string& image_name) {\\r\\n    try {\\r\\n        // Check if the file exists and is a valid image\\r\\n        if (!std::filesystem::exists(filepath) || !validate_image(filepath)) {\\r\\n            throw std::invalid_argument(\"Invalid image file\");\\r\\n        }\\r\\n\\r\\n        // Open the image file and read it\\r\\n        std::ifstream file(filepath, std::ios::binary);\\r\\n        if (!file) {\\r\\n            throw std::runtime_error(\"Unable to open file\");\\r\\n        }\\r\\n\\r\\n        // Read the image content\\r\\n        std::ostringstream oss;\\r\\n        oss << file.rdbuf();\\r\\n        std::string image_data = oss.str();\\r\\n        file.close();\\r\\n\\r\\n        // Convert image data to Base64\\r\\n        std::string base64_image = base64_encode(image_data);\\r\\n\\r\\n        // Securely interact with the database (using SQLite for this example)\\r\\n        sqlite3* db;\\r\\n        sqlite3_stmt* stmt;\\r\\n        int rc = sqlite3_open(\"image_database.db\", &db);\\r\\n\\r\\n        if (rc != SQLITE_OK) {\\r\\n            throw std::runtime_error(\"Cannot open database\");\\r\\n        }\\r\\n\\r\\n        // Use prepared statements to avoid SQL injection\\r\\n        const char* sql = \"INSERT INTO images (image_name, image_data) VALUES (?, ?);\";\\r\\n        rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\\r\\n        if (rc != SQLITE_OK) {\\r\\n            sqlite3_close(db);\\r\\n            throw std::runtime_error(\"Failed to prepare statement\");\\r\\n        }\\r\\n\\r\\n        // Bind parameters to prevent SQL injection\\r\\n        sqlite3_bind_text(stmt, 1, image_name.c_str(), -1, SQLITE_STATIC);\\r\\n        sqlite3_bind_text(stmt, 2, base64_image.c_str(), -1, SQLITE_STATIC);\\r\\n\\r\\n        // Execute the statement\\r\\n        rc = sqlite3_step(stmt);\\r\\n        if (rc != SQLITE_DONE) {\\r\\n            sqlite3_finalize(stmt);\\r\\n            sqlite3_close(db);\\r\\n            throw std::runtime_error(\"Failed to execute statement\");\\r\\n        }\\r\\n\\r\\n        // Cleanup\\r\\n        sqlite3_finalize(stmt);\\r\\n        sqlite3_close(db);\\r\\n\\r\\n        // Log successful upload\\r\\n        syslog(LOG_INFO, \"Image %s successfully uploaded.\", image_name.c_str());\\r\\n\\r\\n        return true;\\r\\n    } catch (const std::exception& ex) {\\r\\n        // Log the error and return false\\r\\n        syslog(LOG_ERR, \"Error uploading image: %s\", ex.what());\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::string user_token = \"valid_token\"; // Simulate user token (in real scenarios, this comes from the request)\\r\\n    std::string user_role = \"admin\"; // Simulate user role\\r\\n\\r\\n    // Authenticate and authorize the user\\r\\n    if (!authenticate_user(user_token)) {\\r\\n        std::cerr << \"Authentication failed.\" << std::endl;\\r\\n        syslog(LOG_WARNING, \"Authentication failed for token: %s\", user_token.c_str());\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    if (!authorize_user(user_role)) {\\r\\n        std::cerr << \"Authorization failed.\" << std::endl;\\r\\n        syslog(LOG_WARNING, \"Authorization failed for role: %s\", user_role.c_str());\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Call the upload_image function with the file path and image name\\r\\n    std::string filepath = \"path_to_image.jpg\";\\r\\n    std::string image_name = \"example_image\";\\r\\n\\r\\n    if (upload_image(filepath, image_name)) {\\r\\n        std::cout << \"Image uploaded successfully.\" << std::endl;\\r\\n    } else {\\r\\n        std::cerr << \"Failed to upload image.\" << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-434"}
{"text": "Generate C++ code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory. The file_is_safe_type function is a stub that always returns true. The upload_file function is the function that handles the file upload.", "BP": ["Input Validation", "Existing File Check", "File I/O Handling", "File Path Handling", "Error Handling", "Allowed Extensions", "Separation of Concerns", "File Size Limits", "Access Control", "Logging and Monitoring", "Input Sanitization", "Use of Cryptography"], "code": "#include <cppcms/application.h>\\r\\n#include <cppcms/service.h>\\r\\n#include <cppcms/http_request.h>\\r\\n#include <cppcms/http_response.h>\\r\\n#include <cppcms/url_dispatcher.h>\\r\\n#include <iostream>\\r\\n#include <fstream>\\r\\n#include <filesystem>\\r\\n#include <openssl/rand.h>\\r\\n\\r\\nnamespace fs = std::filesystem;\\r\\n\\r\\n// Directory where uploaded files will be saved\\r\\nconst std::string UPLOAD_DIR = \"uploads/\";\\r\\nconst std::size_t MAX_FILE_SIZE = 10 * 1024 * 1024; // 10 MB limit\\r\\n\\r\\n// Function to check allowed extensions\\r\\nbool allowed_extension(const std::string &filename) {\\r\\n    static const std::set<std::string> allowed_extensions = {\".jpg\", \".jpeg\", \".png\", \".txt\", \".pdf\"};\\r\\n    std::string ext = fs::path(filename).extension().string();\\r\\n    return allowed_extensions.count(ext) > 0;\\r\\n}\\r\\n\\r\\n// Function to sanitize filename\\r\\nstd::string sanitize_filename(const std::string &filename) {\\r\\n    std::string sanitized;\\r\\n    for (char c : filename) {\\r\\n        if (std::isalnum(c) || c == '.' || c == '_' || c == '-') {\\r\\n            sanitized += c;\\r\\n        }\\r\\n    }\\r\\n    return sanitized;\\r\\n}\\r\\n\\r\\n// Function to generate a cryptographically secure random filename\\r\\nstd::string generate_secure_filename() {\\r\\n    unsigned char buffer[16];\\r\\n    if (!RAND_bytes(buffer, sizeof(buffer))) {\\r\\n        throw std::runtime_error(\"Failed to generate secure filename\");\\r\\n    }\\r\\n    std::string filename;\\r\\n    for (int i = 0; i < 16; ++i) {\\r\\n        filename += \"0123456789ABCDEF\"[buffer[i] % 16];\\r\\n    }\\r\\n    return filename + \".upload\";\\r\\n}\\r\\n\\r\\n// Function to check if the file is of safe type (Stub function)\\r\\nbool file_is_safe_type(const std::string &filename) {\\r\\n    return true;  // Stub: Add real checks for file content\\r\\n}\\r\\n\\r\\n// Function to handle file upload\\r\\nclass FileUploadApp : public cppcms::application {\\r\\npublic:\\r\\n    FileUploadApp(cppcms::service &srv) : cppcms::application(srv) {\\r\\n        dispatcher().assign(\"/upload\", &FileUploadApp::upload_file, this);\\r\\n    }\\r\\n\\r\\n    void upload_file() {\\r\\n        try {\\r\\n            // Ensure there is a file in the request\\r\\n            if (!request().files().empty()) {\\r\\n                cppcms::http::file &file = request().files().front();\\r\\n                \\r\\n                // Validate file size\\r\\n                if (file.size() > MAX_FILE_SIZE) {\\r\\n                    response().out() << \"Error: File size exceeds the limit!\";\\r\\n                    return;\\r\\n                }\\r\\n\\r\\n                // Validate file extension\\r\\n                std::string filename = sanitize_filename(file.filename());\\r\\n                if (!allowed_extension(filename)) {\\r\\n                    response().out() << \"Error: Invalid file extension!\";\\r\\n                    return;\\r\\n                }\\r\\n\\r\\n                // Generate a unique and secure filename\\r\\n                std::string secure_filename = generate_secure_filename();\\r\\n                std::string file_path = UPLOAD_DIR + secure_filename;\\r\\n\\r\\n                // Check if file is safe (stub for more detailed checks)\\r\\n                if (!file_is_safe_type(file.filename())) {\\r\\n                    response().out() << \"Error: File type not allowed!\";\\r\\n                    return;\\r\\n                }\\r\\n\\r\\n                // Ensure the uploads directory exists\\r\\n                if (!fs::exists(UPLOAD_DIR)) {\\r\\n                    fs::create_directories(UPLOAD_DIR);\\r\\n                }\\r\\n\\r\\n                // Save the file\\r\\n                std::ofstream out(file_path, std::ios::binary);\\r\\n                if (!out.is_open()) {\\r\\n                    throw std::runtime_error(\"Failed to open file for writing\");\\r\\n                }\\r\\n                file.save_to(out);\\r\\n                out.close();\\r\\n\\r\\n                // Log successful upload (simple console logging here)\\r\\n                std::cout << \"File uploaded: \" << file_path << std::endl;\\r\\n\\r\\n                response().out() << \"File uploaded successfully!\";\\r\\n            } else {\\r\\n                response().out() << \"Error: No file uploaded!\";\\r\\n            }\\r\\n        } catch (const std::exception &e) {\\r\\n            // Log errors and send response\\r\\n            std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n            response().out() << \"Error occurred during file upload: \" << e.what();\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nint main(int argc, char **argv) {\\r\\n    try {\\r\\n        cppcms::service srv(argc, argv);\\r\\n        srv.applications_pool().mount(cppcms::applications_factory<FileUploadApp>());\\r\\n        srv.run();\\r\\n    } catch (std::exception const &e) {\\r\\n        std::cerr << e.what() << std::endl;\\r\\n    }\\r\\n}", "CWE": "CWE-434"}
{"text": "Generate C++ code for the following: Memory allocation method allocates a buffer of 1024 bytes.fgets reads 10 characters from sstandard inout and stores them in buf.", "BP": ["Memory Allocation", "Buffer Size Limit", "Input Validation", "Null Termination", "Error Handling", "Memory Deallocation"], "code": "#include <iostream>\\r\\n#include <cstdio>\\r\\n#include <cstdlib>\\r\\n#include <cstring>\\r\\n\\r\\nint main() {\\r\\n    // Step 1: Memory Allocation (Buffer Size = 1024 bytes)\\r\\n    size_t bufferSize = 1024;\\r\\n    char* buf = (char*)malloc(bufferSize * sizeof(char));\\r\\n    \\r\\n    if (buf == nullptr) {\\r\\n        std::cerr << \"Memory allocation failed!\" << std::endl;\\r\\n        return 1; // Exit with error code if memory allocation fails\\r\\n    }\\r\\n\\r\\n    // Step 2: Input Handling (Reading 10 characters from stdin)\\r\\n    std::cout << \"Please enter up to 10 characters: \";\\r\\n\\r\\n    // Step 3: Buffer Size Limit & Error Handling\\r\\n    if (fgets(buf, 11, stdin) == nullptr) {\\r\\n        std::cerr << \"Error reading input!\" << std::endl;\\r\\n        free(buf); // Free memory in case of error\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Step 4: Input Validation & Null Termination\\r\\n    // fgets ensures null-termination, but we can explicitly check and trim newlines.\\r\\n    size_t inputLength = strlen(buf);\\r\\n    if (inputLength > 0 && buf[inputLength - 1] == '\\n') {\\r\\n        buf[inputLength - 1] = '\\0'; // Replace newline character with null-terminator\\r\\n    }\\r\\n\\r\\n    // Step 5: Output and Validation\\r\\n    std::cout << \"You entered: \" << buf << std::endl;\\r\\n\\r\\n    // Step 6: Memory Deallocation\\r\\n    free(buf);\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-476"}
{"text": "Generate C++ code for the following:  Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct through a pointer. The code allocates a new person and sets its status to 0.", "BP": ["Memory Allocation", "Exception Handling", "Memory Initialization", "Pointer Usage", "Resource Management", "Const Correctness"], "code": "#include <iostream>\\r\\n#include <memory>  // For std::unique_ptr\\r\\n#include <stdexcept>  // For std::bad_alloc\\r\\n\\r\\n// Define the 'person' struct\\r\\nstruct person {\\r\\n    int status;\\r\\n\\r\\n    // Constructor to initialize the status\\r\\n    person() : status(0) {\\r\\n        std::cout << \"Person created with status = \" << status << std::endl;\\r\\n    }\\r\\n\\r\\n    // Destructor for demonstration purposes\\r\\n    ~person() {\\r\\n        std::cout << \"Person destroyed\" << std::endl;\\r\\n    }\\r\\n};\\r\\n\\r\\n// Function to allocate and initialize a person\\r\\nstd::unique_ptr<person> allocate_person() {\\r\\n    try {\\r\\n        // Allocate a block of memory for a 'person' object\\r\\n        // Using 'new' for memory allocation and returning a unique_ptr to manage the resource\\r\\n        std::unique_ptr<person> p(new person());\\r\\n\\r\\n        // Access and modify the 'status' member through the pointer\\r\\n        p->status = 0;\\r\\n\\r\\n        // Return the unique_ptr that manages the allocated memory\\r\\n        return p;\\r\\n    }\\r\\n    catch (const std::bad_alloc& e) {\\r\\n        // Handle memory allocation failure\\r\\n        std::cerr << \"Memory allocation failed: \" << e.what() << std::endl;\\r\\n        throw;  // Rethrow the exception after logging\\r\\n    }\\r\\n}\\r\\n\\r\\n// Function to access a person's status, ensuring const correctness\\r\\nvoid display_person_status(const std::unique_ptr<person>& p) {\\r\\n    // Const correctness: p is passed by const reference, so it cannot modify the person object\\r\\n    if (p) {\\r\\n        std::cout << \"Person status: \" << p->status << std::endl;\\r\\n    } else {\\r\\n        std::cout << \"Person pointer is null\" << std::endl;\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    try {\\r\\n        // Allocate a new person object using the function\\r\\n        std::unique_ptr<person> person_ptr = allocate_person();\\r\\n\\r\\n        // Display the person's status\\r\\n        display_person_status(person_ptr);\\r\\n\\r\\n        // The unique_ptr automatically deallocates memory when it goes out of scope\\r\\n    }\\r\\n    catch (const std::exception& e) {\\r\\n        std::cerr << \"An error occurred: \" << e.what() << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-476"}
{"text": "Generate C++ code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The cast (person *) is not necessary but it is good practice to include it. The -> operator is used to access the fields of a struct through a pointer. The code allocates a new person and sets the status field to 0.", "BP": ["Memory Allocation", "Initialization", "Memory Deallocation", "Secure Coding Practices", "Null Pointer Check", "Exception Handling", "Buffer Overflow Prevention", "Error Handling"], "code": "#include <iostream>\\r\\n#include <cstdlib>  // for std::malloc, std::free\\r\\n#include <exception>\\r\\n\\r\\nstruct person {\\r\\n    int status;\\r\\n    // Add other fields here, such as name, age, etc.\\r\\n};\\r\\n\\r\\n// Custom exception class for memory allocation failure\\r\\nclass MemoryAllocationException : public std::exception {\\r\\npublic:\\r\\n    const char* what() const noexcept override {\\r\\n        return \"Memory allocation failed.\";\\r\\n    }\\r\\n};\\r\\n\\r\\n// Secure memory allocation method\\r\\nperson* allocate_person() {\\r\\n    // Allocate memory for a person struct\\r\\n    person* new_person = static_cast<person*>(std::malloc(sizeof(person)));\\r\\n    \\r\\n    // Null pointer check for secure coding practices\\r\\n    if (new_person == nullptr) {\\r\\n        throw MemoryAllocationException(); // Throw custom exception if memory allocation fails\\r\\n    }\\r\\n    \\r\\n    return new_person;\\r\\n}\\r\\n\\r\\n// Function to initialize the person struct\\r\\nvoid initialize_person(person* p) {\\r\\n    if (p == nullptr) {\\r\\n        std::cerr << \"Null pointer error: Cannot initialize person.\" << std::endl;\\r\\n        return;\\r\\n    }\\r\\n    // Initialize fields (avoiding potential buffer overflows)\\r\\n    p->status = 0;\\r\\n    // Initialize other fields with safe operations if needed\\r\\n}\\r\\n\\r\\n// Function to deallocate the memory of person struct\\r\\nvoid deallocate_person(person* p) {\\r\\n    if (p != nullptr) {\\r\\n        std::free(p);  // Safely free the allocated memory\\r\\n        p = nullptr;   // Avoid dangling pointer\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    person* new_person = nullptr;\\r\\n\\r\\n    try {\\r\\n        // Allocate and initialize person struct\\r\\n        new_person = allocate_person();\\r\\n        initialize_person(new_person);\\r\\n\\r\\n        // Example usage of the person struct\\r\\n        std::cout << \"Person status: \" << new_person->status << std::endl;\\r\\n\\r\\n    } catch (const MemoryAllocationException& e) {\\r\\n        // Handle memory allocation failure\\r\\n        std::cerr << e.what() << std::endl;\\r\\n        return EXIT_FAILURE;\\r\\n    } catch (const std::exception& e) {\\r\\n        // Catch any other exceptions\\r\\n        std::cerr << \"An error occurred: \" << e.what() << std::endl;\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    // Deallocate memory for person struct\\r\\n    deallocate_person(new_person);\\r\\n\\r\\n    return EXIT_SUCCESS;\\r\\n}", "CWE": "CWE-476"}
{"text": "Generate C++ code for the following: The code is a simple web application that listens on port 5000. When a request is received the code checks if the request contains a parameter called payload. If not it returns an error message. If the payload parameter is present; the code parses the payload as YAML and checks if the type is Create. If it is it returns an error message. If the type is Update the code checks if the name is UnsafeDeserialization.", "BP": ["Input Validation", "Input Sanitization", "Secure YAML Parsing", "Secure Request Handling", "Server Setup and Configuration"], "code": "#include <iostream>\\r\\n#include <boost/asio.hpp>\\r\\n#include <boost/beast.hpp>\\r\\n#include <boost/beast/http.hpp>\\r\\n#include <yaml-cpp/yaml.h>\\r\\n#include <regex>\\r\\n\\r\\nnamespace beast = boost::beast;\\r\\nnamespace http = beast::http;\\r\\nnamespace net = boost::asio;\\r\\nusing tcp = net::ip::tcp;\\r\\n\\r\\n// Input sanitization for the YAML payload\\r\\nstd::string sanitize_input(const std::string& input) {\\r\\n    // Remove any potential harmful characters from input\\r\\n    std::string sanitized_input = input;\\r\\n    sanitized_input = std::regex_replace(sanitized_input, std::regex(\"<\"), \"&lt;\");\\r\\n    sanitized_input = std::regex_replace(sanitized_input, std::regex(\">\"), \"&gt;\");\\r\\n    // Add further sanitization as needed (like SQL injection prevention)\\r\\n    return sanitized_input;\\r\\n}\\r\\n\\r\\n// Input validation\\r\\nbool is_valid_input(const std::string& payload) {\\r\\n    // Perform basic validation checks (e.g., max length, structure, etc.)\\r\\n    if (payload.size() > 10000) { // Limit the payload size\\r\\n        return false;\\r\\n    }\\r\\n    return true;\\r\\n}\\r\\n\\r\\n// Secure YAML parsing (avoiding certain exploits)\\r\\nYAML::Node secure_parse_yaml(const std::string& payload) {\\r\\n    try {\\r\\n        YAML::Node node = YAML::Load(payload);\\r\\n        return node;\\r\\n    } catch (const YAML::ParserException& ex) {\\r\\n        throw std::runtime_error(\"YAML Parsing Error\");\\r\\n    }\\r\\n}\\r\\n\\r\\n// Handles incoming HTTP requests\\r\\nvoid handle_request(http::request<http::string_body> req, http::response<http::string_body>& res) {\\r\\n    if (req.method() != http::verb::post) {\\r\\n        res.result(http::status::bad_request);\\r\\n        res.body() = \"Only POST method is supported.\";\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // Extract 'payload' from the request\\r\\n    std::string payload;\\r\\n    try {\\r\\n        auto params = http::parse_query_string(req.body());\\r\\n        if (params.find(\"payload\") != params.end()) {\\r\\n            payload = params.at(\"payload\");\\r\\n        } else {\\r\\n            res.result(http::status::bad_request);\\r\\n            res.body() = \"Missing 'payload' parameter.\";\\r\\n            return;\\r\\n        }\\r\\n    } catch (std::exception& e) {\\r\\n        res.result(http::status::bad_request);\\r\\n        res.body() = \"Error parsing query.\";\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // Input Validation and Sanitization\\r\\n    if (!is_valid_input(payload)) {\\r\\n        res.result(http::status::bad_request);\\r\\n        res.body() = \"Invalid payload.\";\\r\\n        return;\\r\\n    }\\r\\n    payload = sanitize_input(payload);\\r\\n\\r\\n    // Secure YAML Parsing\\r\\n    YAML::Node yaml_node;\\r\\n    try {\\r\\n        yaml_node = secure_parse_yaml(payload);\\r\\n    } catch (const std::exception& e) {\\r\\n        res.result(http::status::bad_request);\\r\\n        res.body() = \"Failed to parse YAML.\";\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // Check if 'type' exists in the YAML payload\\r\\n    if (!yaml_node[\"type\"]) {\\r\\n        res.result(http::status::bad_request);\\r\\n        res.body() = \"Missing 'type' field in payload.\";\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    std::string type = yaml_node[\"type\"].as<std::string>();\\r\\n\\r\\n    if (type == \"Create\") {\\r\\n        res.result(http::status::bad_request);\\r\\n        res.body() = \"'Create' type is not allowed.\";\\r\\n    } else if (type == \"Update\") {\\r\\n        if (yaml_node[\"name\"] && yaml_node[\"name\"].as<std::string>() == \"UnsafeDeserialization\") {\\r\\n            res.result(http::status::ok);\\r\\n            res.body() = \"Update type with UnsafeDeserialization name.\";\\r\\n        } else {\\r\\n            res.result(http::status::bad_request);\\r\\n            res.body() = \"'name' field must be 'UnsafeDeserialization' for Update type.\";\\r\\n        }\\r\\n    } else {\\r\\n        res.result(http::status::bad_request);\\r\\n        res.body() = \"Invalid 'type' field in payload.\";\\r\\n    }\\r\\n}\\r\\n\\r\\n// Server function\\r\\nvoid server() {\\r\\n    try {\\r\\n        net::io_context ioc{1};\\r\\n        tcp::acceptor acceptor{ioc, tcp::endpoint{tcp::v4(), 5000}};\\r\\n\\r\\n        while (true) {\\r\\n            tcp::socket socket{ioc};\\r\\n            acceptor.accept(socket);\\r\\n\\r\\n            // Handle the connection\\r\\n            beast::flat_buffer buffer;\\r\\n            http::request<http::string_body> req;\\r\\n            http::read(socket, buffer, req);\\r\\n\\r\\n            http::response<http::string_body> res{http::status::ok, req.version()};\\r\\n            res.set(http::field::server, \"BeastServer\");\\r\\n            res.keep_alive(req.keep_alive());\\r\\n\\r\\n            handle_request(req, res);\\r\\n\\r\\n            // Send the response\\r\\n            http::write(socket, res);\\r\\n        }\\r\\n    } catch (std::exception& e) {\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::cout << \"Starting server on port 5000...\\n\";\\r\\n    server();\\r\\n    return 0;\\r\\n}", "CWE": "CWE-502"}
{"text": "Generate C++ code for the following: Create a web application that takes in a payload from a user request and checks for the field 'name'. If the field exists return the content of the field 'name'.", "BP": ["Input Validation", "Input Sanitization", "Secure Library Usage", "Appropriate HTTP Status Codes", "Asynchronous Handling", "Authentication and Authorization", "Error Handling", "Logging and Monitoring", "Input Validation against Whitelist or Regular Expressions"], "code": "#include \"crow.h\"\\r\\n#include <jwt-cpp/jwt.h>\\r\\n#include <regex>\\r\\n#include <future>\\r\\n#include <iostream>\\r\\n\\r\\n// Function to sanitize user input (removes dangerous characters)\\r\\nstd::string sanitize_input(const std::string& input) {\\r\\n    std::string sanitized = input;\\r\\n    sanitized.erase(std::remove_if(sanitized.begin(), sanitized.end(),\\r\\n                    [](char c) { return !std::isalnum(c) && c != ' '; }), sanitized.end());\\r\\n    return sanitized;\\r\\n}\\r\\n\\r\\n// Function to validate 'name' using regular expression\\r\\nbool validate_name(const std::string& name) {\\r\\n    std::regex name_regex(\"^[a-zA-Z ]+$\");\\r\\n    return std::regex_match(name, name_regex);\\r\\n}\\r\\n\\r\\n// Function for authentication (JWT-based authentication)\\r\\nbool authenticate_request(const std::string& token) {\\r\\n    try {\\r\\n        auto decoded = jwt::decode(token);\\r\\n        // Ideally, the secret should be stored securely and used to verify the token.\\r\\n        auto verifier = jwt::verify()\\r\\n                .allow_algorithm(jwt::algorithm::hs256{\"your-secret-key\"})\\r\\n                .with_issuer(\"auth0\");\\r\\n\\r\\n        verifier.verify(decoded);  // Verify the JWT token\\r\\n        return true;\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << \"Authentication failed: \" << e.what() << std::endl;\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    crow::SimpleApp app;\\r\\n\\r\\n    // Logging Middleware for Crow\\r\\n    CROW_LOG_INFO << \"Server started...\";\\r\\n\\r\\n    // Handle the POST request asynchronously\\r\\n    CROW_ROUTE(app, \"/submit\").methods(crow::HTTPMethod::Post)\\r\\n    ([](const crow::request& req) -> crow::response {\\r\\n        // Simple Authentication (JWT in headers)\\r\\n        auto auth_header = req.get_header_value(\"Authorization\");\\r\\n        if (auth_header.empty() || !authenticate_request(auth_header)) {\\r\\n            CROW_LOG_ERROR << \"Unauthorized access\";\\r\\n            return crow::response(401, \"Unauthorized\");\\r\\n        }\\r\\n\\r\\n        try {\\r\\n            // Parse JSON payload\\r\\n            auto body = crow::json::load(req.body);\\r\\n            if (!body) {\\r\\n                CROW_LOG_ERROR << \"Bad Request: Malformed JSON\";\\r\\n                return crow::response(400, \"Bad Request: Invalid JSON payload\");\\r\\n            }\\r\\n\\r\\n            // Check if 'name' field exists\\r\\n            if (body.has(\"name\")) {\\r\\n                std::string name = body[\"name\"].s();\\r\\n\\r\\n                // Sanitize the input\\r\\n                std::string sanitized_name = sanitize_input(name);\\r\\n\\r\\n                // Validate the name field against whitelist (only alphabets and spaces)\\r\\n                if (!validate_name(sanitized_name)) {\\r\\n                    CROW_LOG_ERROR << \"Invalid 'name' field\";\\r\\n                    return crow::response(400, \"Invalid 'name' field\");\\r\\n                }\\r\\n\\r\\n                // Simulate asynchronous operation\\r\\n                auto result = std::async(std::launch::async, [sanitized_name]() {\\r\\n                    CROW_LOG_INFO << \"Processing the name: \" << sanitized_name;\\r\\n                    return crow::response(200, \"Hello \" + sanitized_name);\\r\\n                });\\r\\n\\r\\n                return result.get();\\r\\n            } else {\\r\\n                CROW_LOG_ERROR << \"Bad Request: 'name' field is missing\";\\r\\n                return crow::response(400, \"'name' field is required\");\\r\\n            }\\r\\n        } catch (const std::exception& e) {\\r\\n            CROW_LOG_ERROR << \"Server Error: \" << e.what();\\r\\n            return crow::response(500, \"Internal Server Error\");\\r\\n        }\\r\\n    });\\r\\n\\r\\n    // Start the server\\r\\n    app.port(8080).multithreaded().run();\\r\\n    return 0;\\r\\n}", "CWE": "CWE-502"}
{"text": "Generate C++ code for the following: The function temperature_for_location() is called when a request is made to the URL /api/temperature_for_location. The function gets the latitude; longitude and date from the request. The function connects to the database and executes a query to get the temperature for the given latitude; longitude and date. The function returns the temperature.", "BP": ["Parameterized Queries", "Connection Management", "Error Handling", "Input Validation", "Secure Database Credentials", "Logging and Monitoring", "Connection Pooling", "Security Auditing"], "code": "#include <cpprest/http_listener.h>\\r\\n#include <cpprest/json.h>\\r\\n#include <cppconn/connection.h>\\r\\n#include <cppconn/prepared_statement.h>\\r\\n#include <cppconn/driver.h>\\r\\n#include <cppconn/result_set.h>\\r\\n#include <spdlog/spdlog.h>\\r\\n#include <memory>\\r\\n#include <stdexcept>\\r\\n#include <string>\\r\\n#include <regex>\\r\\n\\r\\nusing namespace web;\\r\\nusing namespace web::http;\\r\\nusing namespace web::http::experimental::listener;\\r\\n\\r\\n// Function to validate latitude and longitude\\r\\nbool is_valid_coordinate(double value, double min, double max) {\\r\\n    return value >= min && value <= max;\\r\\n}\\r\\n\\r\\n// Function to perform the temperature query\\r\\ndouble get_temperature(double latitude, double longitude, const std::string& date) {\\r\\n    // Secure database credentials (ideally stored in environment variables)\\r\\n    const std::string db_user = \"username\"; // replace with secure handling\\r\\n    const std::string db_password = \"password\"; // replace with secure handling\\r\\n    const std::string db_host = \"tcp://127.0.0.1:3306\"; // replace with your DB host\\r\\n    const std::string db_name = \"temperature_db\"; // replace with your DB name\\r\\n\\r\\n    try {\\r\\n        sql::mysql::MySQL_Driver *driver = sql::mysql::get_mysql_driver_instance();\\r\\n        std::unique_ptr<sql::Connection> con(driver->connect(db_host, db_user, db_password));\\r\\n        con->setSchema(db_name);\\r\\n\\r\\n        // Prepare SQL statement\\r\\n        std::unique_ptr<sql::PreparedStatement> pstmt(con->prepareStatement(\\r\\n            \"SELECT temperature FROM weather WHERE latitude = ? AND longitude = ? AND date = ?\"\\r\\n        ));\\r\\n        pstmt->setDouble(1, latitude);\\r\\n        pstmt->setDouble(2, longitude);\\r\\n        pstmt->setString(3, date);\\r\\n\\r\\n        // Execute the query\\r\\n        std::unique_ptr<sql::ResultSet> res(pstmt->executeQuery());\\r\\n        if (res->next()) {\\r\\n            return res->getDouble(\"temperature\");\\r\\n        } else {\\r\\n            throw std::runtime_error(\"No temperature data found for the given location and date.\");\\r\\n        }\\r\\n    } catch (sql::SQLException &e) {\\r\\n        spdlog::error(\"SQL error: {}\", e.what());\\r\\n        throw std::runtime_error(\"Database error occurred.\");\\r\\n    } catch (const std::exception &e) {\\r\\n        spdlog::error(\"Error: {}\", e.what());\\r\\n        throw;\\r\\n    }\\r\\n}\\r\\n\\r\\n// The main function to handle HTTP requests\\r\\nvoid temperature_for_location(http_request request) {\\r\\n    request.extract_json().then([=](json::value request_data) {\\r\\n        try {\\r\\n            // Extract parameters\\r\\n            double latitude = request_data.at(U(\"latitude\")).as_double();\\r\\n            double longitude = request_data.at(U(\"longitude\")).as_double();\\r\\n            std::string date = request_data.at(U(\"date\")).as_string();\\r\\n\\r\\n            // Input validation\\r\\n            if (!is_valid_coordinate(latitude, -90.0, 90.0) || !is_valid_coordinate(longitude, -180.0, 180.0)) {\\r\\n                throw std::invalid_argument(\"Invalid latitude or longitude.\");\\r\\n            }\\r\\n\\r\\n            // Get the temperature\\r\\n            double temperature = get_temperature(latitude, longitude, date);\\r\\n\\r\\n            // Prepare the response\\r\\n            json::value response_data;\\r\\n            response_data[U(\"temperature\")] = json::value::number(temperature);\\r\\n            request.reply(status_codes::OK, response_data);\\r\\n        } catch (const std::invalid_argument &e) {\\r\\n            spdlog::warn(\"Input validation failed: {}\", e.what());\\r\\n            request.reply(status_codes::BadRequest, json::value::string(\"Input validation error.\"));\\r\\n        } catch (const std::runtime_error &e) {\\r\\n            spdlog::error(\"Runtime error: {}\", e.what());\\r\\n            request.reply(status_codes::InternalError, json::value::string(\"Internal server error.\"));\\r\\n        } catch (...) {\\r\\n            spdlog::error(\"Unknown error occurred.\");\\r\\n            request.reply(status_codes::InternalError, json::value::string(\"Internal server error.\"));\\r\\n        }\\r\\n    }).wait();\\r\\n}\\r\\n\\r\\n// Main function to set up the HTTP listener\\r\\nint main() {\\r\\n    uri uri(U(\"http://localhost:8080/api/temperature_for_location\"));\\r\\n    listener l(uri);\\r\\n    \\r\\n    l.support(methods::POST, temperature_for_location);\\r\\n    \\r\\n    try {\\r\\n        l\\r\\n            .open()\\r\\n            .then([&l](){ spdlog::info(\"Starting to listen at: {}\", l.uri().to_string()); })\\r\\n            .wait();\\r\\n\\r\\n        std::string line;\\r\\n        std::getline(std::cin, line);\\r\\n    } catch (const std::exception& e) {\\r\\n        spdlog::error(\"An error occurred: {}\", e.what());\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-502"}
