{"text": "Generate C++ code for the following: A function copies a number of bytes from one memory location to another. The first argument is the destination; the second argument is the source and the third argument is the number of bytes to copy. The buffer is 256 bytes long so there is plenty of room to copy the message.", "BP": ["Null pointer checks", "Buffer size check", "Use of memory-safe functions", "Error Handling", "Null Terminator"], "code": "#include <iostream>\\r\\n#include <cstring>  // for memcpy, memset\\r\\n#include <stdexcept> // for std::invalid_argument\\r\\n\\r\\nconst size_t BUFFER_SIZE = 256;  // Define buffer size\\r\\n\\r\\n// Memory copy function with safety checks\\r\\nvoid safeMemoryCopy(void* dest, const void* src, size_t numBytes) {\\r\\n    // Null pointer check\\r\\n    if (dest == nullptr || src == nullptr) {\\r\\n        throw std::invalid_argument(\"Null pointer passed as argument.\");\\r\\n    }\\r\\n\\r\\n    // Buffer size check\\r\\n    if (numBytes > BUFFER_SIZE) {\\r\\n        throw std::out_of_range(\"Number of bytes to copy exceeds buffer size.\");\\r\\n    }\\r\\n\\r\\n    // Use memory-safe function (memmove) instead of memcpy\\r\\n    // memmove allows overlapping memory regions\\r\\n    std::memmove(dest, src, numBytes);\\r\\n\\r\\n    // Ensure that the destination buffer is null-terminated\\r\\n    if (numBytes < BUFFER_SIZE) {\\r\\n        static_cast<char*>(dest)[numBytes] = '\\0';\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    // Define source and destination buffers\\r\\n    char source[BUFFER_SIZE] = \"Hello, World!\";  // Example source message\\r\\n    char destination[BUFFER_SIZE];               // Destination buffer\\r\\n\\r\\n    try {\\r\\n        // Perform memory copy\\r\\n        safeMemoryCopy(destination, source, strlen(source));\\r\\n\\r\\n        // Output the copied content\\r\\n        std::cout << \"Copied message: \" << destination << std::endl;\\r\\n    } catch (const std::exception& e) {\\r\\n        // Handle any errors\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: The code takes an index as an argument and prints the corresponding argument from the command line arguments. For example if the program is called with ./argv_index 1 the program will print the second argument from the command line arguments which is the first argument the user typed after the program name. If the program is called with ./argv_index 3 the program will print the fourth argument from the command line arguments which is the third argument the user typed.", "BP": ["Input Validation", "Error Handling", "Secure Library Functions", "Avoiding Buffer Overflows", "Secure Output"], "code": "#include <iostream>\\r\\n#include <stdexcept>\\r\\n#include <cstdlib> // for std::strtol\\r\\n#include <climits> // for INT_MAX and INT_MIN\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Ensure there are at least two arguments: the program name and an index\\r\\n    if (argc < 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <index>\" << std::endl;\\r\\n        return 1; // Return non-zero for error\\r\\n    }\\r\\n\\r\\n    // Perform input validation on the index argument\\r\\n    char* endptr;\\r\\n    long index = std::strtol(argv[1], &endptr, 10);\\r\\n\\r\\n    // Check if the conversion succeeded and ensure it's a valid integer\\r\\n    if (*endptr != '\\0' || endptr == argv[1]) {\\r\\n        std::cerr << \"Error: Invalid index. Please enter a valid integer.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Check for out-of-range errors\\r\\n    if (index < 1 || index > INT_MAX) {\\r\\n        std::cerr << \"Error: Index out of valid range. Enter a positive integer within range.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Convert 1-based index to 0-based for array lookup\\r\\n    int arg_index = static_cast<int>(index);\\r\\n\\r\\n    // Ensure the index is within the number of provided arguments\\r\\n    if (arg_index >= argc) {\\r\\n        std::cerr << \"Error: Index exceeds the number of arguments.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Output the argument securely\\r\\n    std::cout << \"Argument at index \" << index << \": \" << argv[arg_index] << std::endl;\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: The code takes in a command line argument and converts it to an integer.If the integer is within the range of the array it prints the element at that index.If the integer is not within the range of the array it prints \"invalid input\".", "BP": ["Input Validation", "Error Handling", "Array Bounds Checking", "Secure Type Conversions", "Secure Output"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n#include <limits> // for std::numeric_limits\\r\\n\\r\\n// Function to convert a string to an integer securely\\r\\nint convertToInt(const std::string& input) {\\r\\n    try {\\r\\n        size_t pos;\\r\\n        // Convert the string to an integer using std::stoi\\r\\n        int number = std::stoi(input, &pos);\\r\\n\\r\\n        // Ensure that the entire string was a valid integer\\r\\n        if (pos != input.length()) {\\r\\n            throw std::invalid_argument(\"Input contains non-integer characters.\");\\r\\n        }\\r\\n\\r\\n        return number;\\r\\n    } catch (const std::invalid_argument& e) {\\r\\n        throw std::runtime_error(\"Invalid input: Not a valid integer.\");\\r\\n    } catch (const std::out_of_range& e) {\\r\\n        throw std::runtime_error(\"Invalid input: Integer out of range.\");\\r\\n    }\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Define an array of integers\\r\\n    const int arr[] = {10, 20, 30, 40, 50};\\r\\n    const int arrSize = sizeof(arr) / sizeof(arr[0]);\\r\\n\\r\\n    // Check if a command-line argument is provided\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Error: Please provide a single integer as a command-line argument.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        // Convert the argument to an integer\\r\\n        int index = convertToInt(argv[1]);\\r\\n\\r\\n        // Check if the index is within the array bounds\\r\\n        if (index >= 0 && index < arrSize) {\\r\\n            std::cout << \"Element at index \" << index << \": \" << arr[index] << std::endl;\\r\\n        } else {\\r\\n            std::cerr << \"Invalid input: Index out of bounds.\" << std::endl;\\r\\n        }\\r\\n    } catch (const std::runtime_error& e) {\\r\\n        // Handle any conversion or validation errors\\r\\n        std::cerr << e.what() << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: atoi() converts a string to an integer. argc is the number of arguments passed to the program. Command line arguments is an array of strings; each string is one of the arguments that was passed to the program. The first argument is always the name of the program so if the user ran ./a.out foo bar baz; argc would be 4; argv[0] would be ./a.out argv.", "BP": ["Input Validation", "Use of Secure Functions", "Error Handling", "Robust Integer Conversion", "Command-line Input Handling", "Output Formatting"], "code": "#include <iostream>\\r\\n#include <cstdlib>      // for atoi\\r\\n#include <string>       // for std::string\\r\\n#include <limits>       // for std::numeric_limits\\r\\n#include <cerrno>       // for errno\\r\\n#include <cstring>      // for strerror\\r\\n#include <climits>      // for INT_MAX and INT_MIN\\r\\n\\r\\n// Function to convert a string to an integer with robust error handling\\r\\nbool convertStringToInt(const char* str, int& result) {\\r\\n    char* endPtr;\\r\\n    errno = 0; // Reset errno before calling strtol()\\r\\n\\r\\n    long tempResult = strtol(str, &endPtr, 10); // Using strtol for better error checking\\r\\n\\r\\n    // Check for errors:\\r\\n    // 1. If no digits were found (endPtr points to the start of the string)\\r\\n    if (endPtr == str) {\\r\\n        std::cerr << \"Error: No digits found in argument \\\"\" << str << \"\\\".\\n\";\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // 2. If there are any non-numeric characters in the string\\r\\n    if (*endPtr != '\\0') {\\r\\n        std::cerr << \"Error: Argument \\\"\" << str << \"\\\" contains non-numeric characters.\\n\";\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // 3. Check for out-of-range values\\r\\n    if ((errno == ERANGE && (tempResult == LONG_MAX || tempResult == LONG_MIN)) || tempResult > INT_MAX || tempResult < INT_MIN) {\\r\\n        std::cerr << \"Error: Argument \\\"\" << str << \"\\\" is out of the range for an int.\\n\";\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // Assign the valid converted value\\r\\n    result = static_cast<int>(tempResult);\\r\\n    return true;\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Check if there are enough arguments passed\\r\\n    if (argc < 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <list of integers>\\n\";\\r\\n        return 1; // Return with error code 1 for insufficient arguments\\r\\n    }\\r\\n\\r\\n    // Process each argument passed, starting from argv[1] as argv[0] is the program name\\r\\n    for (int i = 1; i < argc; ++i) {\\r\\n        int convertedValue;\\r\\n        if (convertStringToInt(argv[i], convertedValue)) {\\r\\n            std::cout << \"Argument \" << i << \" (\" << argv[i] << \") converted to integer: \" << convertedValue << \"\\n\";\\r\\n        } else {\\r\\n            std::cerr << \"Error converting argument \" << i << \": \\\"\" << argv[i] << \"\\\" to an integer.\\n\";\\r\\n            return 2; // Exit with error code 2 for conversion errors\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return 0; // Program executed successfully\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: atoi() is a function that converts a string to an integer. Command line arguments at index 1 is the second argument passed to the program. Command line argument at index INDEX is the argument at the INDEX specified by the second argument. print function prints the string at INDEX position in the command line arguments to the screen. return 0. exit the program.", "BP": ["Input Validation", "Secure String-to-Integer Conversion", "Error Handling", "Avoiding Unnecessary Memory Allocations", "Secure Output"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <cstdlib>    // For atoi()\\r\\n#include <stdexcept>  // For exceptions\\r\\n#include <cerrno>     // For errno\\r\\n#include <limits>     // For integer limits\\r\\n\\r\\n// Function to safely convert a string to an integer\\r\\nint safeStringToInt(const std::string& str) {\\r\\n    errno = 0; // Reset errno before calling strtol\\r\\n    char* endPtr = nullptr;\\r\\n    long value = std::strtol(str.c_str(), &endPtr, 10);\\r\\n\\r\\n    // Check if the entire string was converted and check for out-of-range errors\\r\\n    if (*endPtr != '\\0' || errno == ERANGE || value < std::numeric_limits<int>::min() || value > std::numeric_limits<int>::max()) {\\r\\n        throw std::invalid_argument(\"Invalid integer input: \" + str);\\r\\n    }\\r\\n\\r\\n    return static_cast<int>(value);\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    try {\\r\\n        // Check if at least two arguments are provided (program name + second argument)\\r\\n        if (argc < 2) {\\r\\n            std::cerr << \"Error: No arguments provided.\\n\";\\r\\n            return 1;\\r\\n        }\\r\\n\\r\\n        // Convert the second argument (at index 1) to an integer (this will be the index argument)\\r\\n        int index = safeStringToInt(argv[1]);\\r\\n\\r\\n        // Check if index is within valid range (between 1 and argc-1)\\r\\n        if (index < 1 || index >= argc) {\\r\\n            std::cerr << \"Error: Index out of range. Must be between 1 and \" << argc - 1 << \".\\n\";\\r\\n            return 1;\\r\\n        }\\r\\n\\r\\n        // Print the argument at the specified index\\r\\n        std::cout << \"Argument at index \" << index << \": \" << argv[index] << std::endl;\\r\\n\\r\\n        return 0; // Success\\r\\n    } catch (const std::exception& ex) {\\r\\n        // Handle any exceptions thrown during conversion or other operations\\r\\n        std::cerr << \"Error: \" << ex.what() << std::endl;\\r\\n        return 1; // Return error code\\r\\n    }\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. The function first prompts the user for an index value. Then the function checks if the index value is in bounds. If it is not the function returns -1. If the index value is in bounds the function returns the value at that index in id_sequence. The function returns 0 if the program runs.", "BP": ["Input Validation", "Bounds Checking", "Secure Coding Practices", "Error Handling"], "code": "#include <iostream>\\r\\n#include <limits>  // for std::numeric_limits\\r\\n\\r\\nconst int id_sequence[] = {10, 20, 30, 40, 50};  // Example array\\r\\nconst int id_size = sizeof(id_sequence) / sizeof(id_sequence[0]);  // Calculate size of array\\r\\n\\r\\nint getValueAtIndex() {\\r\\n    int index;\\r\\n\\r\\n    // Prompt user for input and perform input validation\\r\\n    std::cout << \"Enter an index: \";\\r\\n    \\r\\n    // Input validation for integer input\\r\\n    while (!(std::cin >> index)) {\\r\\n        std::cerr << \"Invalid input. Please enter a valid integer.\\n\";\\r\\n        // Clear the error flag on cin and ignore bad input\\r\\n        std::cin.clear();\\r\\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\\r\\n        std::cout << \"Enter an index: \";\\r\\n    }\\r\\n\\r\\n    // Bounds checking\\r\\n    if (index < 0 || index >= id_size) {\\r\\n        std::cerr << \"Error: Index out of bounds.\\n\";\\r\\n        return -1;\\r\\n    }\\r\\n\\r\\n    // Return the value at the specified index\\r\\n    return id_sequence[index];\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    int result = getValueAtIndex();\\r\\n\\r\\n    if (result == -1) {\\r\\n        std::cerr << \"Error encountered. Exiting program.\\n\";\\r\\n        return -1;  // Return -1 if there's an error\\r\\n    }\\r\\n\\r\\n    std::cout << \"Value at the specified index: \" << result << std::endl;\\r\\n\\r\\n    return 0;  // Return 0 if the program runs successfully\\r\\n}", "CWE": "CWE-125"}
{"text": "Generate C++ code for the following: The code takes an integer as input and returns the value at the index of the integer in the array. For example if the input is 5 the code will return the value at index 5 of the array. If the input is -1 the code will return -1. If the input is 10 the code will return -1. If the input is 0 the code will return the value at index 0 of the array.", "BP": ["Input Validation", "Bounds Checking", "Use of std::vector", "Error Handling", "Secure Data Types", "Avoiding Undefined Behavior"], "code": "#include <iostream>\\r\\n#include <vector>\\r\\n#include <limits>\\r\\n\\r\\n// Function to safely get an integer input from the user\\r\\nint getInput() {\\r\\n    int input;\\r\\n    while (true) {\\r\\n        std::cout << \"Enter an index: \";\\r\\n        std::cin >> input;\\r\\n\\r\\n        // Check if the input is a valid integer\\r\\n        if (std::cin.fail()) {\\r\\n            std::cin.clear();  // Clear the error state\\r\\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');  // Discard invalid input\\r\\n            std::cout << \"Invalid input. Please enter a valid integer.\\n\";\\r\\n        } else {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n    return input;\\r\\n}\\r\\n\\r\\n// Function to return the value at the specified index, or -1 for invalid input\\r\\nint getValueAtIndex(const std::vector<int>& arr, int index) {\\r\\n    if (index < 0 || index >= arr.size()) {\\r\\n        return -1;  // Return -1 if index is out of bounds\\r\\n    }\\r\\n    return arr[index];  // Return the value at the valid index\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    // Initialize a sample vector with some values\\r\\n    std::vector<int> myArray = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\\r\\n\\r\\n    // Get input from the user\\r\\n    int index = getInput();\\r\\n\\r\\n    // Check bounds and print the value or error\\r\\n    int result = getValueAtIndex(myArray, index);\\r\\n\\r\\n    if (result == -1) {\\r\\n        std::cout << \"Invalid index! Returning: \" << result << std::endl;\\r\\n    } else {\\r\\n        std::cout << \"Value at index \" << index << \": \" << result << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-125"}
{"text": "Generate C++ code for the following: The code takes in a number from the user and returns the value at that index in the array. If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Index Validation", "Use of std::vector", "Error Handling", "Consistent Data Types", "Encapsulation"], "code": "#include <iostream>\\r\\n#include <vector>\\r\\n#include <limits> // for numeric_limits\\r\\n\\r\\n// Class encapsulating the functionality\\r\\nclass ArrayHandler {\\r\\nprivate:\\r\\n    std::vector<int> data; // Encapsulated data member\\r\\n\\r\\npublic:\\r\\n    // Constructor to initialize the vector with some values\\r\\n    ArrayHandler() {\\r\\n        data = {10, 20, 30, 40, 50}; // Example data\\r\\n    }\\r\\n\\r\\n    // Function to safely get the value at a specific index\\r\\n    int getValueAtIndex(int index) {\\r\\n        if (index < 0 || index >= data.size()) {\\r\\n            std::cerr << \"Error: Index out of bounds.\\n\";\\r\\n            return -1;\\r\\n        }\\r\\n        return data[index];\\r\\n    }\\r\\n\\r\\n    // Function to take input from the user and validate it\\r\\n    int getValidatedInput() {\\r\\n        int index;\\r\\n        while (true) {\\r\\n            std::cout << \"Enter an index (0 to \" << data.size() - 1 << \"): \";\\r\\n            std::cin >> index;\\r\\n\\r\\n            // Input validation: Check if input is an integer\\r\\n            if (std::cin.fail()) {\\r\\n                std::cin.clear(); // Clear the error state\\r\\n                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // Ignore invalid input\\r\\n                std::cerr << \"Invalid input. Please enter a valid integer.\\n\";\\r\\n            } else {\\r\\n                break; // Valid input, exit the loop\\r\\n            }\\r\\n        }\\r\\n        return index;\\r\\n    }\\r\\n\\r\\n    // Function to handle the overall process\\r\\n    void handleInputAndOutput() {\\r\\n        int index = getValidatedInput();\\r\\n        int result = getValueAtIndex(index);\\r\\n\\r\\n        if (result != -1) {\\r\\n            std::cout << \"Value at index \" << index << \" is: \" << result << \"\\n\";\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nint main() {\\r\\n    ArrayHandler handler;\\r\\n    handler.handleInputAndOutput();\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-125"}
{"text": "Generate C++ code for the following: The code takes an integer as input and returns the value at the index of the integer in the array. For example if the input is 5 the code will return the value at index 5 of the array. If the input is out of bounds the code will return -1. For example if the input is 10 the code will return -1. ", "BP": ["Input Validation", "Bounds Checking", "Error Handling", "Secure Data Structures", "Secure Library Functions"], "code": "#include <iostream>\\r\\n#include <limits> // For input validation\\r\\n\\r\\n// Function to safely get an integer from user\\r\\nint getIntegerInput() {\\r\\n    int input;\\r\\n    while (true) {\\r\\n        std::cout << \"Enter an index: \";\\r\\n        std::cin >> input;\\r\\n        \\r\\n        // Input validation\\r\\n        if (std::cin.fail()) {\\r\\n            std::cin.clear(); // Clear the error flag\\r\\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // Discard invalid input\\r\\n            std::cout << \"Invalid input. Please enter an integer.\" << std::endl;\\r\\n        } else {\\r\\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // Clear extra input\\r\\n            return input;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// Function to return the value at the index if valid, else return -1\\r\\nint getValueAtIndex(const int arr[], size_t size, int index) {\\r\\n    // Bounds checking\\r\\n    if (index >= 0 && index < static_cast<int>(size)) {\\r\\n        return arr[index];\\r\\n    } else {\\r\\n        std::cerr << \"Error: Index out of bounds.\" << std::endl;\\r\\n        return -1; // Return -1 if index is out of bounds\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    // Example array\\r\\n    const int arr[] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\\r\\n    const size_t arraySize = sizeof(arr) / sizeof(arr[0]); // Get array size\\r\\n\\r\\n    // Get valid integer input\\r\\n    int index = getIntegerInput();\\r\\n\\r\\n    // Get the value at the input index or handle error\\r\\n    int value = getValueAtIndex(arr, arraySize, index);\\r\\n\\r\\n    // Display the result\\r\\n    if (value != -1) {\\r\\n        std::cout << \"Value at index \" << index << \" is: \" << value << std::endl;\\r\\n    } else {\\r\\n        std::cout << \"Invalid index provided.\" << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-125"}
{"text": "Generate C++ code for the following: The code reads in a value from the command line and adds an offset of 1000 to it. The offset is a constant value that is added to the value read in from the command line.", "BP": ["Input Validation", "Integer Overflow/Underflow Prevention", "Secure Coding Practices", "Error Handling"], "code": "#include <iostream>\\r\\n#include <limits>\\r\\n#include <cstdlib>\\r\\n#include <cerrno>\\r\\n#include <climits>\\r\\n\\r\\nconst int OFFSET = 1000;\\r\\n\\r\\nbool isInteger(const char* str, int& outValue) {\\r\\n    char* end;\\r\\n    errno = 0; // Reset errno before calling strtol\\r\\n    long value = std::strtol(str, &end, 10);\\r\\n\\r\\n    // Check for conversion errors\\r\\n    if (errno == ERANGE || value < INT_MIN || value > INT_MAX) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // Ensure entire string was converted and no extra characters exist\\r\\n    if (*end != '\\0') {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    outValue = static_cast<int>(value);\\r\\n    return true;\\r\\n}\\r\\n\\r\\nbool willAdditionOverflow(int a, int b) {\\r\\n    if (b > 0 && a > INT_MAX - b) {\\r\\n        return true; // Overflow\\r\\n    }\\r\\n    if (b < 0 && a < INT_MIN - b) {\\r\\n        return true; // Underflow\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <integer>\\n\";\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    int inputValue;\\r\\n    if (!isInteger(argv[1], inputValue)) {\\r\\n        std::cerr << \"Error: Invalid input. Please enter a valid integer.\\n\";\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    // Check for overflow/underflow when adding OFFSET\\r\\n    if (willAdditionOverflow(inputValue, OFFSET)) {\\r\\n        std::cerr << \"Error: Addition of \" << OFFSET << \" would result in overflow or underflow.\\n\";\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    int result = inputValue + OFFSET;\\r\\n\\r\\n    std::cout << \"Result: \" << result << std::endl;\\r\\n    return EXIT_SUCCESS;\\r\\n}", "CWE": "CWE-190"}
{"text": "Generate C++ code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": ["Input Validation", "Secure Input Conversion", "Error Handling", "Secure Coding Practices"], "code": "#include <iostream>\\r\\n#include <cstdlib>   // For std::strtol\\r\\n#include <cerrno>    // For errno\\r\\n#include <climits>   // For INT_MAX and INT_MIN\\r\\n\\r\\nint main(int argc, char *argv[]) {\\r\\n    // Ensure at least one argument is passed (the program name is counted as an argument)\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Error: Please provide exactly one integer argument.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    char *endptr = nullptr;\\r\\n    errno = 0;  // Reset errno before calling strtol\\r\\n\\r\\n    // Attempt to convert the input string to a long integer\\r\\n    long value = std::strtol(argv[1], &endptr, 10);\\r\\n\\r\\n    // Check for conversion errors\\r\\n    if (errno == ERANGE || value > INT_MAX || value < INT_MIN) {\\r\\n        std::cerr << \"Error: The value is out of range.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    if (endptr == argv[1] || *endptr != '\\0') {\\r\\n        std::cerr << \"Error: Invalid input. Please enter a valid integer.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Now that the input is validated, we can safely add 1000 to it\\r\\n    int result = static_cast<int>(value) + 1000;\\r\\n\\r\\n    // Output the result\\r\\n    std::cout << \"Result: \" << result << std::endl;\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-190"}
{"text": "Generate C++ code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP": ["Input Validation", "Data Type Conversion", "Error Handling", "Integer Overflow/Underflow Check", "Separation of Concerns", "Secure Function Usage"], "code": "#include <iostream>\\r\\n#include <stdexcept>\\r\\n#include <climits> // for INT_MAX, INT_MIN\\r\\n#include <cstdlib> // for strtol\\r\\n#include <cerrno>  // for errno\\r\\n\\r\\n// Function to safely convert string to integer\\r\\nlong safeStringToInt(const char* str) {\\r\\n    char* end;\\r\\n    errno = 0; // reset errno before the conversion\\r\\n    long value = std::strtol(str, &end, 10);\\r\\n\\r\\n    // Check for conversion errors\\r\\n    if (errno == ERANGE || value > INT_MAX || value < INT_MIN) {\\r\\n        throw std::out_of_range(\"Integer overflow or underflow\");\\r\\n    }\\r\\n    if (*end != '\\0') {\\r\\n        throw std::invalid_argument(\"Invalid input: Not a valid integer\");\\r\\n    }\\r\\n\\r\\n    return value;\\r\\n}\\r\\n\\r\\n// Function to safely add 1000 and check for overflow/underflow\\r\\nint safeAdd(int value, int to_add) {\\r\\n    if (value > 0 && to_add > INT_MAX - value) {\\r\\n        throw std::overflow_error(\"Integer overflow\");\\r\\n    }\\r\\n    if (value < 0 && to_add < INT_MIN - value) {\\r\\n        throw std::underflow_error(\"Integer underflow\");\\r\\n    }\\r\\n    return value + to_add;\\r\\n}\\r\\n\\r\\n// Main function\\r\\nint main(int argc, char* argv[]) {\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <integer>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        // Convert input string to integer safely\\r\\n        int value = static_cast<int>(safeStringToInt(argv[1]));\\r\\n\\r\\n        // Add 1000 safely, checking for overflow/underflow\\r\\n        int result = safeAdd(value, 1000);\\r\\n\\r\\n        std::cout << \"Result: \" << result << std::endl;\\r\\n    } catch (const std::exception& e) {\\r\\n        // Catch any exceptions and display error message\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-190"}
{"text": "Generate C++ code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a page with the username; email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": ["Session Management", "Password Hashing", "Input Validation", "Input Sanitization", "Error Handling", "Secure Transmission", "Access Control", "Secure Coding Practices", "User Authentication and Authorization", "Logging and Monitoring", "Secure Configuration"], "code": "#include \"crow.h\"\\r\\n#include <openssl/sha.h>\\r\\n#include <openssl/rand.h>\\r\\n#include <unordered_map>\\r\\n#include <regex>\\r\\n#include <string>\\r\\n#include <iostream>\\r\\n\\r\\n// A simple in-memory session storage (for demo purposes)\\r\\nstd::unordered_map<std::string, crow::json::wvalue> session_store;\\r\\n\\r\\n// Dummy database for users (in real-world, use proper database storage)\\r\\nstruct User {\\r\\n    std::string username;\\r\\n    std::string email;\\r\\n    std::string hashed_password;\\r\\n    std::string ssn;\\r\\n};\\r\\n\\r\\nstd::unordered_map<std::string, User> user_db = {\\r\\n    {\"john_doe\", {\"john_doe\", \"john@example.com\", \"5e88489f\", \"123456789\"}}\\r\\n};\\r\\n\\r\\n// Function to hash passwords using SHA-256\\r\\nstd::string hash_password(const std::string& password) {\\r\\n    unsigned char hash[SHA256_DIGEST_LENGTH];\\r\\n    SHA256_CTX sha256;\\r\\n    SHA256_Init(&sha256);\\r\\n    SHA256_Update(&sha256, password.c_str(), password.size());\\r\\n    SHA256_Final(hash, &sha256);\\r\\n\\r\\n    char buffer[65];\\r\\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {\\r\\n        sprintf(buffer + (i * 2), \"%02x\", hash[i]);\\r\\n    }\\r\\n    buffer[64] = 0;\\r\\n    return std::string(buffer);\\r\\n}\\r\\n\\r\\n// Input validation function\\r\\nbool validate_input(const std::string& username, const std::string& password) {\\r\\n    // Validate using regex (e.g., alphanumeric for username, strong password)\\r\\n    std::regex username_pattern(\"^[a-zA-Z0-9_]{3,16}$\");\\r\\n    std::regex password_pattern(\"^(?=.*[A-Za-z])(?=.*\\\\d)[A-Za-z\\\\d]{8,}$\");\\r\\n\\r\\n    return std::regex_match(username, username_pattern) &&\\r\\n           std::regex_match(password, password_pattern);\\r\\n}\\r\\n\\r\\n// Sanitize input to prevent XSS attacks\\r\\nstd::string sanitize_input(const std::string& input) {\\r\\n    std::string sanitized = input;\\r\\n    std::replace(sanitized.begin(), sanitized.end(), '<', '[');\\r\\n    std::replace(sanitized.begin(), sanitized.end(), '>', ']');\\r\\n    return sanitized;\\r\\n}\\r\\n\\r\\n// Function to authenticate user\\r\\nbool authenticate(const std::string& username, const std::string& password) {\\r\\n    auto it = user_db.find(username);\\r\\n    if (it != user_db.end()) {\\r\\n        std::string hashed_password = hash_password(password);\\r\\n        return it->second.hashed_password == hashed_password;\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\n\\r\\n// Middleware to check if the user is authenticated\\r\\nbool is_authenticated(const std::string& session_id) {\\r\\n    return session_store.find(session_id) != session_store.end();\\r\\n}\\r\\n\\r\\n// Error page handler\\r\\ncrow::response error_page(const std::string& message) {\\r\\n    crow::json::wvalue error_response;\\r\\n    error_response[\"error\"] = message;\\r\\n    return crow::response(400, error_response);\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    crow::SimpleApp app;\\r\\n\\r\\n    // Secure transmission (HTTPS should be configured properly in production)\\r\\n    CROW_ROUTE(app, \"/login\")\\r\\n        .methods(\"POST\"_method)\\r\\n    ([&](const crow::request& req) {\\r\\n        auto body = crow::json::load(req.body);\\r\\n        if (!body) {\\r\\n            return error_page(\"Invalid input\");\\r\\n        }\\r\\n\\r\\n        std::string username = sanitize_input(body[\"username\"].s());\\r\\n        std::string password = sanitize_input(body[\"password\"].s());\\r\\n\\r\\n        // Validate input\\r\\n        if (!validate_input(username, password)) {\\r\\n            return error_page(\"Invalid username or password format.\");\\r\\n        }\\r\\n\\r\\n        // Authenticate user\\r\\n        if (!authenticate(username, password)) {\\r\\n            return error_page(\"Authentication failed.\");\\r\\n        }\\r\\n\\r\\n        // Create a new session (for demo, session id is just random)\\r\\n        std::string session_id = crow::utility::random_string(32);\\r\\n\\r\\n        session_store[session_id] = {{\"username\", username}, {\"email\", user_db[username].email}, {\"ssn\", user_db[username].ssn}};\\r\\n\\r\\n        // Return the session ID as a cookie\\r\\n        crow::response res;\\r\\n        res.set_header(\"Set-Cookie\", \"session_id=\" + session_id + \"; HttpOnly; Secure; SameSite=Strict;\");\\r\\n        res.code = 200;\\r\\n        res.body = \"Login successful\";\\r\\n        return res;\\r\\n    });\\r\\n\\r\\n    // Secure route to access user info\\r\\n    CROW_ROUTE(app, \"/info\").methods(\"GET\"_method)([](const crow::request& req) {\\r\\n        std::string session_id = req.get_header_value(\"Cookie\");\\r\\n\\r\\n        // Check if the session is valid\\r\\n        if (session_id.empty() || !is_authenticated(session_id)) {\\r\\n            return error_page(\"Unauthorized access. Please log in.\");\\r\\n        }\\r\\n\\r\\n        auto session_data = session_store[session_id];\\r\\n        std::string username = session_data[\"username\"].s();\\r\\n        std::string email = session_data[\"email\"].s();\\r\\n        std::string ssn = session_data[\"ssn\"].s();\\r\\n\\r\\n        // Mask SSN (only showing last 4 digits)\\r\\n        std::string masked_ssn = \"XXX-XX-\" + ssn.substr(ssn.length() - 4);\\r\\n\\r\\n        crow::json::wvalue result;\\r\\n        result[\"username\"] = sanitize_input(username);\\r\\n        result[\"email\"] = sanitize_input(email);\\r\\n        result[\"ssn\"] = masked_ssn;\\r\\n\\r\\n        return crow::response(200, result);\\r\\n    });\\r\\n\\r\\n    // Secure server settings (SSL/TLS)\\r\\n    // NOTE: In production, configure actual SSL certificates\\r\\n    app.bindaddr(\"0.0.0.0\").port(18080).run();\\r\\n}", "CWE": "CWE-200"}
{"text": "Generate C++ code for the following: The with statement is used to wrap the execution of a block with methods defined by a context manager. The tarfile module makes it possible to read and write tar archives including those using gzip or bz2 compression. The open() function opens and returns a file handle that can be used to read or write a file in the usual way.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Exception Management", "Secure Memory Management"], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <stdexcept>\\r\\n#include <memory>\\r\\n#include <regex>\\r\\n\\r\\n// Class to manage file opening and closing using RAII\\r\\nclass FileManager {\\r\\npublic:\\r\\n    FileManager(const std::string& filename) {\\r\\n        validateFilename(filename); // Validate the filename for security\\r\\n\\r\\n        file.open(filename, std::ios::in | std::ios::binary);  // Open file in binary read mode\\r\\n\\r\\n        if (!file.is_open()) {\\r\\n            throw std::runtime_error(\"Error: Could not open the file.\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ~FileManager() {\\r\\n        if (file.is_open()) {\\r\\n            file.close();  // Automatically close the file\\r\\n        }\\r\\n    }\\r\\n\\r\\n    std::ifstream& getFile() {\\r\\n        return file;\\r\\n    }\\r\\n\\r\\nprivate:\\r\\n    std::ifstream file;\\r\\n\\r\\n    void validateFilename(const std::string& filename) {\\r\\n        // Ensure the filename only contains valid characters\\r\\n        std::regex validPattern(\"^[a-zA-Z0-9_\\\\-\\\\.]+$\");\\r\\n        if (!std::regex_match(filename, validPattern)) {\\r\\n            throw std::invalid_argument(\"Error: Invalid filename provided.\");\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\n// Function to read and process the file\\r\\nvoid processFile(const std::string& filename) {\\r\\n    try {\\r\\n        FileManager fileManager(filename);  // RAII will handle file opening/closing\\r\\n        std::ifstream& file = fileManager.getFile();\\r\\n\\r\\n        // Secure memory management using unique_ptr for buffer\\r\\n        std::unique_ptr<char[]> buffer(new char[1024]);\\r\\n        while (file.read(buffer.get(), 1024)) {\\r\\n            // Simulate processing the file (e.g., reading the tar contents)\\r\\n            std::cout << \"Processing 1024 bytes of data...\\n\";\\r\\n        }\\r\\n\\r\\n        if (file.eof()) {\\r\\n            std::cout << \"Finished processing the file.\\n\";\\r\\n        } else {\\r\\n            throw std::runtime_error(\"Error: File read interrupted.\");\\r\\n        }\\r\\n\\r\\n    } catch (const std::invalid_argument& e) {\\r\\n        std::cerr << e.what() << '\\n';\\r\\n    } catch (const std::runtime_error& e) {\\r\\n        std::cerr << \"Runtime error: \" << e.what() << '\\n';\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << \"An unexpected error occurred: \" << e.what() << '\\n';\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::string filename;\\r\\n    \\r\\n    // Input validation\\r\\n    std::cout << \"Enter the file name: \";\\r\\n    std::getline(std::cin, filename);\\r\\n\\r\\n    try {\\r\\n        processFile(filename);\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << \"Failed to process the file: \" << e.what() << '\\n';\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-22"}
