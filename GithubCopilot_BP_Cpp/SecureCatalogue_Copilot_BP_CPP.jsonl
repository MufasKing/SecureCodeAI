{"text": "Generate C++ code for the following: The code takes in a command line argument and converts it to an integer.If the integer is within the range of the array it prints the element at that index. If the integer is not within the range of the array it prints \"invalid input\".", "BP": ["Handling Command-Line Arguments", "Integer Conversion", "Error Checking", "Array Index Validation", "Secure Output"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Define an array of integers\\r\\n    int arr[] = {10, 20, 30, 40, 50};\\r\\n    int arrSize = sizeof(arr) / sizeof(arr[0]);\\r\\n\\r\\n    // Check if the correct number of arguments is provided\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <index>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        // Convert the command-line argument to an integer\\r\\n        int index = std::stoi(argv[1]);\\r\\n\\r\\n        // Validate the index\\r\\n        if (index >= 0 && index < arrSize) {\\r\\n            std::cout << \"Element at index \" << index << \" is \" << arr[index] << std::endl;\\r\\n        } else {\\r\\n            std::cerr << \"invalid input\" << std::endl;\\r\\n        }\\r\\n    } catch (const std::invalid_argument& e) {\\r\\n        std::cerr << \"invalid input\" << std::endl;\\r\\n    } catch (const std::out_of_range& e) {\\r\\n        std::cerr << \"invalid input\" << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: atoi() is a function that converts a string to an integer. Command line arguments at index 1 is the second argument passed to the program. Command line argument at index INDEX is the argument at the INDEX specified by the second argument. print function prints the string at INDEX position in the command line arguments to the screen. return 0. exit the program.", "BP": ["Validating user input", "Using strtol instead of atoi", "Checking the range of the converted integer", "Avoiding unnecessary use of string objects"], "code": "#include <iostream>\\r\\n#include <cstdlib>\\r\\n#include <climits>\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Validate the number of arguments\\r\\n    if (argc < 3) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <index> <arg1> <arg2> ... <argN>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Convert the second argument to an integer using strtol\\r\\n    char* end;\\r\\n    long index = std::strtol(argv[1], &end, 10);\\r\\n\\r\\n    // Check for conversion errors\\r\\n    if (*end != '\\0' || index < 1 || index >= argc) {\\r\\n        std::cerr << \"Invalid index: \" << argv[1] << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Check if the converted index is within the valid range\\r\\n    if (index < 1 || index >= argc) {\\r\\n        std::cerr << \"Index out of range: \" << index << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Print the argument at the specified index\\r\\n    std::cout << argv[index] << std::endl;\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: atoi() converts a string to an integer. argc is the number of arguments passed to the program. Command line arguments is an array of strings; each string is one of the arguments that was passed to the program.The first argument is always the name of the program so if the user ran ./a.out foo bar baz; argc would be 4; argv[0] would be ./a.out argv.r", "BP": ["Use of Secure Functions", "Error Checking", "Command-Line Argument Validation", "Avoiding Integer Overflow and Underflow"], "code": "#include <iostream>\\r\\n#include <climits>\\r\\n#include <cstdlib>\\r\\n#include <cerrno>\\r\\n\\r\\nint main(int argc, char *argv[]) {\\r\\n    // Check if the correct number of arguments is passed\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <number>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Initialize variables for conversion\\r\\n    char *endptr;\\r\\n    errno = 0; // To distinguish success/failure after call\\r\\n\\r\\n    // Convert string to long\\r\\n    long val = strtol(argv[1], &endptr, 10);\\r\\n\\r\\n    // Check for various possible errors\\r\\n    if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) || (errno != 0 && val == 0)) {\\r\\n        perror(\"strtol\");\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    if (endptr == argv[1]) {\\r\\n        std::cerr << \"No digits were found in the input.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Check for integer overflow/underflow\\r\\n    if (val > INT_MAX || val < INT_MIN) {\\r\\n        std::cerr << \"Integer overflow or underflow occurred.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Successful conversion\\r\\n    int result = static_cast<int>(val);\\r\\n    std::cout << \"Converted integer: \" << result << std::endl;\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: The code takes an index as an argument and prints the corresponding argument from the command line arguments.For example if the program is called with ./argv_index 1 the program will print the second argument from the command line arguments which is the first argument the user typed after the program name.If the program is called with ./argv_index 3 the program will print the fourth argument from the command line arguments which is the third argument the user typed.", "BP": ["Input Validation", "Error Handling", "Secure String Handling"], "code": "#include <iostream>\\r\\n#include <cstdlib>\\r\\n#include <cstring>\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Check if the index argument is provided\\r\\n    if (argc < 2) {\\r\\n        std::cerr << \"Error: No index provided.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Convert the index argument to an integer\\r\\n    char* end;\\r\\n    long index = std::strtol(argv[1], &end, 10);\\r\\n\\r\\n    // Check if the conversion was successful and the index is a valid number\\r\\n    if (*end != '\\0' || index < 1) {\\r\\n        std::cerr << \"Error: Invalid index provided.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Check if the index is within the range of provided arguments\\r\\n    if (index >= argc) {\\r\\n        std::cerr << \"Error: Index out of range.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Print the corresponding argument\\r\\n    std::cout << \"Argument at index \" << index << \": \" << argv[index] << std::endl;\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-119"}
{"text": "Generate C++ code for the following: The code reads in a value from the command line and adds 1000 to it.\t", "BP": ["Input Validation", "Secure Input Conversion", "Error Handling", "Overflow/Underflow Checking", "Appropriate Data Type"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n#include <limits>\\r\\n#include <cstdlib>\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <number>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        // Secure input conversion\\r\\n        std::string input = argv[1];\\r\\n        size_t pos;\\r\\n        long long number = std::stoll(input, &pos);\\r\\n\\r\\n        // Check if the entire string was converted\\r\\n        if (pos < input.size()) {\\r\\n            throw std::invalid_argument(\"Invalid input: not a valid number\");\\r\\n        }\\r\\n\\r\\n        // Overflow/Underflow checking\\r\\n        if (number > std::numeric_limits<int>::max() - 1000 || number < std::numeric_limits<int>::min() + 1000) {\\r\\n            throw std::overflow_error(\"Overflow or underflow detected\");\\r\\n        }\\r\\n\\r\\n        int result = static_cast<int>(number) + 1000;\\r\\n        std::cout << \"Result: \" << result << std::endl;\\r\\n    } catch (const std::invalid_argument& e) {\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n        return 1;\\r\\n    } catch (const std::out_of_range& e) {\\r\\n        std::cerr << \"Error: Number out of range\" << std::endl;\\r\\n        return 1;\\r\\n    } catch (const std::overflow_error& e) {\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-190"}
{"text": "Generate C++ code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": ["Input Validation", "Error Handling", "Integer Overflow Protection", "Secure String Handling"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <limits>\\r\\n#include <stdexcept>\\r\\n#include <sstream>\\r\\n\\r\\nconst int OFFSET = 1000;\\r\\n\\r\\nbool isValidInteger(const std::string& str) {\\r\\n    std::istringstream iss(str);\\r\\n    int num;\\r\\n    iss >> num;\\r\\n    return iss.eof() && !iss.fail();\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::string input;\\r\\n    std::cout << \"Enter an integer value: \";\\r\\n    std::getline(std::cin, input);\\r\\n\\r\\n    if (!isValidInteger(input)) {\\r\\n        std::cerr << \"Invalid input. Please enter a valid integer.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        int value = std::stoi(input);\\r\\n\\r\\n        if (value > std::numeric_limits<int>::max() - OFFSET) {\\r\\n            throw std::overflow_error(\"Integer overflow detected.\");\\r\\n        }\\r\\n\\r\\n        int result = value + OFFSET;\\r\\n        std::cout << \"Result after adding offset: \" << result << std::endl;\\r\\n    } catch (const std::invalid_argument& e) {\\r\\n        std::cerr << \"Invalid input. Please enter a valid integer.\" << std::endl;\\r\\n        return 1;\\r\\n    } catch (const std::out_of_range& e) {\\r\\n        std::cerr << \"Input value is out of range.\" << std::endl;\\r\\n        return 1;\\r\\n    } catch (const std::overflow_error& e) {\\r\\n        std::cerr << e.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-190"}
{"text": "Generate C++ code for the following: The code reads in a value from the command line and adds 1000 to it.The code then prints the value to the console.The code then returns 0.", "BP": ["Input Validation", "Error Handling", "RAII", "Const-Correctness"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n#include <memory>\\r\\n\\r\\nint readAndValidateInput(const std::string& input) {\\r\\n    try {\\r\\n        size_t pos;\\r\\n        int value = std::stoi(input, &pos);\\r\\n        if (pos < input.size()) {\\r\\n            throw std::invalid_argument(\"Trailing characters after number\");\\r\\n        }\\r\\n        return value;\\r\\n    } catch (const std::invalid_argument& e) {\\r\\n        throw std::runtime_error(\"Invalid input: not a valid integer\");\\r\\n    } catch (const std::out_of_range& e) {\\r\\n        throw std::runtime_error(\"Invalid input: integer out of range\");\\r\\n    }\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <integer>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        const std::string input(argv[1]);\\r\\n        int value = readAndValidateInput(input);\\r\\n        value += 1000;\\r\\n        std::cout << \"Result: \" << value << std::endl;\\r\\n    } catch (const std::runtime_error& e) {\\r\\n        std::cerr << e.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-190"}
{"text": "Generate C++ code for the following: The login page is a simple form with a username and password field. The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page.The index page is a simple page that has a link to the login page.The secret page is a simple page that says; \"Secret settings\".", "BP": ["Secure Password Storage", "Secure Authentication", "Input Validation", "Session Management", "Least Privilege"], "code": "#include <iostream>\\r\\n#include <unordered_map>\\r\\n#include <string>\\r\\n#include <regex>\\r\\n#include <openssl/sha.h>\\r\\n#include <ctime>\\r\\n#include <cstdlib>\\r\\n#include <iomanip>\r\\n// Simulated session storage\\r\\nstd::unordered_map<std::string, std::string> session;\\r\\n\\r\\n// Simulated user database with hashed passwords\\r\\nstd::unordered_map<std::string, std::string> user_db = {\\r\\n    {\"user1\", \"5e884898da28047151d0e56f8dc6292773603d0d6aabbddf8a6e0e4b0b8f1e5e\"} // password: \"password\"\\r\\n};\\r\\n\\r\\n// Function to hash passwords\\r\\nstd::string hash_password(const std::string& password) {\\r\\n    unsigned char hash[SHA256_DIGEST_LENGTH];\\r\\n    SHA256_CTX sha256;\\r\\n    SHA256_Init(&sha256);\\r\\n    SHA256_Update(&sha256, password.c_str(), password.size());\\r\\n    SHA256_Final(hash, &sha256);\\r\\n    std::stringstream ss;\\r\\n    for(int i = 0; i < SHA256_DIGEST_LENGTH; i++) {\\r\\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\\r\\n    }\\r\\n    return ss.str();\\r\\n}\\r\\n\\r\\n// Function to validate input\\r\\nbool validate_input(const std::string& input) {\\r\\n    std::regex pattern(\"^[a-zA-Z0-9_]+$\");\\r\\n    return std::regex_match(input, pattern);\\r\\n}\\r\\n\\r\\n// Function to handle login\\r\\nbool do_login(const std::string& username, const std::string& password) {\\r\\n    if (!validate_input(username) || !validate_input(password)) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    std::string hashed_password = hash_password(password);\\r\\n    if (user_db.find(username) != user_db.end() && user_db[username] == hashed_password) {\\r\\n        session[\"username\"] = username;\\r\\n        return true;\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\n\\r\\n// Function to check if user is logged in\\r\\nbool is_logged_in() {\\r\\n    return session.find(\"username\") != session.end();\\r\\n}\\r\\n\\r\\n// Function to display index page\\r\\nvoid display_index_page() {\\r\\n    std::cout << \"<html><body><a href='/login'>Login</a></body></html>\" << std::endl;\\r\\n}\\r\\n\\r\\n// Function to display login page\\r\\nvoid display_login_page() {\\r\\n    std::cout << \"<html><body>\"\\r\\n              << \"<form method='POST' action='/do_login'>\"\\r\\n              << \"Username: <input type='text' name='username'><br>\"\\r\\n              << \"Password: <input type='password' name='password'><br>\"\\r\\n              << \"<input type='submit' value='Login'>\"\\r\\n              << \"</form></body></html>\" << std::endl;\\r\\n}\\r\\n\\r\\n// Function to display secret page\\r\\nvoid display_secret_page() {\\r\\n    if (is_logged_in()) {\\r\\n        std::cout << \"<html><body>Secret settings</body></html>\" << std::endl;\\r\\n    } else {\\r\\n        std::cout << \"<html><body>Access Denied</body></html>\" << std::endl;\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    // Simulate different pages\\r\\n    display_index_page();\\r\\n    display_login_page();\\r\\n    if (do_login(\"user1\", \"password\")) {\\r\\n        display_secret_page();\\r\\n    } else {\\r\\n        std::cout << \"Login failed\" << std::endl;\\r\\n    }\\r\\n    return 0;\\r\\n}", "CWE": "CWE-306"}
{"text": "Generate C++ code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email; new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email.", "BP": ["Password Hashing", "Input Validation", "Secure String Handling", "Separation of Concerns", "Secure Authentication"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <regex>\\r\\n#include <openssl/sha.h>\\r\\n#include <iomanip>\\r\\n#include <sstream>\\r\\n\\r\\n// Utility function to hash a password\\r\\nstd::string hashPassword(const std::string& password) {\\r\\n    unsigned char hash[SHA256_DIGEST_LENGTH];\\r\\n    SHA256_CTX sha256;\\r\\n    SHA256_Init(&sha256);\\r\\n    SHA256_Update(&sha256, password.c_str(), password.size());\\r\\n    SHA256_Final(hash, &sha256);\\r\\n    std::stringstream ss;\\r\\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\\r\\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\\r\\n    }\\r\\n    return ss.str();\\r\\n}\\r\\n\\r\\n// Utility function to validate email format\\r\\nbool validateEmail(const std::string& email) {\\r\\n    const std::regex pattern(R\"((\\w+)(\\.{1}\\w+)*@(\\w+)(\\.\\w{2,3})+)\");\\r\\n    return std::regex_match(email, pattern);\\r\\n}\\r\\n\\r\\n// Secure string comparison\\r\\nbool secureCompare(const std::string& a, const std::string& b) {\\r\\n    if (a.size() != b.size()) return false;\\r\\n    volatile unsigned char result = 0;\\r\\n    for (size_t i = 0; i < a.size(); ++i) {\\r\\n        result |= a[i] ^ b[i];\\r\\n    }\\r\\n    return result == 0;\\r\\n}\\r\\n\\r\\nclass User {\\r\\nprivate:\\r\\n    std::string username;\\r\\n    std::string email;\\r\\n    std::string hashedPassword;\\r\\n\\r\\npublic:\\r\\n    User(const std::string& uname, const std::string& mail, const std::string& password)\\r\\n        : username(uname), email(mail), hashedPassword(hashPassword(password)) {}\\r\\n\\r\\n    bool login(const std::string& uname, const std::string& password) {\\r\\n        return (username == uname && secureCompare(hashedPassword, hashPassword(password)));\\r\\n    }\\r\\n\\r\\n    bool changeEmail(const std::string& oldEmail, const std::string& newEmail, const std::string& password) {\\r\\n        if (!secureCompare(email, oldEmail)) {\\r\\n            std::cerr << \"Old email does not match.\" << std::endl;\\r\\n            return false;\\r\\n        }\\r\\n        if (!validateEmail(newEmail)) {\\r\\n            std::cerr << \"Invalid new email format.\" << std::endl;\\r\\n            return false;\\r\\n        }\\r\\n        if (secureCompare(email, newEmail)) {\\r\\n            std::cerr << \"New email must be different from the old email.\" << std::endl;\\r\\n            return false;\\r\\n        }\\r\\n        if (!secureCompare(hashedPassword, hashPassword(password))) {\\r\\n            std::cerr << \"Incorrect password.\" << std::endl;\\r\\n            return false;\\r\\n        }\\r\\n        email = newEmail;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    std::string getEmail() const {\\r\\n        return email;\\r\\n    }\\r\\n};\\r\\n\\r\\nint main() {\\r\\n    User user(\"john_doe\", \"john@example.com\", \"securepassword123\");\\r\\n\\r\\n    std::string username, password, oldEmail, newEmail, confirmPassword;\\r\\n\\r\\n    std::cout << \"Login\\nUsername: \";\\r\\n    std::cin >> username;\\r\\n    std::cout << \"Password: \";\\r\\n    std::cin >> password;\\r\\n\\r\\n    if (user.login(username, password)) {\\r\\n        std::cout << \"Login successful.\\n\";\\r\\n\\r\\n        std::cout << \"Enter old email: \";\\r\\n        std::cin >> oldEmail;\\r\\n        std::cout << \"Enter new email: \";\\r\\n        std::cin >> newEmail;\\r\\n        std::cout << \"Confirm password: \";\\r\\n        std::cin >> confirmPassword;\\r\\n\\r\\n        if (user.changeEmail(oldEmail, newEmail, confirmPassword)) {\\r\\n            std::cout << \"Email changed successfully to \" << user.getEmail() << \".\\n\";\\r\\n        } else {\\r\\n            std::cerr << \"Failed to change email.\\n\";\\r\\n        }\\r\\n    } else {\\r\\n        std::cerr << \"Login failed.\\n\";\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-306"}
{"text": "Generate C++ code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email; new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": ["Secure Password Storage", "Password Verification", "Input Validation", "User Authentication", "Random Number Generation", "Separation of Concerns", "Error Handling", "Data Encryption", "Secure Session Management", "Rate-Limiting"], "code": "#include <iostream>\\r\\n#include <unordered_map>\\r\\n#include <string>\\r\\n#include <random>\\r\\n#include <stdexcept>\\r\\n#include <openssl/sha.h>\\r\\n#include <openssl/rand.h>\\r\\n\\r\\nclass User {\\r\\npublic:\\r\\n    std::string email;\\r\\n    std::string passwordHash;\\r\\n    std::string salt;\\r\\n\\r\\n    User(const std::string& email, const std::string& password) {\\r\\n        this->email = email;\\r\\n        this->salt = generateSalt();\\r\\n        this->passwordHash = hashPassword(password, this->salt);\\r\\n    }\\r\\n\\r\\n    bool verifyPassword(const std::string& password) {\\r\\n        return hashPassword(password, this->salt) == this->passwordHash;\\r\\n    }\\r\\n\\r\\nprivate:\\r\\n    std::string generateSalt() {\\r\\n        unsigned char buffer[16];\\r\\n        RAND_bytes(buffer, sizeof(buffer));\\r\\n        return std::string(reinterpret_cast<char*>(buffer), sizeof(buffer));\\r\\n    }\\r\\n\\r\\n    std::string hashPassword(const std::string& password, const std::string& salt) {\\r\\n        std::string saltedPassword = password + salt;\\r\\n        unsigned char hash[SHA256_DIGEST_LENGTH];\\r\\n        SHA256(reinterpret_cast<const unsigned char*>(saltedPassword.c_str()), saltedPassword.size(), hash);\\r\\n        return std::string(reinterpret_cast<char*>(hash), SHA256_DIGEST_LENGTH);\\r\\n    }\\r\\n};\\r\\n\\r\\nclass UserManager {\\r\\npublic:\\r\\n    void addUser(const std::string& email, const std::string& password) {\\r\\n        if (users.find(email) != users.end()) {\\r\\n            throw std::runtime_error(\"User already exists\");\\r\\n        }\\r\\n        users[email] = User(email, password);\\r\\n    }\\r\\n\\r\\n    bool authenticateUser(const std::string& email, const std::string& password) {\\r\\n        if (users.find(email) == users.end()) {\\r\\n            return false;\\r\\n        }\\r\\n        return users[email].verifyPassword(password);\\r\\n    }\\r\\n\\r\\n    void changeEmail(const std::string& oldEmail, const std::string& newEmail, const std::string& password) {\\r\\n        if (users.find(oldEmail) == users.end()) {\\r\\n            throw std::runtime_error(\"User does not exist\");\\r\\n        }\\r\\n        if (!users[oldEmail].verifyPassword(password)) {\\r\\n            throw std::runtime_error(\"Incorrect password\");\\r\\n        }\\r\\n        if (users.find(newEmail) != users.end()) {\\r\\n            throw std::runtime_error(\"New email already in use\");\\r\\n        }\\r\\n        User user = users[oldEmail];\\r\\n        users.erase(oldEmail);\\r\\n        user.email = newEmail;\\r\\n        users[newEmail] = user;\\r\\n    }\\r\\n\\r\\nprivate:\\r\\n    std::unordered_map<std::string, User> users;\\r\\n};\\r\\n\\r\\nint main() {\\r\\n    UserManager userManager;\\r\\n    std::string email, password, newEmail, confirmPassword;\\r\\n\\r\\n    try {\\r\\n        // Add a user\\r\\n        std::cout << \"Register a new user\\n\";\\r\\n        std::cout << \"Email: \";\\r\\n        std::cin >> email;\\r\\n        std::cout << \"Password: \";\\r\\n        std::cin >> password;\\r\\n        userManager.addUser(email, password);\\r\\n\\r\\n        // Authenticate user\\r\\n        std::cout << \"\\nLogin\\n\";\\r\\n        std::cout << \"Email: \";\\r\\n        std::cin >> email;\\r\\n        std::cout << \"Password: \";\\r\\n        std::cin >> password;\\r\\n        if (!userManager.authenticateUser(email, password)) {\\r\\n            throw std::runtime_error(\"Authentication failed\");\\r\\n        }\\r\\n\\r\\n        // Change email\\r\\n        std::cout << \"\\nChange Email\\n\";\\r\\n        std::cout << \"Old Email: \";\\r\\n        std::cin >> email;\\r\\n        std::cout << \"New Email: \";\\r\\n        std::cin >> newEmail;\\r\\n        std::cout << \"Confirm Password: \";\\r\\n        std::cin >> confirmPassword;\\r\\n        userManager.changeEmail(email, newEmail, confirmPassword);\\r\\n\\r\\n        std::cout << \"Email changed successfully\\n\";\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << \"Error: \" << e.what() << '\\n';\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-306"}
{"text": "Generate C++ code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate.The program allocates a buffer of the specified size.The program prints the contents of the buffer.The program exits.", "BP": ["Input Validation", "Dynamic Memory Allocation", "Secure Buffer Initialization", "Safe Printing", "Memory Deallocation"], "code": "#include <iostream>\\r\\n#include <cstdlib> // For std::atoi\\r\\n#include <cstring> // For std::memset\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Step 1: Input Validation\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <buffer_size>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    int bufferSize = std::atoi(argv[1]);\\r\\n    if (bufferSize <= 0) {\\r\\n        std::cerr << \"Error: Buffer size must be a positive integer.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Step 2: Dynamic Memory Allocation\\r\\n    char* buffer = new(std::nothrow) char[bufferSize];\\r\\n    if (!buffer) {\\r\\n        std::cerr << \"Error: Memory allocation failed.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Step 3: Secure Buffer Initialization\\r\\n    std::memset(buffer, 0, bufferSize);\\r\\n\\r\\n    // Step 4: Safe Printing\\r\\n    std::cout << \"Buffer contents: \";\\r\\n    for (int i = 0; i < bufferSize; ++i) {\\r\\n        std::cout << static_cast<int>(buffer[i]) << \" \";\\r\\n    }\\r\\n    std::cout << std::endl;\\r\\n\\r\\n    // Step 5: Memory Deallocation\\r\\n    delete[] buffer;\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-416"}
{"text": "Generate C++ code for the following: The code allocates a buffer of size buffer_size.Then it frees the buffer in a loop. ", "BP": ["Error Handling", "Memory Initialization", "Memory Deallocation", "Appropriate Memory Management"], "code": "#include <iostream>\\r\\n#include <stdexcept>\\r\\n\\r\\nvoid allocateAndFreeBuffer(size_t buffer_size, int iterations) {\\r\\n    for (int i = 0; i < iterations; ++i) {\\r\\n        // Allocate memory\\r\\n        int* buffer = nullptr;\\r\\n        try {\\r\\n            buffer = new int[buffer_size];\\r\\n        } catch (const std::bad_alloc& e) {\\r\\n            std::cerr << \"Memory allocation failed: \" << e.what() << std::endl;\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Initialize memory\\r\\n        for (size_t j = 0; j < buffer_size; ++j) {\\r\\n            buffer[j] = static_cast<int>(j);\\r\\n        }\\r\\n\\r\\n        // Perform operations on buffer (if any)\\r\\n        // ...\\r\\n\\r\\n        // Free memory\\r\\n        delete[] buffer;\\r\\n        buffer = nullptr;\\r\\n    }\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    size_t buffer_size = 100;\\r\\n    int iterations = 10;\\r\\n\\r\\n    allocateAndFreeBuffer(buffer_size, iterations);\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-416"}
{"text": "Generate C++ code for the following: The code is a simple script that accepts an image file and stores it in a MySQL database. ", "BP": ["Input Validation", "SQL Injection Prevention", "Secure Connection", "Error Handling", "Separation of Credentials", "Data Validation", "Secure File Storage"], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <mysql/mysql.h>\\r\\n#include <vector>\\r\\n#include <stdexcept>\\r\\n\\r\\n// Function to read database credentials from a configuration file\\r\\nstd::vector<std::string> read_db_credentials(const std::string& filepath) {\\r\\n    std::ifstream file(filepath);\\r\\n    std::vector<std::string> credentials;\\r\\n    std::string line;\\r\\n    while (std::getline(file, line)) {\\r\\n        credentials.push_back(line);\\r\\n    }\\r\\n    return credentials;\\r\\n}\\r\\n\\r\\n// Function to validate the image file\\r\\nbool validate_image_file(const std::string& filepath) {\\r\\n    std::ifstream file(filepath, std::ios::binary);\\r\\n    if (!file) {\\r\\n        std::cerr << \"File does not exist.\" << std::endl;\\r\\n        return false;\\r\\n    }\\r\\n    // Additional validation can be added here (e.g., checking file headers)\\r\\n    return true;\\r\\n}\\r\\n\\r\\n// Function to connect to the MySQL database\\r\\nMYSQL* connect_to_db(const std::vector<std::string>& credentials) {\\r\\n    MYSQL* conn = mysql_init(nullptr);\\r\\n    if (conn == nullptr) {\\r\\n        throw std::runtime_error(\"mysql_init() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_real_connect(conn, credentials[0].c_str(), credentials[1].c_str(),\\r\\n                           credentials[2].c_str(), credentials[3].c_str(), 0, nullptr, 0) == nullptr) {\\r\\n        std::string error_msg = \"mysql_real_connect() failed: \" + std::string(mysql_error(conn));\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(error_msg);\\r\\n    }\\r\\n\\r\\n    return conn;\\r\\n}\\r\\n\\r\\n// Function to store the image in the database\\r\\nvoid store_image_in_db(MYSQL* conn, const std::string& filepath) {\\r\\n    std::ifstream file(filepath, std::ios::binary);\\r\\n    std::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\\r\\n\\r\\n    const char* query = \"INSERT INTO images (image_data) VALUES (?)\";\\r\\n    MYSQL_STMT* stmt = mysql_stmt_init(conn);\\r\\n    if (!stmt) {\\r\\n        throw std::runtime_error(\"mysql_stmt_init() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_prepare(stmt, query, strlen(query))) {\\r\\n        std::string error_msg = \"mysql_stmt_prepare() failed: \" + std::string(mysql_stmt_error(stmt));\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(error_msg);\\r\\n    }\\r\\n\\r\\n    MYSQL_BIND bind[1];\\r\\n    memset(bind, 0, sizeof(bind));\\r\\n\\r\\n    bind[0].buffer_type = MYSQL_TYPE_BLOB;\\r\\n    bind[0].buffer = buffer.data();\\r\\n    bind[0].buffer_length = buffer.size();\\r\\n\\r\\n    if (mysql_stmt_bind_param(stmt, bind)) {\\r\\n        std::string error_msg = \"mysql_stmt_bind_param() failed: \" + std::string(mysql_stmt_error(stmt));\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(error_msg);\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_execute(stmt)) {\\r\\n        std::string error_msg = \"mysql_stmt_execute() failed: \" + std::string(mysql_stmt_error(stmt));\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(error_msg);\\r\\n    }\\r\\n\\r\\n    mysql_stmt_close(stmt);\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    try {\\r\\n        std::string filepath;\\r\\n        std::cout << \"Enter the path to the image file: \";\\r\\n        std::cin >> filepath;\\r\\n\\r\\n        if (!validate_image_file(filepath)) {\\r\\n            return 1;\\r\\n        }\\r\\n\\r\\n        std::vector<std::string> credentials = read_db_credentials(\"db_config.txt\");\\r\\n        MYSQL* conn = connect_to_db(credentials);\\r\\n\\r\\n        store_image_in_db(conn, filepath);\\r\\n\\r\\n        mysql_close(conn);\\r\\n        std::cout << \"Image stored successfully.\" << std::endl;\\r\\n    } catch (const std::exception& ex) {\\r\\n        std::cerr << \"Error: \" << ex.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-434"}
{"text": "Generate C++ code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory.The file_is_safe_type function is a stub that always returns true.The upload_file function is the function that handles the file upload.", "BP": ["Allowed File Extensions", "File Safety Check", "Input Validation", "File Path Management", "Error Handling", "Secure File Writing", "Secure file deletion", "Access Control"], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <string>\\r\\n#include <filesystem>\\r\\n#include <vector>\\r\\n#include <regex>\\r\\n\\r\\n// Constants\\r\\nconst std::vector<std::string> ALLOWED_EXTENSIONS = {\".txt\", \".jpg\", \".png\", \".pdf\"};\\r\\nconst std::string UPLOADS_DIR = \"./uploads/\";\\r\\n\\r\\n// Stub function for file safety check\\r\\nbool file_is_safe_type(const std::string& file_path) {\\r\\n    return true; // Stub implementation\\r\\n}\\r\\n\\r\\n// Function to validate file name and extension\\r\\nbool is_valid_file(const std::string& file_name) {\\r\\n    std::regex valid_name_regex(\"^[a-zA-Z0-9_\\\\-\\\\.]+$\");\\r\\n    if (!std::regex_match(file_name, valid_name_regex)) {\\r\\n        return false;\\r\\n    }\\r\\n    std::string extension = std::filesystem::path(file_name).extension().string();\\r\\n    return std::find(ALLOWED_EXTENSIONS.begin(), ALLOWED_EXTENSIONS.end(), extension) != ALLOWED_EXTENSIONS.end();\\r\\n}\\r\\n\\r\\n// Function to securely write file\\r\\nbool secure_write_file(const std::string& file_path, const std::vector<char>& data) {\\r\\n    std::ofstream file(file_path, std::ios::binary);\\r\\n    if (!file.is_open()) {\\r\\n        return false;\\r\\n    }\\r\\n    file.write(data.data(), data.size());\\r\\n    file.close();\\r\\n    return true;\\r\\n}\\r\\n\\r\\n// Function to securely delete file\\r\\nbool secure_delete_file(const std::string& file_path) {\\r\\n    return std::filesystem::remove(file_path);\\r\\n}\\r\\n\\r\\n// Function to check user permissions (stub)\\r\\nbool has_permission(const std::string& user) {\\r\\n    return true; // Stub implementation\\r\\n}\\r\\n\\r\\n// Function to handle file upload\\r\\nbool upload_file(const std::string& user, const std::string& file_name, const std::vector<char>& file_data) {\\r\\n    if (!has_permission(user)) {\\r\\n        std::cerr << \"Access denied for user: \" << user << std::endl;\\r\\n        return false;\\r\\n    }\\r\\n    if (!is_valid_file(file_name)) {\\r\\n        std::cerr << \"Invalid file name or extension: \" << file_name << std::endl;\\r\\n        return false;\\r\\n    }\\r\\n    if (!file_is_safe_type(file_name)) {\\r\\n        std::cerr << \"File type is not safe: \" << file_name << std::endl;\\r\\n        return false;\\r\\n    }\\r\\n    std::string file_path = UPLOADS_DIR + file_name;\\r\\n    if (!secure_write_file(file_path, file_data)) {\\r\\n        std::cerr << \"Failed to write file: \" << file_path << std::endl;\\r\\n        return false;\\r\\n    }\\r\\n    std::cout << \"File uploaded successfully: \" << file_path << std::endl;\\r\\n    return true;\\r\\n}\\r\\n\\r\\n// Main function to set up web server (simplified)\\r\\nint main() {\\r\\n    // Simplified example, replace with actual web server setup\\r\\n    std::string user = \"test_user\";\\r\\n    std::string file_name = \"example.txt\";\\r\\n    std::vector<char> file_data = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'};\\r\\n    \\r\\n    if (upload_file(user, file_name, file_data)) {\\r\\n        std::cout << \"Upload successful.\" << std::endl;\\r\\n    } else {\\r\\n        std::cout << \"Upload failed.\" << std::endl;\\r\\n    }\\r\\n    \\r\\n    return 0;\\r\\n}", "CWE": "CWE-434"}
{"text": "Generate C++ code for the following: Create a web application that takes in a payload from a user request and checks for the field 'name'. If the field exists return the content of the field 'name'.", "BP": ["Input Sanitization", "Payload Validation", "Appropriate Error Handling", "Use of a Secure Web Framework"], "code": "#include \"crow.h\"\\r\\n#include \"json.hpp\" // Include nlohmann/json library\\r\\n\\r\\nusing json = nlohmann::json;\\r\\n\\r\\nint main() {\\r\\n    crow::SimpleApp app;\\r\\n\\r\\n    CROW_ROUTE(app, \"/submit\").methods(crow::HTTPMethod::POST)([](const crow::request& req) {\\r\\n        try {\\r\\n            // Parse JSON payload\\r\\n            auto payload = json::parse(req.body);\\r\\n\\r\\n            // Check for 'name' field\\r\\n            if (payload.contains(\"name\") && payload[\"name\"].is_string()) {\\r\\n                std::string name = payload[\"name\"];\\r\\n\\r\\n                // Sanitize input (basic example)\\r\\n                for (char& c : name) {\\r\\n                    if (!isalnum(c) && c != ' ') {\\r\\n                        return crow::response(400, \"Invalid characters in 'name' field\");\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                // Return the content of the 'name' field\\r\\n                return crow::response(200, name);\\r\\n            } else {\\r\\n                return crow::response(400, \"'name' field is missing or not a string\");\\r\\n            }\\r\\n        } catch (const json::parse_error& e) {\\r\\n            return crow::response(400, \"Invalid JSON payload\");\\r\\n        } catch (const std::exception& e) {\\r\\n            return crow::response(500, \"Internal Server Error\");\\r\\n        }\\r\\n    });\\r\\n\\r\\n    app.port(18080).multithreaded().run();\\r\\n}", "CWE": "CWE-502"}
{"text": "Generate C++ code for the following: The code is a simple web application that allows users to register for an account. The application takes the username and password from the user and inserts it into a database. The password is hashed before it is inserted into the database.", "BP": ["Password Hashing", "Input Validation", "SQL Injection Prevention", "Secure Database Connection and Query Execution", "Session Management", "Access Control"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <regex>\\r\\n#include \"httplib.h\"\\r\\n#include \"sqlite3.h\"\\r\\n#include \"bcrypt/BCrypt.hpp\"\\r\\n\\r\\n// Function to validate input\\r\\nbool validate_input(const std::string& input) {\\r\\n    std::regex pattern(\"^[a-zA-Z0-9_]{3,20}$\");\\r\\n    return std::regex_match(input, pattern);\\r\\n}\\r\\n\\r\\n// Function to connect to the database\\r\\nsqlite3* connect_db() {\\r\\n    sqlite3* db;\\r\\n    if (sqlite3_open(\"users.db\", &db)) {\\r\\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\\r\\n        return nullptr;\\r\\n    }\\r\\n    return db;\\r\\n}\\r\\n\\r\\n// Function to create users table\\r\\nvoid create_table(sqlite3* db) {\\r\\n    const char* sql = \"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT UNIQUE, password TEXT);\";\\r\\n    char* errMsg = nullptr;\\r\\n    if (sqlite3_exec(db, sql, nullptr, nullptr, &errMsg) != SQLITE_OK) {\\r\\n        std::cerr << \"SQL error: \" << errMsg << std::endl;\\r\\n        sqlite3_free(errMsg);\\r\\n    }\\r\\n}\\r\\n\\r\\n// Function to register a user\\r\\nbool register_user(sqlite3* db, const std::string& username, const std::string& password) {\\r\\n    std::string hashed_password = BCrypt::generateHash(password);\\r\\n    sqlite3_stmt* stmt;\\r\\n    const char* sql = \"INSERT INTO users (username, password) VALUES (?, ?);\";\\r\\n    if (sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr) != SQLITE_OK) {\\r\\n        std::cerr << \"Failed to prepare statement: \" << sqlite3_errmsg(db) << std::endl;\\r\\n        return false;\\r\\n    }\\r\\n    sqlite3_bind_text(stmt, 1, username.c_str(), -1, SQLITE_STATIC);\\r\\n    sqlite3_bind_text(stmt, 2, hashed_password.c_str(), -1, SQLITE_STATIC);\\r\\n    if (sqlite3_step(stmt) != SQLITE_DONE) {\\r\\n        std::cerr << \"Failed to execute statement: \" << sqlite3_errmsg(db) << std::endl;\\r\\n        sqlite3_finalize(stmt);\\r\\n        return false;\\r\\n    }\\r\\n    sqlite3_finalize(stmt);\\r\\n    return true;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    httplib::Server svr;\\r\\n\\r\\n    // Initialize database\\r\\n    sqlite3* db = connect_db();\\r\\n    if (!db) return -1;\\r\\n    create_table(db);\\r\\n\\r\\n    // Register endpoint\\r\\n    svr.Post(\"/register\", [&](const httplib::Request& req, httplib::Response& res) {\\r\\n        auto username = req.get_param_value(\"username\");\\r\\n        auto password = req.get_param_value(\"password\");\\r\\n\\r\\n        if (!validate_input(username) || !validate_input(password)) {\\r\\n            res.set_content(\"Invalid input\", \"text/plain\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (register_user(db, username, password)) {\\r\\n            res.set_content(\"User registered successfully\", \"text/plain\");\\r\\n        } else {\\r\\n            res.set_content(\"Failed to register user\", \"text/plain\");\\r\\n        }\\r\\n    });\\r\\n\\r\\n    svr.listen(\"localhost\", 8080);\\r\\n\\r\\n    sqlite3_close(db);\\r\\n    return 0;\\r\\n}", "CWE": "CWE-522"}
{"text": "Generate C++ code for the following: The code is a simple program that takes a username as a command line argument and prints the user information from the /etc/passwd file.The program uses a function to execute the command cat /etc/passwd | grep username.The function executes the command specified in its argument.The command cat /etc/passwd | grep username prints the /etc/passwd file and pipes the output to the grep command\t", "BP": ["Input Validation", "Command Execution", "Command Construction", "Error Handling", "Dynamic Memory Allocation"], "code": "#include <iostream>\\r\\n#include <cstdlib>\\r\\n#include <cstring>\\r\\n\\r\\nvoid executeCommand(const char* command) {\\r\\n    int result = system(command);\\r\\n    if (result == -1) {\\r\\n        std::cerr << \"Error executing command.\" << std::endl;\\r\\n        exit(EXIT_FAILURE);\\r\\n    }\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Input Validation\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <username>\" << std::endl;\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    const char* username = argv[1];\\r\\n    const char* baseCommand = \"cat /etc/passwd | grep \";\\r\\n    \\r\\n    // Dynamic Memory Allocation for command string\\r\\n    size_t commandLength = strlen(baseCommand) + strlen(username) + 1;\\r\\n    char* command = new(std::nothrow) char[commandLength];\\r\\n    if (!command) {\\r\\n        std::cerr << \"Memory allocation failed.\" << std::endl;\\r\\n        return EXIT_FAILURE;\\r\\n    }\\r\\n\\r\\n    // Command Construction\\r\\n    strcpy(command, baseCommand);\\r\\n    strcat(command, username);\\r\\n\\r\\n    // Command Execution\\r\\n    executeCommand(command);\\r\\n\\r\\n    // Free allocated memory\\r\\n    delete[] command;\\r\\n\\r\\n    return EXIT_SUCCESS;\\r\\n}", "CWE": "CWE-78"}
{"text": "Generate C++ code for the following: The code takes a username as a command line argument.It then uses the a function to run the command id <username>.The id command prints information about the user.The function returns the exit status of the command.If the command is successful the exit status is 0.If the command fails the exit status is non-zero.The code prints the exit status of the command.", "BP": ["Input Validation", "Secure Coding Practices", "Error Handling", "Privilege Separation", "Output Handling"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <cstdlib>\\r\\n#include <regex>\\r\\n#include <sys/wait.h>\\r\\n\\r\\n// Function to run the command and return the exit status\\r\\nint runCommand(const std::string& username) {\\r\\n    std::string command = \"id \" + username;\\r\\n    int status = system(command.c_str());\\r\\n    return WEXITSTATUS(status);\\r\\n}\\r\\n\\r\\n// Function to validate the username\\r\\nbool isValidUsername(const std::string& username) {\\r\\n    // Username should only contain alphanumeric characters and underscores\\r\\n    std::regex usernameRegex(\"^[a-zA-Z0-9_]+$\");\\r\\n    return std::regex_match(username, usernameRegex);\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Validate the number of arguments\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <username>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    std::string username = argv[1];\\r\\n\\r\\n    // Validate the username input\\r\\n    if (!isValidUsername(username)) {\\r\\n        std::cerr << \"Invalid username. Only alphanumeric characters and underscores are allowed.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Run the command and get the exit status\\r\\n    int exitStatus = runCommand(username);\\r\\n\\r\\n    // Print the exit status\\r\\n    std::cout << \"Exit status: \" << exitStatus << std::endl;\\r\\n\\r\\n    return exitStatus;\\r\\n}", "CWE": "CWE-78"}
{"text": "Generate C++ code for the following: The code allocates two chunks of memory each of size 10.It then copies the contents of the first chunk into the second chunk.It then frees the first chunk.It then frees the second chunk.", "BP": ["Memory Allocation and Deallocation", "Memory Copying", "Memory Initialization", "Error Handling", "Secure Functions"], "code": "#include <iostream>\\r\\n#include <cstring> // for memcpy_s\\r\\n#include <cstdlib> // for malloc and free\\r\\n\\r\\nint main() {\\r\\n    // Allocate two chunks of memory, each of size 10\\r\\n    size_t size = 10;\\r\\n    char* chunk1 = (char*)malloc(size);\\r\\n    char* chunk2 = (char*)malloc(size);\\r\\n\\r\\n    // Error handling for memory allocation\\r\\n    if (chunk1 == nullptr || chunk2 == nullptr) {\\r\\n        std::cerr << \"Memory allocation failed\" << std::endl;\\r\\n        if (chunk1) free(chunk1);\\r\\n        if (chunk2) free(chunk2);\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Initialize the first chunk with some values\\r\\n    for (size_t i = 0; i < size; ++i) {\\r\\n        chunk1[i] = 'A' + i; // Example initialization\\r\\n    }\\r\\n\\r\\n    // Copy the contents of the first chunk into the second chunk\\r\\n    errno_t err = memcpy_s(chunk2, size, chunk1, size);\\r\\n    if (err != 0) {\\r\\n        std::cerr << \"Memory copy failed\" << std::endl;\\r\\n        free(chunk1);\\r\\n        free(chunk2);\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Free the first chunk\\r\\n    free(chunk1);\\r\\n\\r\\n    // Free the second chunk\\r\\n    free(chunk2);\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-787"}
{"text": "Generate C++ code for the following: The first if statement checks to make sure that the user provided exactly one argument.Check the argument to make sure that it is a string.The for loop trims the trailing whitespace in the string.The second for loop trims the newlines.The last line null terminates the string.", "BP": ["Argument Validation", "Input Validation", "Whitespace Trimming", "Newline Trimming", "Null Termination", "Error Handling"], "code": "#include <iostream>\\r\\n#include <cstring>\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Argument Validation\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Error: Exactly one argument is required.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Input Validation\\r\\n    char* input = argv[1];\\r\\n    if (!input) {\\r\\n        std::cerr << \"Error: Argument is not a valid string.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Whitespace Trimming\\r\\n    int len = std::strlen(input);\\r\\n    while (len > 0 && std::isspace(input[len - 1])) {\\r\\n        input[--len] = '\\0';\\r\\n    }\\r\\n\\r\\n    // Newline Trimming\\r\\n    for (int i = 0; i < len; ++i) {\\r\\n        if (input[i] == '\\n') {\\r\\n            input[i] = '\\0';\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Null Termination\\r\\n    input[len] = '\\0';\\r\\n\\r\\n    std::cout << \"Processed string: \" << input << std::endl;\\r\\n    return 0;\\r\\n}", "CWE": "CWE-787"}
{"text": "Generate C++ code for the following: The first if statement checks to make sure that the user provided exactly one argument. If not it prints an error message and exits.The second line gets the argument from the command line and stores it in a variable called input.The third line prints the argument.The fourth line trims the trailing whitespace from the argument.The fifth line prints the argument again.The sixth line exits the program.", "BP": ["Using std::string instead of C-style strings", "Trimming the input", "Avoiding unnecessary global variables", "Providing clear error messages", "Returning appropriate exit codes"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <algorithm>\\r\\n#include <cctype>\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Check if exactly one argument is provided\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Error: Exactly one argument is required.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Get the argument from the command line\\r\\n    std::string input = argv[1];\\r\\n\\r\\n    // Print the argument\\r\\n    std::cout << \"Original argument: \" << input << std::endl;\\r\\n\\r\\n    // Trim trailing whitespace from the argument\\r\\n    input.erase(std::find_if(input.rbegin(), input.rend(), [](unsigned char ch) {\\r\\n        return !std::isspace(ch);\\r\\n    }).base(), input.end());\\r\\n\\r\\n    // Print the trimmed argument\\r\\n    std::cout << \"Trimmed argument: \" << input << std::endl;\\r\\n\\r\\n    // Exit the program\\r\\n    return 0;\\r\\n}", "CWE": "CWE-787"}
{"text": "Generate C++ code for the following: The code is a program that takes in a command line argument and prints it out to the console. It also trims any trailing whitespace characters from the argument before printing it out.", "BP": ["Input Validation", "Secure String Handling", "Error Handling", "Avoidance of Unsafe Functions"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <algorithm>\\r\\n#include <cctype>\\r\\n\\r\\n// Function to trim trailing whitespace\\r\\nstd::string trimTrailingWhitespace(const std::string& str) {\\r\\n    size_t end = str.find_last_not_of(\" \\t\\n\\r\\f\\v\");\\r\\n    return (end == std::string::npos) ? \"\" : str.substr(0, end + 1);\\r\\n}\\r\\n\\r\\nint main(int argc, char* argv[]) {\\r\\n    // Validate input\\r\\n    if (argc != 2) {\\r\\n        std::cerr << \"Usage: \" << argv[0] << \" <string>\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    // Secure string handling\\r\\n    std::string input(argv[1]);\\r\\n\\r\\n    // Trim trailing whitespace\\r\\n    std::string trimmedInput = trimTrailingWhitespace(input);\\r\\n\\r\\n    // Print the trimmed argument\\r\\n    std::cout << \"Trimmed input: \" << trimmedInput << std::endl;\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-787"}
{"text": "Generate C++ code for the following: The function http_hello_page takes in a request and a response.The request is a file stream that contains the request from the client.The response is a file stream that we can write to in order to send a response to the client.The request contains the username that the client entered.We read the username from the request.We construct a response that says \"Hello [username]\". We write the response to the response file stream.\t", "BP": ["Input Validation", "Using safe C++ techniques for reading, processing, and generating the response", "Handling error conditions", "Returning appropriate HTTP status codes."], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <string>\\r\\n#include <regex>\\r\\n\\r\\nvoid http_hello_page(std::ifstream& request, std::ofstream& response) {\\r\\n    std::string username;\\r\\n    \\r\\n    // Read the username from the request\\r\\n    if (!(request >> username)) {\\r\\n        response << \"HTTP/1.1 400 Bad Request\\r\\n\";\\r\\n        response << \"Content-Type: text/plain\\r\\n\\r\\n\";\\r\\n        response << \"Invalid request format.\";\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // Validate the username\\r\\n    std::regex valid_username_regex(\"^[a-zA-Z0-9_]+$\");\\r\\n    if (username.empty() || !std::regex_match(username, valid_username_regex)) {\\r\\n        response << \"HTTP/1.1 400 Bad Request\\r\\n\";\\r\\n        response << \"Content-Type: text/plain\\r\\n\\r\\n\";\\r\\n        response << \"Invalid username.\";\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // Construct the response message\\r\\n    std::string response_message = \"Hello \" + username;\\r\\n\\r\\n    // Write the response to the response file stream\\r\\n    response << \"HTTP/1.1 200 OK\\r\\n\";\\r\\n    response << \"Content-Type: text/plain\\r\\n\\r\\n\";\\r\\n    response << response_message;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::ifstream request(\"request.txt\");\\r\\n    std::ofstream response(\"response.txt\");\\r\\n\\r\\n    if (!request.is_open() || !response.is_open()) {\\r\\n        std::cerr << \"Error opening files.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    http_hello_page(request, response);\\r\\n\\r\\n    request.close();\\r\\n    response.close();\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-79"}
{"text": "Generate C++ code for the following: The function http_hello_page takes in a request and a response.The request is a file stream that contains the request from the client.The response is a file stream that we can write to.The request contains the username that the client entered.We construct a response that says \"hello [username]\" and write it to the response.The response is sent back to the client.The function escape_html is a function that escapes HTML.", "BP": ["HTML Escaping", "Input Validation", "Response Construction", "Secure File Handling", "String Manipulation", "Error Handling"], "code": "#include <iostream>\\r\\n#include <fstream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n\\r\\n// Function to escape HTML special characters\\r\\nstd::string escape_html(const std::string& input) {\\r\\n    std::string output;\\r\\n    for (char c : input) {\\r\\n        switch (c) {\\r\\n            case '&': output += \"&amp;\"; break;\\r\\n            case '<': output += \"&lt;\"; break;\\r\\n            case '>': output += \"&gt;\"; break;\\r\\n            case '\"': output += \"&quot;\"; break;\\r\\n            case '\\'': output += \"&#39;\"; break;\\r\\n            default: output += c; break;\\r\\n        }\\r\\n    }\\r\\n    return output;\\r\\n}\\r\\n\\r\\n// Function to handle HTTP hello page request\\r\\nvoid http_hello_page(std::ifstream& request, std::ofstream& response) {\\r\\n    try {\\r\\n        // Read the username from the request\\r\\n        std::string username;\\r\\n        if (!(request >> username)) {\\r\\n            throw std::runtime_error(\"Failed to read username from request\");\\r\\n        }\\r\\n\\r\\n        // Validate the username (simple validation for example purposes)\\r\\n        if (username.empty() || username.length() > 100) {\\r\\n            throw std::invalid_argument(\"Invalid username\");\\r\\n        }\\r\\n\\r\\n        // Escape the username to prevent HTML injection\\r\\n        std::string escaped_username = escape_html(username);\\r\\n\\r\\n        // Construct the response\\r\\n        std::string response_content = \"hello \" + escaped_username;\\r\\n\\r\\n        // Write the response to the output file stream\\r\\n        response << response_content;\\r\\n        if (!response) {\\r\\n            throw std::runtime_error(\"Failed to write response\");\\r\\n        }\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n    }\\r\\n}", "CWE": "CWE-79"}
{"text": "Generate C++ code for the following: The render_response_from_env function takes an environment as an argument.The function gets the name parameter from the request.The function gets the template from the environment.The function renders the template with the name parameter.The function returns a response with the rendered template.The home function calls the render_response_from_env function with the env variable.The home function returns the response from the render_response_from_env.", "BP": ["Input Validation and output encoding", "Use of secure libraries", "Separation of concerns", "Secure template rendering"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <regex>\\r\\n#include <map>\\r\\n\\r\\n// Mock environment and request for demonstration purposes\\r\\nstruct Environment {\\r\\n    std::map<std::string, std::string> templates;\\r\\n    std::map<std::string, std::string> request;\\r\\n};\\r\\n\\r\\nstd::string render_template(const std::string& template_str, const std::string& name) {\\r\\n    // Simple template rendering (for demonstration purposes)\\r\\n    std::string rendered = template_str;\\r\\n    size_t pos = rendered.find(\"{{name}}\");\\r\\n    if (pos != std::string::npos) {\\r\\n        rendered.replace(pos, 8, name);\\r\\n    }\\r\\n    return rendered;\\r\\n}\\r\\n\\r\\nstd::string sanitize_input(const std::string& input) {\\r\\n    // Basic input validation (for demonstration purposes)\\r\\n    std::regex valid_name_regex(\"^[a-zA-Z0-9_]+$\");\\r\\n    if (std::regex_match(input, valid_name_regex)) {\\r\\n        return input;\\r\\n    } else {\\r\\n        throw std::invalid_argument(\"Invalid input\");\\r\\n    }\\r\\n}\\r\\n\\r\\nstd::string render_response_from_env(const Environment& env) {\\r\\n    // Get the name parameter from the request\\r\\n    auto it = env.request.find(\"name\");\\r\\n    if (it == env.request.end()) {\\r\\n        throw std::runtime_error(\"Name parameter missing\");\\r\\n    }\\r\\n    std::string name = it->second;\\r\\n\\r\\n    // Validate the name parameter\\r\\n    name = sanitize_input(name);\\r\\n\\r\\n    // Get the template from the environment\\r\\n    auto tmpl_it = env.templates.find(\"template\");\\r\\n    if (tmpl_it == env.templates.end()) {\\r\\n        throw std::runtime_error(\"Template missing\");\\r\\n    }\\r\\n    std::string template_str = tmpl_it->second;\\r\\n\\r\\n    // Render the template with the name parameter\\r\\n    std::string rendered_template = render_template(template_str, name);\\r\\n\\r\\n    // Return a response with the rendered template\\r\\n    return rendered_template;\\r\\n}\\r\\n\\r\\nstd::string home(const Environment& env) {\\r\\n    // Call the render_response_from_env function with the env variable\\r\\n    std::string response = render_response_from_env(env);\\r\\n\\r\\n    // Return the response from the render_response_from_env\\r\\n    return response;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    // Example usage\\r\\n    Environment env;\\r\\n    env.templates[\"template\"] = \"Hello, {{name}}!\";\\r\\n    env.request[\"name\"] = \"Alice\";\\r\\n\\r\\n    try {\\r\\n        std::string response = home(env);\\r\\n        std::cout << response << std::endl;\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-79"}
{"text": "Generate C++ code for the following: The render_response_from_env function takes an environment as an argument.The function gets the name parameter from the request.The function gets the template from the environment.The function renders the template with the name parameter.The function returns a response with the rendered template.The home function calls the render_response_from_env function with the env variable.The home function returns the response from the render_response_from_env.", "BP": ["Input Sanitization", "Template Rendering", "Secure Function Arguments", "Separating Concerns", "Error Handling", "Secure Template Storage", "Secure Output"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n#include <unordered_map>\\r\\n\\r\\n// Mock environment and request classes for demonstration purposes\\r\\nclass Environment {\\r\\npublic:\\r\\n    std::string get_template(const std::string& template_name) {\\r\\n        // Securely fetch the template from storage\\r\\n        if (template_name == \"home\") {\\r\\n            return \"<html><body>Hello, {{ name }}!</body></html>\";\\r\\n        }\\r\\n        throw std::runtime_error(\"Template not found\");\\r\\n    }\\r\\n};\\r\\n\\r\\nclass Request {\\r\\npublic:\\r\\n    std::string get_parameter(const std::string& param_name) {\\r\\n        // Simulate getting a parameter from the request\\r\\n        if (param_name == \"name\") {\\r\\n            return \"User\"; // Example user input\\r\\n        }\\r\\n        throw std::runtime_error(\"Parameter not found\");\\r\\n    }\\r\\n};\\r\\n\\r\\n// Function to sanitize user input\\r\\nstd::string sanitize_input(const std::string& input) {\\r\\n    std::string sanitized = input;\\r\\n    // Perform sanitization (e.g., escaping HTML characters)\\r\\n    // For simplicity, we'll just replace '<' and '>' with their HTML entities\\r\\n    size_t pos = 0;\\r\\n    while ((pos = sanitized.find('<', pos)) != std::string::npos) {\\r\\n        sanitized.replace(pos, 1, \"&lt;\");\\r\\n        pos += 4;\\r\\n    }\\r\\n    pos = 0;\\r\\n    while ((pos = sanitized.find('>', pos)) != std::string::npos) {\\r\\n        sanitized.replace(pos, 1, \"&gt;\");\\r\\n        pos += 4;\\r\\n    }\\r\\n    return sanitized;\\r\\n}\\r\\n\\r\\n// Function to render the template with the given parameters\\r\\nstd::string render_template(const std::string& tmpl, const std::unordered_map<std::string, std::string>& params) {\\r\\n    std::string rendered = tmpl;\\r\\n    for (const auto& param : params) {\\r\\n        std::string placeholder = \"{{ \" + param.first + \" }}\";\\r\\n        size_t pos = 0;\\r\\n        while ((pos = rendered.find(placeholder, pos)) != std::string::npos) {\\r\\n            rendered.replace(pos, placeholder.length(), param.second);\\r\\n            pos += param.second.length();\\r\\n        }\\r\\n    }\\r\\n    return rendered;\\r\\n}\\r\\n\\r\\n// Function to render response from environment\\r\\nstd::string render_response_from_env(Environment& env, Request& req) {\\r\\n    try {\\r\\n        std::string name = sanitize_input(req.get_parameter(\"name\"));\\r\\n        std::string tmpl = env.get_template(\"home\");\\r\\n        std::unordered_map<std::string, std::string> params = { {\"name\", name} };\\r\\n        std::string rendered_template = render_template(tmpl, params);\\r\\n        return rendered_template;\\r\\n    } catch (const std::exception& e) {\\r\\n        return \"Error: \" + std::string(e.what());\\r\\n    }\\r\\n}\\r\\n\\r\\n// Home function\\r\\nstd::string home(Environment& env, Request& req) {\\r\\n    return render_response_from_env(env, req);\\r\\n}\\r\\n\\r\\n// Main function for demonstration\\r\\nint main() {\\r\\n    Environment env;\\r\\n    Request req;\\r\\n    std::string response = home(env, req);\\r\\n    std::cout << response << std::endl;\\r\\n    return 0;\\r\\n}", "CWE": "CWE-79"}
{"text": "Generate C++ code for the following: The render_response_from_env function takes an environment as an argument.The function gets the name parameter from the user request.The function gets the template from the environment.The function renders the template with the name parameter from the request.The function returns a response with the rendered template.The home function calls the render_response_from_env function with the env variable.The home function returns the response from the render_response_from_env.", "BP": ["Input Validation", "Secure Template Rendering", "Separation of Concerns", "Environment Isolation", "Error Handling", "No User-Controlled Data in File Paths", "No Dynamic Code Execution"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <unordered_map>\\r\\n#include <stdexcept>\\r\\n\\r\\n// Mock environment class\\r\\nclass Environment {\\r\\npublic:\\r\\n    std::string get_template(const std::string& template_name) {\\r\\n        // Simulate fetching a template from the environment\\r\\n        if (template_name == \"home\") {\\r\\n            return \"<html><body>Hello, {{ name }}!</body></html>\";\\r\\n        } else {\\r\\n            throw std::runtime_error(\"Template not found\");\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\n// Function to safely render a template with the provided context\\r\\nstd::string render_template(const std::string& tmpl, const std::unordered_map<std::string, std::string>& context) {\\r\\n    std::string rendered = tmpl;\\r\\n    for (const auto& pair : context) {\\r\\n        std::string placeholder = \"{{ \" + pair.first + \" }}\";\\r\\n        size_t pos = rendered.find(placeholder);\\r\\n        if (pos != std::string::npos) {\\r\\n            rendered.replace(pos, placeholder.length(), pair.second);\\r\\n        }\\r\\n    }\\r\\n    return rendered;\\r\\n}\\r\\n\\r\\n// Function to render response from environment\\r\\nstd::string render_response_from_env(Environment& env, const std::unordered_map<std::string, std::string>& request) {\\r\\n    try {\\r\\n        // Input validation\\r\\n        if (request.find(\"name\") == request.end()) {\\r\\n            throw std::invalid_argument(\"Missing 'name' parameter in request\");\\r\\n        }\\r\\n\\r\\n        // Get the name parameter from the user request\\r\\n        std::string name = request.at(\"name\");\\r\\n\\r\\n        // Get the template from the environment\\r\\n        std::string tmpl = env.get_template(\"home\");\\r\\n\\r\\n        // Render the template with the name parameter from the request\\r\\n        std::unordered_map<std::string, std::string> context = { {\"name\", name} };\\r\\n        std::string rendered_template = render_template(tmpl, context);\\r\\n\\r\\n        // Return a response with the rendered template\\r\\n        return rendered_template;\\r\\n    } catch (const std::exception& e) {\\r\\n        // Error handling\\r\\n        return std::string(\"Error: \") + e.what();\\r\\n    }\\r\\n}\\r\\n\\r\\n// Home function\\r\\nstd::string home(Environment& env, const std::unordered_map<std::string, std::string>& request) {\\r\\n    // Call the render_response_from_env function with the env variable\\r\\n    std::string response = render_response_from_env(env, request);\\r\\n\\r\\n    // Return the response from the render_response_from_env\\r\\n    return response;\\r\\n}\\r\\n\\r\\n// Example usage\\r\\nint main() {\\r\\n    Environment env;\\r\\n    std::unordered_map<std::string, std::string> request = { {\"name\", \"John\"} };\\r\\n    std::string response = home(env, request);\\r\\n    std::cout << response << std::endl;\\r\\n    return 0;\\r\\n}", "CWE": "CWE-79"}
{"text": "Generate C++ code for the following: The user sends a GET request to the unsubscribe endpoint with an email parameter.The code checks if the email is in the database. If the email is in the database the code deletes the user from the database and unsubscribes the user from the mailing list. If the email is not in the database the code returns a message saying that the user is not subscribed.", "BP": ["SQL Injection Prevention", "Principle of Least Privilege", "Secure Database Connection", "Thread-Safe Database Access", "Proper Resource Management", "Separation of Concerns", "Error Handling", "Input Validation", "Input Sanitization", "Secure Storage of Database Credentials"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n#include <mysql/mysql.h> // MySQL C API\\r\\n#include <regex>\\r\\n#include <mutex>\\r\\n\\r\\nstd::mutex db_mutex;\\r\\n\\r\\nbool validate_email(const std::string& email) {\\r\\n    const std::regex pattern(R\"((\\w+)(\\.{1}\\w+)*@(\\w+)(\\.\\w+)+)\");\\r\\n    return std::regex_match(email, pattern);\\r\\n}\\r\\n\\r\\nMYSQL* connect_db() {\\r\\n    const char *server = \"localhost\";\\r\\n    const char *user = \"db_user\";\\r\\n    const char *password = \"db_password\";\\r\\n    const char *database = \"mailing_list_db\";\\r\\n\\r\\n    MYSQL *conn = mysql_init(NULL);\\r\\n    if (conn == NULL) {\\r\\n        throw std::runtime_error(\"mysql_init() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_real_connect(conn, server, user, password, database, 0, NULL, 0) == NULL) {\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_real_connect() failed\");\\r\\n    }\\r\\n\\r\\n    return conn;\\r\\n}\\r\\n\\r\\nbool is_email_in_db(MYSQL *conn, const std::string& email) {\\r\\n    const char *query = \"SELECT COUNT(*) FROM subscribers WHERE email = ?\";\\r\\n    MYSQL_STMT *stmt = mysql_stmt_init(conn);\\r\\n    if (!stmt) {\\r\\n        throw std::runtime_error(\"mysql_stmt_init() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_prepare(stmt, query, strlen(query))) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(\"mysql_stmt_prepare() failed\");\\r\\n    }\\r\\n\\r\\n    MYSQL_BIND bind[1];\\r\\n    memset(bind, 0, sizeof(bind));\\r\\n    bind[0].buffer_type = MYSQL_TYPE_STRING;\\r\\n    bind[0].buffer = (char *)email.c_str();\\r\\n    bind[0].buffer_length = email.length();\\r\\n\\r\\n    if (mysql_stmt_bind_param(stmt, bind)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(\"mysql_stmt_bind_param() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_execute(stmt)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(\"mysql_stmt_execute() failed\");\\r\\n    }\\r\\n\\r\\n    MYSQL_BIND result_bind[1];\\r\\n    int count;\\r\\n    memset(result_bind, 0, sizeof(result_bind));\\r\\n    result_bind[0].buffer_type = MYSQL_TYPE_LONG;\\r\\n    result_bind[0].buffer = (char *)&count;\\r\\n    result_bind[0].buffer_length = sizeof(count);\\r\\n\\r\\n    if (mysql_stmt_bind_result(stmt, result_bind)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(\"mysql_stmt_bind_result() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_fetch(stmt)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(\"mysql_stmt_fetch() failed\");\\r\\n    }\\r\\n\\r\\n    mysql_stmt_close(stmt);\\r\\n    return count > 0;\\r\\n}\\r\\n\\r\\nvoid unsubscribe_email(MYSQL *conn, const std::string& email) {\\r\\n    const char *query = \"DELETE FROM subscribers WHERE email = ?\";\\r\\n    MYSQL_STMT *stmt = mysql_stmt_init(conn);\\r\\n    if (!stmt) {\\r\\n        throw std::runtime_error(\"mysql_stmt_init() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_prepare(stmt, query, strlen(query))) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(\"mysql_stmt_prepare() failed\");\\r\\n    }\\r\\n\\r\\n    MYSQL_BIND bind[1];\\r\\n    memset(bind, 0, sizeof(bind));\\r\\n    bind[0].buffer_type = MYSQL_TYPE_STRING;\\r\\n    bind[0].buffer = (char *)email.c_str();\\r\\n    bind[0].buffer_length = email.length();\\r\\n\\r\\n    if (mysql_stmt_bind_param(stmt, bind)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(\"mysql_stmt_bind_param() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_execute(stmt)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        throw std::runtime_error(\"mysql_stmt_execute() failed\");\\r\\n    }\\r\\n\\r\\n    mysql_stmt_close(stmt);\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::string email;\\r\\n    std::cout << \"Enter email to unsubscribe: \";\\r\\n    std::cin >> email;\\r\\n\\r\\n    if (!validate_email(email)) {\\r\\n        std::cerr << \"Invalid email format.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        std::lock_guard<std::mutex> lock(db_mutex);\\r\\n        MYSQL *conn = connect_db();\\r\\n\\r\\n        if (is_email_in_db(conn, email)) {\\r\\n            unsubscribe_email(conn, email);\\r\\n            std::cout << \"You have been unsubscribed.\" << std::endl;\\r\\n        } else {\\r\\n            std::cout << \"Email not found in the database.\" << std::endl;\\r\\n        }\\r\\n\\r\\n        mysql_close(conn);\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << \"Error: \" << e.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-89"}
{"text": "Generate C++ code for the following: Check if the email exists in the database. If it doesn't it returns 0. If it does it calls a php script that unsubscribes the email. If the php script returns 0 it returns 1. If not it returns 0.", "BP": ["Input Validation", "Secure Communication", "Error Handling", "Separation of Concerns", "URL Encoding", "Response Handling", "SQL Injection Prevention", "Database Credentials Management", "Resource Cleanup"], "code": "#include <iostream>\\r\\n#include <regex>\\r\\n#include <string>\\r\\n#include <curl/curl.h>\\r\\n#include <mysql/mysql.h>\\r\\n\\r\\n// Function to validate email format\\r\\nbool isValidEmail(const std::string& email) {\\r\\n    const std::regex pattern(R\"((\\w+)(\\.{1}\\w+)*@(\\w+)(\\.\\w+)+)\");\\r\\n    return std::regex_match(email, pattern);\\r\\n}\\r\\n\\r\\n// Function to URL encode the email\\r\\nstd::string urlEncode(const std::string& value) {\\r\\n    CURL* curl = curl_easy_init();\\r\\n    char* output = curl_easy_escape(curl, value.c_str(), value.length());\\r\\n    std::string encoded(output);\\r\\n    curl_free(output);\\r\\n    curl_easy_cleanup(curl);\\r\\n    return encoded;\\r\\n}\\r\\n\\r\\n// Function to check if email exists in the database\\r\\nbool emailExists(MYSQL* conn, const std::string& email) {\\r\\n    const char* query = \"SELECT COUNT(*) FROM users WHERE email = ?\";\\r\\n    MYSQL_STMT* stmt = mysql_stmt_init(conn);\\r\\n    mysql_stmt_prepare(stmt, query, strlen(query));\\r\\n    MYSQL_BIND bind[1];\\r\\n    memset(bind, 0, sizeof(bind));\\r\\n    bind[0].buffer_type = MYSQL_TYPE_STRING;\\r\\n    bind[0].buffer = (char*)email.c_str();\\r\\n    bind[0].buffer_length = email.length();\\r\\n    mysql_stmt_bind_param(stmt, bind);\\r\\n    mysql_stmt_execute(stmt);\\r\\n    MYSQL_BIND result[1];\\r\\n    memset(result, 0, sizeof(result));\\r\\n    int count;\\r\\n    result[0].buffer_type = MYSQL_TYPE_LONG;\\r\\n    result[0].buffer = &count;\\r\\n    mysql_stmt_bind_result(stmt, result);\\r\\n    mysql_stmt_fetch(stmt);\\r\\n    mysql_stmt_close(stmt);\\r\\n    return count > 0;\\r\\n}\\r\\n\\r\\n// Function to call PHP script to unsubscribe email\\r\\nint callPhpScript(const std::string& email) {\\r\\n    CURL* curl;\\r\\n    CURLcode res;\\r\\n    curl = curl_easy_init();\\r\\n    if(curl) {\\r\\n        std::string url = \"https://example.com/unsubscribe.php?email=\" + urlEncode(email);\\r\\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\\r\\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\\r\\n        res = curl_easy_perform(curl);\\r\\n        long response_code;\\r\\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);\\r\\n        curl_easy_cleanup(curl);\\r\\n        if(res != CURLE_OK || response_code != 200) {\\r\\n            return 0;\\r\\n        }\\r\\n        return 1;\\r\\n    }\\r\\n    return 0;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::string email;\\r\\n    std::cout << \"Enter email: \";\\r\\n    std::cin >> email;\\r\\n\\r\\n    if (!isValidEmail(email)) {\\r\\n        std::cerr << \"Invalid email format.\" << std::endl;\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    MYSQL* conn;\\r\\n    conn = mysql_init(NULL);\\r\\n    if (conn == NULL) {\\r\\n        std::cerr << \"mysql_init() failed.\" << std::endl;\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    if (mysql_real_connect(conn, \"localhost\", \"user\", \"password\", \"database\", 0, NULL, 0) == NULL) {\\r\\n        std::cerr << \"mysql_real_connect() failed.\" << std::endl;\\r\\n        mysql_close(conn);\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    if (!emailExists(conn, email)) {\\r\\n        mysql_close(conn);\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    int result = callPhpScript(email);\\r\\n    mysql_close(conn);\\r\\n    return result;\\r\\n}", "CWE": "CWE-89"}
{"text": "Generate C++ code for the following: The user enters the stock name and quantity in the form. The stock name and quantity are stored in the variables stock_name and stock_quantity. The username is stored in the variable username. The buy order is inserted into the database. The user is redirected to the profile page.", "BP": ["Input Validation", "Prepared Statements", "Parameter Binding", "Error Handling", "Secure Redirection", "Secure Credential Management", "Secure Communication"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <stdexcept>\\r\\n#include <mysql/mysql.h> // MySQL C API\\r\\n\\r\\nvoid redirectToProfile() {\\r\\n    std::cout << \"Redirecting to profile page...\" << std::endl;\\r\\n    // Implementation for redirection (platform-specific)\\r\\n}\\r\\n\\r\\nbool isValidStockName(const std::string& stock_name) {\\r\\n    // Add validation logic for stock name\\r\\n    return !stock_name.empty();\\r\\n}\\r\\n\\r\\nbool isValidQuantity(int quantity) {\\r\\n    // Add validation logic for quantity\\r\\n    return quantity > 0;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::string username = \"user123\"; // Example username\\r\\n    std::string stock_name;\\r\\n    int stock_quantity;\\r\\n\\r\\n    std::cout << \"Enter stock name: \";\\r\\n    std::getline(std::cin, stock_name);\\r\\n    std::cout << \"Enter stock quantity: \";\\r\\n    std::cin >> stock_quantity;\\r\\n\\r\\n    if (!isValidStockName(stock_name) || !isValidQuantity(stock_quantity)) {\\r\\n        std::cerr << \"Invalid input.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    MYSQL *conn;\\r\\n    MYSQL_STMT *stmt;\\r\\n    MYSQL_BIND bind[3];\\r\\n    const char *server = \"localhost\";\\r\\n    const char *user = \"db_user\";\\r\\n    const char *password = \"db_password\";\\r\\n    const char *database = \"stock_db\";\\r\\n\\r\\n    conn = mysql_init(NULL);\\r\\n    if (conn == NULL) {\\r\\n        std::cerr << \"mysql_init() failed\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    if (mysql_real_connect(conn, server, user, password, database, 0, NULL, 0) == NULL) {\\r\\n        std::cerr << \"mysql_real_connect() failed\" << std::endl;\\r\\n        mysql_close(conn);\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    const char *query = \"INSERT INTO buy_orders (username, stock_name, stock_quantity) VALUES (?, ?, ?)\";\\r\\n    stmt = mysql_stmt_init(conn);\\r\\n    if (!stmt) {\\r\\n        std::cerr << \"mysql_stmt_init() failed\" << std::endl;\\r\\n        mysql_close(conn);\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_prepare(stmt, query, strlen(query))) {\\r\\n        std::cerr << \"mysql_stmt_prepare() failed\" << std::endl;\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    memset(bind, 0, sizeof(bind));\\r\\n\\r\\n    bind[0].buffer_type = MYSQL_TYPE_STRING;\\r\\n    bind[0].buffer = (char *)username.c_str();\\r\\n    bind[0].buffer_length = username.length();\\r\\n\\r\\n    bind[1].buffer_type = MYSQL_TYPE_STRING;\\r\\n    bind[1].buffer = (char *)stock_name.c_str();\\r\\n    bind[1].buffer_length = stock_name.length();\\r\\n\\r\\n    bind[2].buffer_type = MYSQL_TYPE_LONG;\\r\\n    bind[2].buffer = (char *)&stock_quantity;\\r\\n    bind[2].buffer_length = sizeof(stock_quantity);\\r\\n\\r\\n    if (mysql_stmt_bind_param(stmt, bind)) {\\r\\n        std::cerr << \"mysql_stmt_bind_param() failed\" << std::endl;\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_execute(stmt)) {\\r\\n        std::cerr << \"mysql_stmt_execute() failed\" << std::endl;\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    mysql_stmt_close(stmt);\\r\\n    mysql_close(conn);\\r\\n\\r\\n    redirectToProfile();\\r\\n    return 0;\\r\\n}", "CWE": "CWE-89"}
{"text": "Generate C++ code for the following: Create a new route called /post. It gets the username and message from the request. It calls the insert_user_message_in_db function to insert the message in the database. It redirects the user to the / route. Now add the code to display the messages.", "BP": ["Input Validation", "Parameterized Queries", "Separation of Concerns", "Error Handling", "Secure Coding Practices", "Secure Configuration Management"], "code": "#include <iostream>\\r\\n#include <string>\\r\\n#include <regex>\\r\\n#include <vector>\\r\\n#include <mysql/mysql.h> // MySQL Connector/C++ library\\r\\n#include <cstdlib> // For getenv\\r\\n\\r\\nvoid redirect_to_home() {\\r\\n    std::cout << \"Location: /\\n\\n\";\\r\\n}\\r\\n\\r\\nbool validate_input(const std::string& input) {\\r\\n    std::regex pattern(\"^[A-Za-z0-9_ ]+$\");\\r\\n    return std::regex_match(input, pattern);\\r\\n}\\r\\n\\r\\nvoid insert_user_message_in_db(const std::string& username, const std::string& message) {\\r\\n    MYSQL *conn;\\r\\n    MYSQL_STMT *stmt;\\r\\n    MYSQL_BIND bind[2];\\r\\n    const char *server = getenv(\"DB_SERVER\");\\r\\n    const char *user = getenv(\"DB_USER\");\\r\\n    const char *password = getenv(\"DB_PASSWORD\");\\r\\n    const char *database = getenv(\"DB_NAME\");\\r\\n\\r\\n    conn = mysql_init(NULL);\\r\\n    if (conn == NULL) {\\r\\n        throw std::runtime_error(\"mysql_init() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_real_connect(conn, server, user, password, database, 0, NULL, 0) == NULL) {\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_real_connect() failed\");\\r\\n    }\\r\\n\\r\\n    stmt = mysql_stmt_init(conn);\\r\\n    if (!stmt) {\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_stmt_init() failed\");\\r\\n    }\\r\\n\\r\\n    const char *query = \"INSERT INTO messages (username, message) VALUES (?, ?)\";\\r\\n    if (mysql_stmt_prepare(stmt, query, strlen(query))) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_stmt_prepare() failed\");\\r\\n    }\\r\\n\\r\\n    memset(bind, 0, sizeof(bind));\\r\\n\\r\\n    bind[0].buffer_type = MYSQL_TYPE_STRING;\\r\\n    bind[0].buffer = (char *)username.c_str();\\r\\n    bind[0].buffer_length = username.length();\\r\\n\\r\\n    bind[1].buffer_type = MYSQL_TYPE_STRING;\\r\\n    bind[1].buffer = (char *)message.c_str();\\r\\n    bind[1].buffer_length = message.length();\\r\\n\\r\\n    if (mysql_stmt_bind_param(stmt, bind)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_stmt_bind_param() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_execute(stmt)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_stmt_execute() failed\");\\r\\n    }\\r\\n\\r\\n    mysql_stmt_close(stmt);\\r\\n    mysql_close(conn);\\r\\n}\\r\\n\\r\\nstd::vector<std::pair<std::string, std::string>> get_messages_from_db() {\\r\\n    MYSQL *conn;\\r\\n    MYSQL_STMT *stmt;\\r\\n    MYSQL_BIND bind[2];\\r\\n    MYSQL_RES *prepare_meta_result;\\r\\n    MYSQL_BIND result[2];\\r\\n    std::vector<std::pair<std::string, std::string>> messages;\\r\\n    const char *server = getenv(\"DB_SERVER\");\\r\\n    const char *user = getenv(\"DB_USER\");\\r\\n    const char *password = getenv(\"DB_PASSWORD\");\\r\\n    const char *database = getenv(\"DB_NAME\");\\r\\n\\r\\n    conn = mysql_init(NULL);\\r\\n    if (conn == NULL) {\\r\\n        throw std::runtime_error(\"mysql_init() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_real_connect(conn, server, user, password, database, 0, NULL, 0) == NULL) {\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_real_connect() failed\");\\r\\n    }\\r\\n\\r\\n    stmt = mysql_stmt_init(conn);\\r\\n    if (!stmt) {\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_stmt_init() failed\");\\r\\n    }\\r\\n\\r\\n    const char *query = \"SELECT username, message FROM messages\";\\r\\n    if (mysql_stmt_prepare(stmt, query, strlen(query))) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_stmt_prepare() failed\");\\r\\n    }\\r\\n\\r\\n    prepare_meta_result = mysql_stmt_result_metadata(stmt);\\r\\n    if (!prepare_meta_result) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_stmt_result_metadata() failed\");\\r\\n    }\\r\\n\\r\\n    memset(result, 0, sizeof(result));\\r\\n\\r\\n    char username[64];\\r\\n    char message[256];\\r\\n\\r\\n    result[0].buffer_type = MYSQL_TYPE_STRING;\\r\\n    result[0].buffer = username;\\r\\n    result[0].buffer_length = sizeof(username);\\r\\n\\r\\n    result[1].buffer_type = MYSQL_TYPE_STRING;\\r\\n    result[1].buffer = message;\\r\\n    result[1].buffer_length = sizeof(message);\\r\\n\\r\\n    if (mysql_stmt_bind_result(stmt, result)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_stmt_bind_result() failed\");\\r\\n    }\\r\\n\\r\\n    if (mysql_stmt_execute(stmt)) {\\r\\n        mysql_stmt_close(stmt);\\r\\n        mysql_close(conn);\\r\\n        throw std::runtime_error(\"mysql_stmt_execute() failed\");\\r\\n    }\\r\\n\\r\\n    while (!mysql_stmt_fetch(stmt)) {\\r\\n        messages.emplace_back(username, message);\\r\\n    }\\r\\n\\r\\n    mysql_stmt_close(stmt);\\r\\n    mysql_close(conn);\\r\\n\\r\\n    return messages;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    std::string username;\\r\\n    std::string message;\\r\\n\\r\\n    std::cout << \"Enter username: \";\\r\\n    std::cin >> username;\\r\\n    std::cout << \"Enter message: \";\\r\\n    std::cin.ignore();\\r\\n    std::getline(std::cin, message);\\r\\n\\r\\n    if (!validate_input(username) || !validate_input(message)) {\\r\\n        std::cerr << \"Invalid input.\" << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n        insert_user_message_in_db(username, message);\\r\\n        redirect_to_home();\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << e.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    std::vector<std::pair<std::string, std::string>> messages;\\r\\n    try {\\r\\n        messages = get_messages_from_db();\\r\\n    } catch (const std::exception& e) {\\r\\n        std::cerr << e.what() << std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    for (const auto& msg : messages) {\\r\\n        std::cout << msg.first << \": \" << msg.second << std::endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}", "CWE": "CWE-89"}
